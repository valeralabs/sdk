// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"gopkg.in/yaml.v2"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/labstack/echo/v4"
	"github.com/gin-gonic/gin"
)







// GetAddressMempoolTransactionsParams defines parameters for GetAddressMempoolTransactions.
type GetAddressMempoolTransactionsParams  struct {
// max number of transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// GetAccountAssetsParams defines parameters for GetAccountAssets.
type GetAccountAssetsParams  struct {
// max number of account assets to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first account assets to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state at that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountBalanceParams defines parameters for GetAccountBalance.
type GetAccountBalanceParams  struct {
// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountNftParams defines parameters for GetAccountNft.
type GetAccountNftParams  struct {
// number of items to return
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// number of items to skip
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountNoncesParams defines parameters for GetAccountNonces.
type GetAccountNoncesParams  struct {
// Optionally get the nonce at a given block height
    BlockHeight *float32`form:"block_height,omitempty" json:"block_height,omitempty"`

// Optionally get the nonce at a given block hash
    BlockHash *string`form:"block_hash,omitempty" json:"block_hash,omitempty"`
}



// GetAccountStxBalanceParams defines parameters for GetAccountStxBalance.
type GetAccountStxBalanceParams  struct {
// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountInboundParams defines parameters for GetAccountInbound.
type GetAccountInboundParams  struct {
// number of items to return
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// number of items to skip
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Filter for transfers only at this given block height
    Height *float32`form:"height,omitempty" json:"height,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountTransactionsParams defines parameters for GetAccountTransactions.
type GetAccountTransactionsParams  struct {
// max number of account transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first account transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Filter for transactions only at this given block height
    Height *float32`form:"height,omitempty" json:"height,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}



// GetAccountTransactionsWithTransfersParams defines parameters for GetAccountTransactionsWithTransfers.
type GetAccountTransactionsWithTransfersParams  struct {
// max number of account transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first account transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Filter for transactions only at this given block height
    Height *float32`form:"height,omitempty" json:"height,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// returned data representing the state up until that point in time, rather than the current block.
    UntilBlock *string`form:"until_block,omitempty" json:"until_block,omitempty"`
}





// GetBlockListParams defines parameters for GetBlockList.
type GetBlockListParams  struct {
// max number of blocks to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first block to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}











// GetBurnchainRewardSlotHoldersParams defines parameters for GetBurnchainRewardSlotHolders.
type GetBurnchainRewardSlotHoldersParams  struct {
// max number of items to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of the first items to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetBurnchainRewardSlotHoldersByAddressParams defines parameters for GetBurnchainRewardSlotHoldersByAddress.
type GetBurnchainRewardSlotHoldersByAddressParams  struct {
// max number of items to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of the first items to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetBurnchainRewardListParams defines parameters for GetBurnchainRewardList.
type GetBurnchainRewardListParams  struct {
// max number of rewards to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first rewards to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetBurnchainRewardListByAddressParams defines parameters for GetBurnchainRewardListByAddress.
type GetBurnchainRewardListByAddressParams  struct {
// max number of rewards to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first rewards to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}





// GetContractsByTraitParams defines parameters for GetContractsByTrait.
type GetContractsByTraitParams  struct {
// JSON abi of the trait.
    TraitAbi string`form:"trait_abi" json:"trait_abi"`

// max number of contracts fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first contract event to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetContractByIdParams defines parameters for GetContractById.
type GetContractByIdParams  struct {
// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// GetContractEventsByIdParams defines parameters for GetContractEventsById.
type GetContractEventsByIdParams  struct {
// max number of contract events to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first contract event to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// RunFaucetBtcJSONBody defines parameters for RunFaucetBtc.
type RunFaucetBtcJSONBody  struct {
// BTC testnet address
    Address *string`json:"address,omitempty"`
}

// RunFaucetBtcParams defines parameters for RunFaucetBtc.
type RunFaucetBtcParams  struct {
// A valid testnet BTC address
    Address string`form:"address" json:"address"`
}



// RunFaucetStxJSONBody defines parameters for RunFaucetStx.
type RunFaucetStxJSONBody  struct {
// STX testnet address
    Address *string`json:"address,omitempty"`

// Use required number of tokens for stacking
    Stacking *bool`json:"stacking,omitempty"`
}

// RunFaucetStxParams defines parameters for RunFaucetStx.
type RunFaucetStxParams  struct {
// A valid testnet STX address
    Address string`form:"address" json:"address"`

// Request the amount of STX tokens needed for individual address stacking
    Stacking *bool`form:"stacking,omitempty" json:"stacking,omitempty"`
}



// FetchFeeRateJSONBody defines parameters for FetchFeeRate.
type FetchFeeRateJSONBody  struct {
// A serialized transaction
    Transaction string`json:"transaction"`
}



// GetNetworkBlockTimeByNetworkParamsNetwork defines parameters for GetNetworkBlockTimeByNetwork.
type GetNetworkBlockTimeByNetworkParamsNetwork  string





// GetMicroblockListParams defines parameters for GetMicroblockList.
type GetMicroblockListParams  struct {
// Max number of microblocks to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// Index of the first microblock to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}







// SearchByIdParams defines parameters for SearchById.
type SearchByIdParams  struct {
// This includes the detailed data for purticular hash in the response
    IncludeMetadata *bool`form:"include_metadata,omitempty" json:"include_metadata,omitempty"`
}





// GetStxSupplyParams defines parameters for GetStxSupply.
type GetStxSupplyParams  struct {
// The block height at which to query supply details from, if not provided then the latest block height is used
    Height *float32`form:"height,omitempty" json:"height,omitempty"`
}





// GetTotalStxSupplyLegacyFormatParams defines parameters for GetTotalStxSupplyLegacyFormat.
type GetTotalStxSupplyLegacyFormatParams  struct {
// The block height at which to query supply details from, if not provided then the latest block height is used
    Height *float32`form:"height,omitempty" json:"height,omitempty"`
}





// GetFtMetadataListParams defines parameters for GetFtMetadataList.
type GetFtMetadataListParams  struct {
// max number of tokens to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first tokens to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetNftHistoryParams defines parameters for GetNftHistory.
type GetNftHistoryParams  struct {
// token asset class identifier
    AssetIdentifier string`form:"asset_identifier" json:"asset_identifier"`

// hex representation of the token's unique value
    Value string`form:"value" json:"value"`

// max number of events to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first event to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// whether or not to include events from unconfirmed transactions
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
    TxMetadata *bool`form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}



// GetNftHoldingsParams defines parameters for GetNftHoldings.
type GetNftHoldingsParams  struct {
// token owner's STX address or Smart Contract ID
    Principal string`form:"principal" json:"principal"`

// identifiers of the token asset classes to filter for
    AssetIdentifiers *[]string`form:"asset_identifiers,omitempty" json:"asset_identifiers,omitempty"`

// max number of tokens to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first tokens to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// whether or not to include tokens from unconfirmed transactions
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
    TxMetadata *bool`form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}



// GetNftMetadataListParams defines parameters for GetNftMetadataList.
type GetNftMetadataListParams  struct {
// max number of tokens to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first tokens to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetNftMintsParams defines parameters for GetNftMints.
type GetNftMintsParams  struct {
// token asset class identifier
    AssetIdentifier string`form:"asset_identifier" json:"asset_identifier"`

// max number of events to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first event to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// whether or not to include events from unconfirmed transactions
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`

// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
    TxMetadata *bool`form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}







// GetTransactionListParams defines parameters for GetTransactionList.
type GetTransactionListParams  struct {
// max number of transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Filter by transaction type
    Type *[]GetTransactionListParamsType`form:"type,omitempty" json:"type,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetTransactionListParamsType defines parameters for GetTransactionList.
type GetTransactionListParamsType  string



// GetTransactionsByBlockHashParams defines parameters for GetTransactionsByBlockHash.
type GetTransactionsByBlockHashParams  struct {
// max number of transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetTransactionsByBlockHeightParams defines parameters for GetTransactionsByBlockHeight.
type GetTransactionsByBlockHeightParams  struct {
// max number of transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// GetFilteredEventsParams defines parameters for GetFilteredEvents.
type GetFilteredEventsParams  struct {
// Hash of transaction
    TxId *string`form:"tx_id,omitempty" json:"tx_id,omitempty"`

// Stacks address or a Contract identifier
    Address *string`form:"address,omitempty" json:"address,omitempty"`

// number of items to return
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// number of items to skip
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Filter the events on event type
    Type *[]GetFilteredEventsParamsType`form:"type,omitempty" json:"type,omitempty"`
}

// GetFilteredEventsParamsType defines parameters for GetFilteredEvents.
type GetFilteredEventsParamsType  string



// GetMempoolTransactionListParams defines parameters for GetMempoolTransactionList.
type GetMempoolTransactionListParams  struct {
// Filter to only return transactions with this sender address.
    SenderAddress *string`form:"sender_address,omitempty" json:"sender_address,omitempty"`

// Filter to only return transactions with this recipient address (only applicable for STX transfer tx types).
    RecipientAddress *string`form:"recipient_address,omitempty" json:"recipient_address,omitempty"`

// Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types).
    Address *string`form:"address,omitempty" json:"address,omitempty"`

// max number of mempool transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first mempool transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// GetDroppedMempoolTransactionListParams defines parameters for GetDroppedMempoolTransactionList.
type GetDroppedMempoolTransactionListParams  struct {
// max number of mempool transactions to fetch
    Limit *int`form:"limit,omitempty" json:"limit,omitempty"`

// index of first mempool transaction to fetch
    Offset *int`form:"offset,omitempty" json:"offset,omitempty"`
}



// GetTxListDetailsParams defines parameters for GetTxListDetails.
type GetTxListDetailsParams  struct {
// Array of transaction ids
    TxId []string`form:"tx_id" json:"tx_id"`

// The number of events to skip
    EventOffset *int`form:"event_offset,omitempty" json:"event_offset,omitempty"`

// The numbers of events to return
    EventLimit *int`form:"event_limit,omitempty" json:"event_limit,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}



// GetTransactionByIdParams defines parameters for GetTransactionById.
type GetTransactionByIdParams  struct {
// The number of events to skip
    EventOffset *int`form:"event_offset,omitempty" json:"event_offset,omitempty"`

// The numbers of events to return
    EventLimit *int`form:"event_limit,omitempty" json:"event_limit,omitempty"`

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
    Unanchored *bool`form:"unanchored,omitempty" json:"unanchored,omitempty"`
}





// RosettaAccountBalanceJSONBody defines parameters for RosettaAccountBalance.
type RosettaAccountBalanceJSONBody  struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier"`

// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
    BlockIdentifier *interface{}`json:"block_identifier,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
}



// RosettaBlockJSONBody defines parameters for RosettaBlock.
type RosettaBlockJSONBody  struct {
// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
    BlockIdentifier interface{}`json:"block_identifier"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
}



// RosettaBlockTransactionJSONBody defines parameters for RosettaBlockTransaction.
type RosettaBlockTransactionJSONBody  struct {
// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
    BlockIdentifier interface{}`json:"block_identifier"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}



// RosettaConstructionCombineJSONBody defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
    Signatures []struct {
    HexBytes string`json:"hex_bytes"`

// PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
    PublicKey struct {
// CurveType is the type of cryptographic curve associated with a PublicKey.
    CurveType RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType`json:"curve_type"`

// Hex-encoded public key bytes in the format specified by the CurveType.
    HexBytes string`json:"hex_bytes"`
}`json:"public_key"`

// SignatureType is the type of a cryptographic signature.
    SignatureType RosettaConstructionCombineJSONBodySignaturesSignatureType`json:"signature_type"`

// SigningPayload is signed by the client with the keypair associated with an address using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
    SigningPayload struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier,omitempty"`

// [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
    Address *string`json:"address,omitempty"`
    HexBytes string`json:"hex_bytes"`

// SignatureType is the type of a cryptographic signature.
    SignatureType *RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType`json:"signature_type,omitempty"`
}`json:"signing_payload"`
}`json:"signatures"`
    UnsignedTransaction string`json:"unsigned_transaction"`
}

// RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType  string

// RosettaConstructionCombineJSONBodySignaturesSignatureType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesSignatureType  string

// RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType  string



// RosettaConstructionDeriveJSONBody defines parameters for RosettaConstructionDerive.
type RosettaConstructionDeriveJSONBody  struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
    PublicKey struct {
// CurveType is the type of cryptographic curve associated with a PublicKey.
    CurveType RosettaConstructionDeriveJSONBodyPublicKeyCurveType`json:"curve_type"`

// Hex-encoded public key bytes in the format specified by the CurveType.
    HexBytes string`json:"hex_bytes"`
}`json:"public_key"`
}

// RosettaConstructionDeriveJSONBodyPublicKeyCurveType defines parameters for RosettaConstructionDerive.
type RosettaConstructionDeriveJSONBodyPublicKeyCurveType  string



// RosettaConstructionHashJSONBody defines parameters for RosettaConstructionHash.
type RosettaConstructionHashJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// Signed transaction
    SignedTransaction string`json:"signed_transaction"`
}



// RosettaConstructionMetadataJSONBody defines parameters for RosettaConstructionMetadata.
type RosettaConstructionMetadataJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// The options that will be sent directly to /construction/metadata by the caller.
    Options struct {
// Amount to be transfered.
    Amount *string`json:"amount,omitempty"`

// Set the burnchain (BTC) block for stacking lock to start.
    BurnBlockHeight *int`json:"burn_block_height,omitempty"`

// Address of the contract to call.
    ContractAddress *string`json:"contract_address,omitempty"`

// Name of the contract to call.
    ContractName *string`json:"contract_name,omitempty"`

// Number of decimal places
    Decimals *int`json:"decimals,omitempty"`

// Delegator address for when calling `delegate-stacking`.
    DelegateTo *string`json:"delegate_to,omitempty"`

// Fee for this transaction
    Fee *string`json:"fee,omitempty"`

// Maximum price a user is willing to pay.
    GasLimit *float32`json:"gas_limit,omitempty"`

// Cost necessary to perform a transaction on the network
    GasPrice *float32`json:"gas_price,omitempty"`

// Maximum fee user is willing to pay
    MaxFee *string`json:"max_fee,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// Number of cycles when stacking.
    NumberOfCycles *int`json:"number_of_cycles,omitempty"`

// The reward address for stacking transaction. It should be a valid Bitcoin address
    PoxAddr *string`json:"pox_addr,omitempty"`

// sender's address 
    SenderAddress *string`json:"sender_address,omitempty"`

// Transaction approximative size (used to calculate total fee).
    Size *int`json:"size,omitempty"`

// This value indicates the state of the operations
    Status *string`json:"status,omitempty"`

//  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
    SuggestedFeeMultiplier *float32`json:"suggested_fee_multiplier,omitempty"`

// Currency symbol e.g STX
    Symbol *string`json:"symbol,omitempty"`

// Recipient's address
    TokenTransferRecipientAddress *string`json:"token_transfer_recipient_address,omitempty"`

// Type of operation e.g transfer
    Type *string`json:"type,omitempty"`
}`json:"options"`
    PublicKeys *[]struct {
// CurveType is the type of cryptographic curve associated with a PublicKey.
    CurveType RosettaConstructionMetadataJSONBodyPublicKeysCurveType`json:"curve_type"`

// Hex-encoded public key bytes in the format specified by the CurveType.
    HexBytes string`json:"hex_bytes"`
}`json:"public_keys,omitempty"`
}

// RosettaConstructionMetadataJSONBodyPublicKeysCurveType defines parameters for RosettaConstructionMetadata.
type RosettaConstructionMetadataJSONBodyPublicKeysCurveType  string



// RosettaConstructionParseJSONBody defines parameters for RosettaConstructionParse.
type RosettaConstructionParseJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// Signed is a boolean indicating whether the transaction is signed.
    Signed bool`json:"signed"`

// This must be either the unsigned transaction blob returned by /construction/payloads or the signed transaction blob returned by /construction/combine.
    Transaction string`json:"transaction"`
}



// RosettaConstructionPayloadsJSONBody defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBody  struct {
    Metadata *struct {
    AccountSequence *int`json:"account_sequence,omitempty"`
    RecentBlockHash *string`json:"recent_block_hash,omitempty"`
}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`
    PublicKeys *[]struct {
// CurveType is the type of cryptographic curve associated with a PublicKey.
    CurveType RosettaConstructionPayloadsJSONBodyPublicKeysCurveType`json:"curve_type"`

// Hex-encoded public key bytes in the format specified by the CurveType.
    HexBytes string`json:"hex_bytes"`
}`json:"public_keys,omitempty"`
}

// RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction  string

// RosettaConstructionPayloadsJSONBodyPublicKeysCurveType defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBodyPublicKeysCurveType  string



// RosettaConstructionPreprocessJSONBody defines parameters for RosettaConstructionPreprocess.
type RosettaConstructionPreprocessJSONBody  struct {
    MaxFee *[]struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"max_fee,omitempty"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

//  The caller can also provide a suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency. It is assumed that providing a very low multiplier (like 0.0001) will never lead to a transaction being created with a fee less than the minimum network fee (if applicable). In the case that the caller provides both a max fee and a suggested fee multiplier, the max fee will set an upper bound on the suggested fee (regardless of the multiplier provided).
    SuggestedFeeMultiplier *int`json:"suggested_fee_multiplier,omitempty"`
}

// RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction defines parameters for RosettaConstructionPreprocess.
type RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction  string



// RosettaConstructionSubmitJSONBody defines parameters for RosettaConstructionSubmit.
type RosettaConstructionSubmitJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// Signed transaction
    SignedTransaction string`json:"signed_transaction"`
}



// RosettaMempoolJSONBody defines parameters for RosettaMempool.
type RosettaMempoolJSONBody  struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
}



// RosettaMempoolTransactionJSONBody defines parameters for RosettaMempoolTransaction.
type RosettaMempoolTransactionJSONBody  struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}





// RosettaNetworkOptionsJSONBody defines parameters for RosettaNetworkOptions.
type RosettaNetworkOptionsJSONBody  struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
}



// RosettaNetworkStatusJSONBody defines parameters for RosettaNetworkStatus.
type RosettaNetworkStatusJSONBody  struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifier struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifier"`
}





// GetAllNamesParams defines parameters for GetAllNames.
type GetAllNamesParams  struct {
// names are returned in pages of size 100, so specify the page number.
    Page int`form:"page" json:"page"`
}













// GetNamespaceNamesParams defines parameters for GetNamespaceNames.
type GetNamespaceNamesParams  struct {
// names are returned in pages of size 100, so specify the page number.
    Page int`form:"page" json:"page"`
}



// GetAccountInfoParams defines parameters for GetAccountInfo.
type GetAccountInfoParams  struct {
// Returns object without the proof field if set to 0
    Proof *int`form:"proof,omitempty" json:"proof,omitempty"`

// The Stacks chain tip to query from
    Tip *string`form:"tip,omitempty" json:"tip,omitempty"`
}



// CallReadOnlyFunctionJSONBody defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionJSONBody  struct {
// An array of hex serialized Clarity values
    Arguments []string`json:"arguments"`

// The simulated tx-sender
    Sender string`json:"sender"`
}

// CallReadOnlyFunctionParams defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionParams  struct {
// The Stacks chain tip to query from
    Tip *string`form:"tip,omitempty" json:"tip,omitempty"`
}



// GetContractInterfaceParams defines parameters for GetContractInterface.
type GetContractInterfaceParams  struct {
// The Stacks chain tip to query from
    Tip *string`form:"tip,omitempty" json:"tip,omitempty"`
}



// GetContractSourceParams defines parameters for GetContractSource.
type GetContractSourceParams  struct {
// Returns object without the proof field if set to 0
    Proof *int`form:"proof,omitempty" json:"proof,omitempty"`

// The Stacks chain tip to query from
    Tip *string`form:"tip,omitempty" json:"tip,omitempty"`
}



// PostFeeTransactionJSONBody defines parameters for PostFeeTransaction.
type PostFeeTransactionJSONBody  struct {
    EstimatedLen *int`json:"estimated_len,omitempty"`
    TransactionPayload string`json:"transaction_payload"`
}







// GetContractDataMapEntryJSONBody defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryJSONBody = string

// GetContractDataMapEntryParams defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryParams  struct {
// Returns object without the proof field when set to 0
    Proof *int`form:"proof,omitempty" json:"proof,omitempty"`

// The Stacks chain tip to query from
    Tip *string`form:"tip,omitempty" json:"tip,omitempty"`
}




























































// RunFaucetBtcJSONRequestBody defines body for RunFaucetBtc for application/json ContentType.
type RunFaucetBtcJSONRequestBody  RunFaucetBtcJSONBody





// RunFaucetStxJSONRequestBody defines body for RunFaucetStx for application/json ContentType.
type RunFaucetStxJSONRequestBody  RunFaucetStxJSONBody





// FetchFeeRateJSONRequestBody defines body for FetchFeeRate for application/json ContentType.
type FetchFeeRateJSONRequestBody  FetchFeeRateJSONBody



























































// RosettaAccountBalanceJSONRequestBody defines body for RosettaAccountBalance for application/json ContentType.
type RosettaAccountBalanceJSONRequestBody  RosettaAccountBalanceJSONBody





// RosettaBlockJSONRequestBody defines body for RosettaBlock for application/json ContentType.
type RosettaBlockJSONRequestBody  RosettaBlockJSONBody





// RosettaBlockTransactionJSONRequestBody defines body for RosettaBlockTransaction for application/json ContentType.
type RosettaBlockTransactionJSONRequestBody  RosettaBlockTransactionJSONBody





// RosettaConstructionCombineJSONRequestBody defines body for RosettaConstructionCombine for application/json ContentType.
type RosettaConstructionCombineJSONRequestBody  RosettaConstructionCombineJSONBody





// RosettaConstructionDeriveJSONRequestBody defines body for RosettaConstructionDerive for application/json ContentType.
type RosettaConstructionDeriveJSONRequestBody  RosettaConstructionDeriveJSONBody





// RosettaConstructionHashJSONRequestBody defines body for RosettaConstructionHash for application/json ContentType.
type RosettaConstructionHashJSONRequestBody  RosettaConstructionHashJSONBody





// RosettaConstructionMetadataJSONRequestBody defines body for RosettaConstructionMetadata for application/json ContentType.
type RosettaConstructionMetadataJSONRequestBody  RosettaConstructionMetadataJSONBody





// RosettaConstructionParseJSONRequestBody defines body for RosettaConstructionParse for application/json ContentType.
type RosettaConstructionParseJSONRequestBody  RosettaConstructionParseJSONBody





// RosettaConstructionPayloadsJSONRequestBody defines body for RosettaConstructionPayloads for application/json ContentType.
type RosettaConstructionPayloadsJSONRequestBody  RosettaConstructionPayloadsJSONBody





// RosettaConstructionPreprocessJSONRequestBody defines body for RosettaConstructionPreprocess for application/json ContentType.
type RosettaConstructionPreprocessJSONRequestBody  RosettaConstructionPreprocessJSONBody





// RosettaConstructionSubmitJSONRequestBody defines body for RosettaConstructionSubmit for application/json ContentType.
type RosettaConstructionSubmitJSONRequestBody  RosettaConstructionSubmitJSONBody





// RosettaMempoolJSONRequestBody defines body for RosettaMempool for application/json ContentType.
type RosettaMempoolJSONRequestBody  RosettaMempoolJSONBody





// RosettaMempoolTransactionJSONRequestBody defines body for RosettaMempoolTransaction for application/json ContentType.
type RosettaMempoolTransactionJSONRequestBody  RosettaMempoolTransactionJSONBody







// RosettaNetworkOptionsJSONRequestBody defines body for RosettaNetworkOptions for application/json ContentType.
type RosettaNetworkOptionsJSONRequestBody  RosettaNetworkOptionsJSONBody





// RosettaNetworkStatusJSONRequestBody defines body for RosettaNetworkStatus for application/json ContentType.
type RosettaNetworkStatusJSONRequestBody  RosettaNetworkStatusJSONBody























// CallReadOnlyFunctionJSONRequestBody defines body for CallReadOnlyFunction for application/json ContentType.
type CallReadOnlyFunctionJSONRequestBody  CallReadOnlyFunctionJSONBody









// PostFeeTransactionJSONRequestBody defines body for PostFeeTransaction for application/json ContentType.
type PostFeeTransactionJSONRequestBody  PostFeeTransactionJSONBody









// GetContractDataMapEntryJSONRequestBody defines body for GetContractDataMapEntry for application/json ContentType.
type GetContractDataMapEntryJSONRequestBody = GetContractDataMapEntryJSONBody














// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
    // create a client with sane default values
    client := Client{
        Server: server,
    }
    // mutate client and add all optional params
    for _, o := range opts {
        if err := o(&client); err != nil {
            return nil, err
        }
    }
    // ensure the server URL always has a trailing slash
    if !strings.HasSuffix(client.Server, "/") {
        client.Server += "/"
    }
    // create httpClient, if not already present
    if client.Client == nil {
        client.Client = &http.Client{}
    }
    return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
// GetAddressMempoolTransactions request
    GetAddressMempoolTransactions(ctx context.Context, address string, params *GetAddressMempoolTransactionsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountAssets request
    GetAccountAssets(ctx context.Context, principal string, params *GetAccountAssetsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountBalance request
    GetAccountBalance(ctx context.Context, principal string, params *GetAccountBalanceParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountNft request
    GetAccountNft(ctx context.Context, principal string, params *GetAccountNftParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountNonces request
    GetAccountNonces(ctx context.Context, principal string, params *GetAccountNoncesParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountStxBalance request
    GetAccountStxBalance(ctx context.Context, principal string, params *GetAccountStxBalanceParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountInbound request
    GetAccountInbound(ctx context.Context, principal string, params *GetAccountInboundParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountTransactions request
    GetAccountTransactions(ctx context.Context, principal string, params *GetAccountTransactionsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountTransactionsWithTransfers request
    GetAccountTransactionsWithTransfers(ctx context.Context, principal string, params *GetAccountTransactionsWithTransfersParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetSingleTransactionWithTransfers request
    GetSingleTransactionWithTransfers(ctx context.Context, principal string, txId string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBlockList request
    GetBlockList(ctx context.Context, params *GetBlockListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBlockByBurnBlockHash request
    GetBlockByBurnBlockHash(ctx context.Context, burnBlockHash string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBlockByBurnBlockHeight request
    GetBlockByBurnBlockHeight(ctx context.Context, burnBlockHeight float32, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBlockByHeight request
    GetBlockByHeight(ctx context.Context, height float32, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBlockByHash request
    GetBlockByHash(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBurnchainRewardSlotHolders request
    GetBurnchainRewardSlotHolders(ctx context.Context, params *GetBurnchainRewardSlotHoldersParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBurnchainRewardSlotHoldersByAddress request
    GetBurnchainRewardSlotHoldersByAddress(ctx context.Context, address string, params *GetBurnchainRewardSlotHoldersByAddressParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBurnchainRewardList request
    GetBurnchainRewardList(ctx context.Context, params *GetBurnchainRewardListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBurnchainRewardListByAddress request
    GetBurnchainRewardListByAddress(ctx context.Context, address string, params *GetBurnchainRewardListByAddressParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetBurnchainRewardsTotalByAddress request
    GetBurnchainRewardsTotalByAddress(ctx context.Context, address string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractsByTrait request
    GetContractsByTrait(ctx context.Context, params *GetContractsByTraitParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractById request
    GetContractById(ctx context.Context, contractId string, params *GetContractByIdParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractEventsById request
    GetContractEventsById(ctx context.Context, contractId string, params *GetContractEventsByIdParams, reqEditors... RequestEditorFn) (*http.Response, error)

// RunFaucetBtc request with any body
    RunFaucetBtcWithBody(ctx context.Context, params *RunFaucetBtcParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RunFaucetBtc(ctx context.Context, params *RunFaucetBtcParams, body RunFaucetBtcJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RunFaucetStx request with any body
    RunFaucetStxWithBody(ctx context.Context, params *RunFaucetStxParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RunFaucetStx(ctx context.Context, params *RunFaucetStxParams, body RunFaucetStxJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// FetchFeeRate request with any body
    FetchFeeRateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    FetchFeeRate(ctx context.Context, body FetchFeeRateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNetworkBlockTimeByNetwork request
    GetNetworkBlockTimeByNetwork(ctx context.Context, network GetNetworkBlockTimeByNetworkParamsNetwork, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNetworkBlockTimes request
    GetNetworkBlockTimes(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetMicroblockList request
    GetMicroblockList(ctx context.Context, params *GetMicroblockListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetUnanchoredTxs request
    GetUnanchoredTxs(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetMicroblockByHash request
    GetMicroblockByHash(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*http.Response, error)

// SearchById request
    SearchById(ctx context.Context, id string, params *SearchByIdParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetStatus request
    GetStatus(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetStxSupply request
    GetStxSupply(ctx context.Context, params *GetStxSupplyParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetStxSupplyCirculatingPlain request
    GetStxSupplyCirculatingPlain(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTotalStxSupplyLegacyFormat request
    GetTotalStxSupplyLegacyFormat(ctx context.Context, params *GetTotalStxSupplyLegacyFormatParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetStxSupplyTotalSupplyPlain request
    GetStxSupplyTotalSupplyPlain(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetFtMetadataList request
    GetFtMetadataList(ctx context.Context, params *GetFtMetadataListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNftHistory request
    GetNftHistory(ctx context.Context, params *GetNftHistoryParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNftHoldings request
    GetNftHoldings(ctx context.Context, params *GetNftHoldingsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNftMetadataList request
    GetNftMetadataList(ctx context.Context, params *GetNftMetadataListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNftMints request
    GetNftMints(ctx context.Context, params *GetNftMintsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractFtMetadata request
    GetContractFtMetadata(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractNftMetadata request
    GetContractNftMetadata(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTransactionList request
    GetTransactionList(ctx context.Context, params *GetTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTransactionsByBlockHash request
    GetTransactionsByBlockHash(ctx context.Context, blockHash string, params *GetTransactionsByBlockHashParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTransactionsByBlockHeight request
    GetTransactionsByBlockHeight(ctx context.Context, height int, params *GetTransactionsByBlockHeightParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetFilteredEvents request
    GetFilteredEvents(ctx context.Context, params *GetFilteredEventsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetMempoolTransactionList request
    GetMempoolTransactionList(ctx context.Context, params *GetMempoolTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetDroppedMempoolTransactionList request
    GetDroppedMempoolTransactionList(ctx context.Context, params *GetDroppedMempoolTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTxListDetails request
    GetTxListDetails(ctx context.Context, params *GetTxListDetailsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTransactionById request
    GetTransactionById(ctx context.Context, txId string, params *GetTransactionByIdParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetRawTransactionById request
    GetRawTransactionById(ctx context.Context, txId string, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaAccountBalance request with any body
    RosettaAccountBalanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaAccountBalance(ctx context.Context, body RosettaAccountBalanceJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaBlock request with any body
    RosettaBlockWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaBlock(ctx context.Context, body RosettaBlockJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaBlockTransaction request with any body
    RosettaBlockTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaBlockTransaction(ctx context.Context, body RosettaBlockTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionCombine request with any body
    RosettaConstructionCombineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionCombine(ctx context.Context, body RosettaConstructionCombineJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionDerive request with any body
    RosettaConstructionDeriveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionDerive(ctx context.Context, body RosettaConstructionDeriveJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionHash request with any body
    RosettaConstructionHashWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionHash(ctx context.Context, body RosettaConstructionHashJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionMetadata request with any body
    RosettaConstructionMetadataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionMetadata(ctx context.Context, body RosettaConstructionMetadataJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionParse request with any body
    RosettaConstructionParseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionParse(ctx context.Context, body RosettaConstructionParseJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionPayloads request with any body
    RosettaConstructionPayloadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionPayloads(ctx context.Context, body RosettaConstructionPayloadsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionPreprocess request with any body
    RosettaConstructionPreprocessWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionPreprocess(ctx context.Context, body RosettaConstructionPreprocessJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaConstructionSubmit request with any body
    RosettaConstructionSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaConstructionSubmit(ctx context.Context, body RosettaConstructionSubmitJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaMempool request with any body
    RosettaMempoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaMempool(ctx context.Context, body RosettaMempoolJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaMempoolTransaction request with any body
    RosettaMempoolTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaMempoolTransaction(ctx context.Context, body RosettaMempoolTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaNetworkList request
    RosettaNetworkList(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaNetworkOptions request with any body
    RosettaNetworkOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaNetworkOptions(ctx context.Context, body RosettaNetworkOptionsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// RosettaNetworkStatus request with any body
    RosettaNetworkStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    RosettaNetworkStatus(ctx context.Context, body RosettaNetworkStatusJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNamesOwnedByAddress request
    GetNamesOwnedByAddress(ctx context.Context, blockchain string, address string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAllNames request
    GetAllNames(ctx context.Context, params *GetAllNamesParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNameInfo request
    GetNameInfo(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error)

// FetchSubdomainsListForName request
    FetchSubdomainsListForName(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error)

// FetchZoneFile request
    FetchZoneFile(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetHistoricalZoneFile request
    GetHistoricalZoneFile(ctx context.Context, name string, zoneFileHash string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAllNamespaces request
    GetAllNamespaces(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNamespaceNames request
    GetNamespaceNames(ctx context.Context, tld string, params *GetNamespaceNamesParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetAccountInfo request
    GetAccountInfo(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors... RequestEditorFn) (*http.Response, error)

// CallReadOnlyFunction request with any body
    CallReadOnlyFunctionWithBody(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    CallReadOnlyFunction(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractInterface request
    GetContractInterface(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractSource request
    GetContractSource(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors... RequestEditorFn) (*http.Response, error)

// PostFeeTransaction request with any body
    PostFeeTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    PostFeeTransaction(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetFeeTransfer request
    GetFeeTransfer(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetCoreApiInfo request
    GetCoreApiInfo(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetContractDataMapEntry request with any body
    GetContractDataMapEntryWithBody(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    GetContractDataMapEntry(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetPoxInfo request
    GetPoxInfo(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNamePrice request
    GetNamePrice(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error)

// GetNamespacePrice request
    GetNamespacePrice(ctx context.Context, tld string, reqEditors... RequestEditorFn) (*http.Response, error)

// PostCoreNodeTransactions request with any body
    PostCoreNodeTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)


}



func (c *Client) GetAddressMempoolTransactions(ctx context.Context, address string, params *GetAddressMempoolTransactionsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAddressMempoolTransactionsRequest(c.Server, address, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountAssets(ctx context.Context, principal string, params *GetAccountAssetsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountAssetsRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountBalance(ctx context.Context, principal string, params *GetAccountBalanceParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountBalanceRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountNft(ctx context.Context, principal string, params *GetAccountNftParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountNftRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountNonces(ctx context.Context, principal string, params *GetAccountNoncesParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountNoncesRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountStxBalance(ctx context.Context, principal string, params *GetAccountStxBalanceParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountStxBalanceRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountInbound(ctx context.Context, principal string, params *GetAccountInboundParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountInboundRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountTransactions(ctx context.Context, principal string, params *GetAccountTransactionsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountTransactionsRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountTransactionsWithTransfers(ctx context.Context, principal string, params *GetAccountTransactionsWithTransfersParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountTransactionsWithTransfersRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetSingleTransactionWithTransfers(ctx context.Context, principal string, txId string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetSingleTransactionWithTransfersRequest(c.Server, principal, txId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBlockList(ctx context.Context, params *GetBlockListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBlockListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBlockByBurnBlockHash(ctx context.Context, burnBlockHash string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBlockByBurnBlockHashRequest(c.Server, burnBlockHash)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBlockByBurnBlockHeight(ctx context.Context, burnBlockHeight float32, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBlockByBurnBlockHeightRequest(c.Server, burnBlockHeight)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBlockByHeight(ctx context.Context, height float32, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBlockByHeightRequest(c.Server, height)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBlockByHash(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBlockByHashRequest(c.Server, hash)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBurnchainRewardSlotHolders(ctx context.Context, params *GetBurnchainRewardSlotHoldersParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBurnchainRewardSlotHoldersRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBurnchainRewardSlotHoldersByAddress(ctx context.Context, address string, params *GetBurnchainRewardSlotHoldersByAddressParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBurnchainRewardSlotHoldersByAddressRequest(c.Server, address, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBurnchainRewardList(ctx context.Context, params *GetBurnchainRewardListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBurnchainRewardListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBurnchainRewardListByAddress(ctx context.Context, address string, params *GetBurnchainRewardListByAddressParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBurnchainRewardListByAddressRequest(c.Server, address, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetBurnchainRewardsTotalByAddress(ctx context.Context, address string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetBurnchainRewardsTotalByAddressRequest(c.Server, address)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractsByTrait(ctx context.Context, params *GetContractsByTraitParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractsByTraitRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractById(ctx context.Context, contractId string, params *GetContractByIdParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractByIdRequest(c.Server, contractId, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractEventsById(ctx context.Context, contractId string, params *GetContractEventsByIdParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractEventsByIdRequest(c.Server, contractId, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RunFaucetBtcWithBody(ctx context.Context, params *RunFaucetBtcParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRunFaucetBtcRequestWithBody(c.Server, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RunFaucetBtc(ctx context.Context, params *RunFaucetBtcParams, body RunFaucetBtcJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRunFaucetBtcRequest(c.Server, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RunFaucetStxWithBody(ctx context.Context, params *RunFaucetStxParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRunFaucetStxRequestWithBody(c.Server, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RunFaucetStx(ctx context.Context, params *RunFaucetStxParams, body RunFaucetStxJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRunFaucetStxRequest(c.Server, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) FetchFeeRateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewFetchFeeRateRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) FetchFeeRate(ctx context.Context, body FetchFeeRateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewFetchFeeRateRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetNetworkBlockTimeByNetwork(ctx context.Context, network GetNetworkBlockTimeByNetworkParamsNetwork, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNetworkBlockTimeByNetworkRequest(c.Server, network)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNetworkBlockTimes(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNetworkBlockTimesRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetMicroblockList(ctx context.Context, params *GetMicroblockListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetMicroblockListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetUnanchoredTxs(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetUnanchoredTxsRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetMicroblockByHash(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetMicroblockByHashRequest(c.Server, hash)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) SearchById(ctx context.Context, id string, params *SearchByIdParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewSearchByIdRequest(c.Server, id, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetStatus(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetStatusRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetStxSupply(ctx context.Context, params *GetStxSupplyParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetStxSupplyRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetStxSupplyCirculatingPlain(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetStxSupplyCirculatingPlainRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTotalStxSupplyLegacyFormat(ctx context.Context, params *GetTotalStxSupplyLegacyFormatParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTotalStxSupplyLegacyFormatRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetStxSupplyTotalSupplyPlain(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetStxSupplyTotalSupplyPlainRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetFtMetadataList(ctx context.Context, params *GetFtMetadataListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetFtMetadataListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNftHistory(ctx context.Context, params *GetNftHistoryParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNftHistoryRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNftHoldings(ctx context.Context, params *GetNftHoldingsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNftHoldingsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNftMetadataList(ctx context.Context, params *GetNftMetadataListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNftMetadataListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNftMints(ctx context.Context, params *GetNftMintsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNftMintsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractFtMetadata(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractFtMetadataRequest(c.Server, contractId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractNftMetadata(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractNftMetadataRequest(c.Server, contractId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTransactionList(ctx context.Context, params *GetTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTransactionListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTransactionsByBlockHash(ctx context.Context, blockHash string, params *GetTransactionsByBlockHashParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTransactionsByBlockHashRequest(c.Server, blockHash, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTransactionsByBlockHeight(ctx context.Context, height int, params *GetTransactionsByBlockHeightParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTransactionsByBlockHeightRequest(c.Server, height, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetFilteredEvents(ctx context.Context, params *GetFilteredEventsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetFilteredEventsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetMempoolTransactionList(ctx context.Context, params *GetMempoolTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetMempoolTransactionListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetDroppedMempoolTransactionList(ctx context.Context, params *GetDroppedMempoolTransactionListParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetDroppedMempoolTransactionListRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTxListDetails(ctx context.Context, params *GetTxListDetailsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTxListDetailsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTransactionById(ctx context.Context, txId string, params *GetTransactionByIdParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTransactionByIdRequest(c.Server, txId, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetRawTransactionById(ctx context.Context, txId string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetRawTransactionByIdRequest(c.Server, txId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaAccountBalanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaAccountBalanceRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaAccountBalance(ctx context.Context, body RosettaAccountBalanceJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaAccountBalanceRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaBlockWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaBlockRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaBlock(ctx context.Context, body RosettaBlockJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaBlockRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaBlockTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaBlockTransactionRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaBlockTransaction(ctx context.Context, body RosettaBlockTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaBlockTransactionRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionCombineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionCombineRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionCombine(ctx context.Context, body RosettaConstructionCombineJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionCombineRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionDeriveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionDeriveRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionDerive(ctx context.Context, body RosettaConstructionDeriveJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionDeriveRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionHashWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionHashRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionHash(ctx context.Context, body RosettaConstructionHashJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionHashRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionMetadataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionMetadataRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionMetadata(ctx context.Context, body RosettaConstructionMetadataJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionMetadataRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionParseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionParseRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionParse(ctx context.Context, body RosettaConstructionParseJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionParseRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionPayloadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionPayloadsRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionPayloads(ctx context.Context, body RosettaConstructionPayloadsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionPayloadsRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionPreprocessWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionPreprocessRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionPreprocess(ctx context.Context, body RosettaConstructionPreprocessJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionPreprocessRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaConstructionSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionSubmitRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaConstructionSubmit(ctx context.Context, body RosettaConstructionSubmitJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaConstructionSubmitRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaMempoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaMempoolRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaMempool(ctx context.Context, body RosettaMempoolJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaMempoolRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaMempoolTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaMempoolTransactionRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaMempoolTransaction(ctx context.Context, body RosettaMempoolTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaMempoolTransactionRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaNetworkList(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaNetworkListRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaNetworkOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaNetworkOptionsRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaNetworkOptions(ctx context.Context, body RosettaNetworkOptionsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaNetworkOptionsRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) RosettaNetworkStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaNetworkStatusRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) RosettaNetworkStatus(ctx context.Context, body RosettaNetworkStatusJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewRosettaNetworkStatusRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetNamesOwnedByAddress(ctx context.Context, blockchain string, address string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNamesOwnedByAddressRequest(c.Server, blockchain, address)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAllNames(ctx context.Context, params *GetAllNamesParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAllNamesRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNameInfo(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNameInfoRequest(c.Server, name)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) FetchSubdomainsListForName(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewFetchSubdomainsListForNameRequest(c.Server, name)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) FetchZoneFile(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewFetchZoneFileRequest(c.Server, name)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetHistoricalZoneFile(ctx context.Context, name string, zoneFileHash string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetHistoricalZoneFileRequest(c.Server, name, zoneFileHash)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAllNamespaces(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAllNamespacesRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNamespaceNames(ctx context.Context, tld string, params *GetNamespaceNamesParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNamespaceNamesRequest(c.Server, tld, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetAccountInfo(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetAccountInfoRequest(c.Server, principal, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) CallReadOnlyFunctionWithBody(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewCallReadOnlyFunctionRequestWithBody(c.Server, contractAddress, contractName, functionName, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) CallReadOnlyFunction(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewCallReadOnlyFunctionRequest(c.Server, contractAddress, contractName, functionName, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetContractInterface(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractInterfaceRequest(c.Server, contractAddress, contractName, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractSource(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractSourceRequest(c.Server, contractAddress, contractName, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostFeeTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostFeeTransactionRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostFeeTransaction(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostFeeTransactionRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetFeeTransfer(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetFeeTransferRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetCoreApiInfo(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetCoreApiInfoRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractDataMapEntryWithBody(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractDataMapEntryRequestWithBody(c.Server, contractAddress, contractName, mapName, params, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetContractDataMapEntry(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetContractDataMapEntryRequest(c.Server, contractAddress, contractName, mapName, params, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetPoxInfo(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetPoxInfoRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNamePrice(ctx context.Context, name string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNamePriceRequest(c.Server, name)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetNamespacePrice(ctx context.Context, tld string, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetNamespacePriceRequest(c.Server, tld)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostCoreNodeTransactionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostCoreNodeTransactionsRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}








// NewGetAddressMempoolTransactionsRequest generates requests for GetAddressMempoolTransactions
func NewGetAddressMempoolTransactionsRequest(server string, address string, params *GetAddressMempoolTransactionsParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/mempool", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountAssetsRequest generates requests for GetAccountAssets
func NewGetAccountAssetsRequest(server string, principal string, params *GetAccountAssetsParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/assets", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountBalanceRequest generates requests for GetAccountBalance
func NewGetAccountBalanceRequest(server string, principal string, params *GetAccountBalanceParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/balances", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountNftRequest generates requests for GetAccountNft
func NewGetAccountNftRequest(server string, principal string, params *GetAccountNftParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/nft_events", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountNoncesRequest generates requests for GetAccountNonces
func NewGetAccountNoncesRequest(server string, principal string, params *GetAccountNoncesParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/nonces", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.BlockHeight != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "block_height", runtime.ParamLocationQuery, *params.BlockHeight); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.BlockHash != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "block_hash", runtime.ParamLocationQuery, *params.BlockHash); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountStxBalanceRequest generates requests for GetAccountStxBalance
func NewGetAccountStxBalanceRequest(server string, principal string, params *GetAccountStxBalanceParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/stx", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountInboundRequest generates requests for GetAccountInbound
func NewGetAccountInboundRequest(server string, principal string, params *GetAccountInboundParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/stx_inbound", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Height != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountTransactionsRequest generates requests for GetAccountTransactions
func NewGetAccountTransactionsRequest(server string, principal string, params *GetAccountTransactionsParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/transactions", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Height != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountTransactionsWithTransfersRequest generates requests for GetAccountTransactionsWithTransfers
func NewGetAccountTransactionsWithTransfersRequest(server string, principal string, params *GetAccountTransactionsWithTransfersParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/transactions_with_transfers", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Height != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.UntilBlock != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until_block", runtime.ParamLocationQuery, *params.UntilBlock); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetSingleTransactionWithTransfersRequest generates requests for GetSingleTransactionWithTransfers
func NewGetSingleTransactionWithTransfersRequest(server string, principal string, txId string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tx_id", runtime.ParamLocationPath, txId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/address/%s/%s/with_transfers", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBlockListRequest generates requests for GetBlockList
func NewGetBlockListRequest(server string, params *GetBlockListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/block")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBlockByBurnBlockHashRequest generates requests for GetBlockByBurnBlockHash
func NewGetBlockByBurnBlockHashRequest(server string, burnBlockHash string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "burn_block_hash", runtime.ParamLocationPath, burnBlockHash)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/block/by_burn_block_hash/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBlockByBurnBlockHeightRequest generates requests for GetBlockByBurnBlockHeight
func NewGetBlockByBurnBlockHeightRequest(server string, burnBlockHeight float32) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "burn_block_height", runtime.ParamLocationPath, burnBlockHeight)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/block/by_burn_block_height/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBlockByHeightRequest generates requests for GetBlockByHeight
func NewGetBlockByHeightRequest(server string, height float32) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "height", runtime.ParamLocationPath, height)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/block/by_height/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBlockByHashRequest generates requests for GetBlockByHash
func NewGetBlockByHashRequest(server string, hash string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/block/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBurnchainRewardSlotHoldersRequest generates requests for GetBurnchainRewardSlotHolders
func NewGetBurnchainRewardSlotHoldersRequest(server string, params *GetBurnchainRewardSlotHoldersParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/burnchain/reward_slot_holders")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBurnchainRewardSlotHoldersByAddressRequest generates requests for GetBurnchainRewardSlotHoldersByAddress
func NewGetBurnchainRewardSlotHoldersByAddressRequest(server string, address string, params *GetBurnchainRewardSlotHoldersByAddressParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/burnchain/reward_slot_holders/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBurnchainRewardListRequest generates requests for GetBurnchainRewardList
func NewGetBurnchainRewardListRequest(server string, params *GetBurnchainRewardListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/burnchain/rewards")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBurnchainRewardListByAddressRequest generates requests for GetBurnchainRewardListByAddress
func NewGetBurnchainRewardListByAddressRequest(server string, address string, params *GetBurnchainRewardListByAddressParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/burnchain/rewards/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetBurnchainRewardsTotalByAddressRequest generates requests for GetBurnchainRewardsTotalByAddress
func NewGetBurnchainRewardsTotalByAddressRequest(server string, address string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/burnchain/rewards/%s/total", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractsByTraitRequest generates requests for GetContractsByTrait
func NewGetContractsByTraitRequest(server string, params *GetContractsByTraitParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/contract/by_trait")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "trait_abi", runtime.ParamLocationQuery, params.TraitAbi); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractByIdRequest generates requests for GetContractById
func NewGetContractByIdRequest(server string, contractId string, params *GetContractByIdParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/contract/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractEventsByIdRequest generates requests for GetContractEventsById
func NewGetContractEventsByIdRequest(server string, contractId string, params *GetContractEventsByIdParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_id", runtime.ParamLocationPath, contractId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/contract/%s/events", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewRunFaucetBtcRequest calls the generic RunFaucetBtc builder with application/json body
func NewRunFaucetBtcRequest(server string, params *RunFaucetBtcParams, body RunFaucetBtcJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRunFaucetBtcRequestWithBody(server, params, "application/json", bodyReader)
}


// NewRunFaucetBtcRequestWithBody generates requests for RunFaucetBtc with any type of body
func NewRunFaucetBtcRequestWithBody(server string, params *RunFaucetBtcParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/faucets/btc")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, params.Address); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRunFaucetStxRequest calls the generic RunFaucetStx builder with application/json body
func NewRunFaucetStxRequest(server string, params *RunFaucetStxParams, body RunFaucetStxJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRunFaucetStxRequestWithBody(server, params, "application/json", bodyReader)
}


// NewRunFaucetStxRequestWithBody generates requests for RunFaucetStx with any type of body
func NewRunFaucetStxRequestWithBody(server string, params *RunFaucetStxParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/faucets/stx")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, params.Address); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.Stacking != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stacking", runtime.ParamLocationQuery, *params.Stacking); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewFetchFeeRateRequest calls the generic FetchFeeRate builder with application/json body
func NewFetchFeeRateRequest(server string, body FetchFeeRateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewFetchFeeRateRequestWithBody(server, "application/json", bodyReader)
}


// NewFetchFeeRateRequestWithBody generates requests for FetchFeeRate with any type of body
func NewFetchFeeRateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/fee_rate")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetNetworkBlockTimeByNetworkRequest generates requests for GetNetworkBlockTimeByNetwork
func NewGetNetworkBlockTimeByNetworkRequest(server string, network GetNetworkBlockTimeByNetworkParamsNetwork) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/info/network_block_time/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNetworkBlockTimesRequest generates requests for GetNetworkBlockTimes
func NewGetNetworkBlockTimesRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/info/network_block_times")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetMicroblockListRequest generates requests for GetMicroblockList
func NewGetMicroblockListRequest(server string, params *GetMicroblockListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/microblock")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetUnanchoredTxsRequest generates requests for GetUnanchoredTxs
func NewGetUnanchoredTxsRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/microblock/unanchored/txs")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetMicroblockByHashRequest generates requests for GetMicroblockByHash
func NewGetMicroblockByHashRequest(server string, hash string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/microblock/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewSearchByIdRequest generates requests for SearchById
func NewSearchByIdRequest(server string, id string, params *SearchByIdParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/search/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.IncludeMetadata != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_metadata", runtime.ParamLocationQuery, *params.IncludeMetadata); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/status")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetStxSupplyRequest generates requests for GetStxSupply
func NewGetStxSupplyRequest(server string, params *GetStxSupplyParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/stx_supply")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Height != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetStxSupplyCirculatingPlainRequest generates requests for GetStxSupplyCirculatingPlain
func NewGetStxSupplyCirculatingPlainRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/stx_supply/circulating/plain")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTotalStxSupplyLegacyFormatRequest generates requests for GetTotalStxSupplyLegacyFormat
func NewGetTotalStxSupplyLegacyFormatRequest(server string, params *GetTotalStxSupplyLegacyFormatParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/stx_supply/legacy_format")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Height != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetStxSupplyTotalSupplyPlainRequest generates requests for GetStxSupplyTotalSupplyPlain
func NewGetStxSupplyTotalSupplyPlainRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/stx_supply/total/plain")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetFtMetadataListRequest generates requests for GetFtMetadataList
func NewGetFtMetadataListRequest(server string, params *GetFtMetadataListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/ft/metadata")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNftHistoryRequest generates requests for GetNftHistory
func NewGetNftHistoryRequest(server string, params *GetNftHistoryParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/nft/history")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_identifier", runtime.ParamLocationQuery, params.AssetIdentifier); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.TxMetadata != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tx_metadata", runtime.ParamLocationQuery, *params.TxMetadata); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNftHoldingsRequest generates requests for GetNftHoldings
func NewGetNftHoldingsRequest(server string, params *GetNftHoldingsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/nft/holdings")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principal", runtime.ParamLocationQuery, params.Principal); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.AssetIdentifiers != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_identifiers", runtime.ParamLocationQuery, *params.AssetIdentifiers); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.TxMetadata != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tx_metadata", runtime.ParamLocationQuery, *params.TxMetadata); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNftMetadataListRequest generates requests for GetNftMetadataList
func NewGetNftMetadataListRequest(server string, params *GetNftMetadataListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/nft/metadata")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNftMintsRequest generates requests for GetNftMints
func NewGetNftMintsRequest(server string, params *GetNftMintsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/nft/mints")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_identifier", runtime.ParamLocationQuery, params.AssetIdentifier); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.TxMetadata != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tx_metadata", runtime.ParamLocationQuery, *params.TxMetadata); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractFtMetadataRequest generates requests for GetContractFtMetadata
func NewGetContractFtMetadataRequest(server string, contractId string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contractId", runtime.ParamLocationPath, contractId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/%s/ft/metadata", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractNftMetadataRequest generates requests for GetContractNftMetadata
func NewGetContractNftMetadataRequest(server string, contractId string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contractId", runtime.ParamLocationPath, contractId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tokens/%s/nft/metadata", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTransactionListRequest generates requests for GetTransactionList
func NewGetTransactionListRequest(server string, params *GetTransactionListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Type != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTransactionsByBlockHashRequest generates requests for GetTransactionsByBlockHash
func NewGetTransactionsByBlockHashRequest(server string, blockHash string, params *GetTransactionsByBlockHashParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_hash", runtime.ParamLocationPath, blockHash)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/block/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTransactionsByBlockHeightRequest generates requests for GetTransactionsByBlockHeight
func NewGetTransactionsByBlockHeightRequest(server string, height int, params *GetTransactionsByBlockHeightParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "height", runtime.ParamLocationPath, height)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/block_height/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetFilteredEventsRequest generates requests for GetFilteredEvents
func NewGetFilteredEventsRequest(server string, params *GetFilteredEventsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/events")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.TxId != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tx_id", runtime.ParamLocationQuery, *params.TxId); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Address != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Type != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetMempoolTransactionListRequest generates requests for GetMempoolTransactionList
func NewGetMempoolTransactionListRequest(server string, params *GetMempoolTransactionListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/mempool")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.SenderAddress != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sender_address", runtime.ParamLocationQuery, *params.SenderAddress); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.RecipientAddress != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recipient_address", runtime.ParamLocationQuery, *params.RecipientAddress); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Address != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetDroppedMempoolTransactionListRequest generates requests for GetDroppedMempoolTransactionList
func NewGetDroppedMempoolTransactionListRequest(server string, params *GetDroppedMempoolTransactionListParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/mempool/dropped")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTxListDetailsRequest generates requests for GetTxListDetails
func NewGetTxListDetailsRequest(server string, params *GetTxListDetailsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/multiple")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tx_id", runtime.ParamLocationQuery, params.TxId); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

     if params.EventOffset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_offset", runtime.ParamLocationQuery, *params.EventOffset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.EventLimit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_limit", runtime.ParamLocationQuery, *params.EventLimit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTransactionByIdRequest generates requests for GetTransactionById
func NewGetTransactionByIdRequest(server string, txId string, params *GetTransactionByIdParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tx_id", runtime.ParamLocationPath, txId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.EventOffset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_offset", runtime.ParamLocationQuery, *params.EventOffset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.EventLimit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_limit", runtime.ParamLocationQuery, *params.EventLimit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Unanchored != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unanchored", runtime.ParamLocationQuery, *params.Unanchored); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetRawTransactionByIdRequest generates requests for GetRawTransactionById
func NewGetRawTransactionByIdRequest(server string, txId string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tx_id", runtime.ParamLocationPath, txId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/extended/v1/tx/%s/raw", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewRosettaAccountBalanceRequest calls the generic RosettaAccountBalance builder with application/json body
func NewRosettaAccountBalanceRequest(server string, body RosettaAccountBalanceJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaAccountBalanceRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaAccountBalanceRequestWithBody generates requests for RosettaAccountBalance with any type of body
func NewRosettaAccountBalanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/account/balance")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaBlockRequest calls the generic RosettaBlock builder with application/json body
func NewRosettaBlockRequest(server string, body RosettaBlockJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaBlockRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaBlockRequestWithBody generates requests for RosettaBlock with any type of body
func NewRosettaBlockRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/block")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaBlockTransactionRequest calls the generic RosettaBlockTransaction builder with application/json body
func NewRosettaBlockTransactionRequest(server string, body RosettaBlockTransactionJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaBlockTransactionRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaBlockTransactionRequestWithBody generates requests for RosettaBlockTransaction with any type of body
func NewRosettaBlockTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/block/transaction")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionCombineRequest calls the generic RosettaConstructionCombine builder with application/json body
func NewRosettaConstructionCombineRequest(server string, body RosettaConstructionCombineJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionCombineRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionCombineRequestWithBody generates requests for RosettaConstructionCombine with any type of body
func NewRosettaConstructionCombineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/combine")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionDeriveRequest calls the generic RosettaConstructionDerive builder with application/json body
func NewRosettaConstructionDeriveRequest(server string, body RosettaConstructionDeriveJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionDeriveRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionDeriveRequestWithBody generates requests for RosettaConstructionDerive with any type of body
func NewRosettaConstructionDeriveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/derive")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionHashRequest calls the generic RosettaConstructionHash builder with application/json body
func NewRosettaConstructionHashRequest(server string, body RosettaConstructionHashJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionHashRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionHashRequestWithBody generates requests for RosettaConstructionHash with any type of body
func NewRosettaConstructionHashRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/hash")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionMetadataRequest calls the generic RosettaConstructionMetadata builder with application/json body
func NewRosettaConstructionMetadataRequest(server string, body RosettaConstructionMetadataJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionMetadataRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionMetadataRequestWithBody generates requests for RosettaConstructionMetadata with any type of body
func NewRosettaConstructionMetadataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/metadata")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionParseRequest calls the generic RosettaConstructionParse builder with application/json body
func NewRosettaConstructionParseRequest(server string, body RosettaConstructionParseJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionParseRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionParseRequestWithBody generates requests for RosettaConstructionParse with any type of body
func NewRosettaConstructionParseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/parse")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionPayloadsRequest calls the generic RosettaConstructionPayloads builder with application/json body
func NewRosettaConstructionPayloadsRequest(server string, body RosettaConstructionPayloadsJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionPayloadsRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionPayloadsRequestWithBody generates requests for RosettaConstructionPayloads with any type of body
func NewRosettaConstructionPayloadsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/payloads")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionPreprocessRequest calls the generic RosettaConstructionPreprocess builder with application/json body
func NewRosettaConstructionPreprocessRequest(server string, body RosettaConstructionPreprocessJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionPreprocessRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionPreprocessRequestWithBody generates requests for RosettaConstructionPreprocess with any type of body
func NewRosettaConstructionPreprocessRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/preprocess")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaConstructionSubmitRequest calls the generic RosettaConstructionSubmit builder with application/json body
func NewRosettaConstructionSubmitRequest(server string, body RosettaConstructionSubmitJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaConstructionSubmitRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaConstructionSubmitRequestWithBody generates requests for RosettaConstructionSubmit with any type of body
func NewRosettaConstructionSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/construction/submit")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaMempoolRequest calls the generic RosettaMempool builder with application/json body
func NewRosettaMempoolRequest(server string, body RosettaMempoolJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaMempoolRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaMempoolRequestWithBody generates requests for RosettaMempool with any type of body
func NewRosettaMempoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/mempool")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaMempoolTransactionRequest calls the generic RosettaMempoolTransaction builder with application/json body
func NewRosettaMempoolTransactionRequest(server string, body RosettaMempoolTransactionJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaMempoolTransactionRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaMempoolTransactionRequestWithBody generates requests for RosettaMempoolTransaction with any type of body
func NewRosettaMempoolTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/mempool/transaction")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewRosettaNetworkListRequest generates requests for RosettaNetworkList
func NewRosettaNetworkListRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/network/list")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewRosettaNetworkOptionsRequest calls the generic RosettaNetworkOptions builder with application/json body
func NewRosettaNetworkOptionsRequest(server string, body RosettaNetworkOptionsJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaNetworkOptionsRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaNetworkOptionsRequestWithBody generates requests for RosettaNetworkOptions with any type of body
func NewRosettaNetworkOptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/network/options")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewRosettaNetworkStatusRequest calls the generic RosettaNetworkStatus builder with application/json body
func NewRosettaNetworkStatusRequest(server string, body RosettaNetworkStatusJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewRosettaNetworkStatusRequestWithBody(server, "application/json", bodyReader)
}


// NewRosettaNetworkStatusRequestWithBody generates requests for RosettaNetworkStatus with any type of body
func NewRosettaNetworkStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/rosetta/v1/network/status")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetNamesOwnedByAddressRequest generates requests for GetNamesOwnedByAddress
func NewGetNamesOwnedByAddressRequest(server string, blockchain string, address string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blockchain", runtime.ParamLocationPath, blockchain)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/addresses/%s/%s", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAllNamesRequest generates requests for GetAllNames
func NewGetAllNamesRequest(server string, params *GetAllNamesParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/names")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNameInfoRequest generates requests for GetNameInfo
func NewGetNameInfoRequest(server string, name string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/names/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewFetchSubdomainsListForNameRequest generates requests for FetchSubdomainsListForName
func NewFetchSubdomainsListForNameRequest(server string, name string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/names/%s/subdomains", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewFetchZoneFileRequest generates requests for FetchZoneFile
func NewFetchZoneFileRequest(server string, name string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/names/%s/zonefile", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetHistoricalZoneFileRequest generates requests for GetHistoricalZoneFile
func NewGetHistoricalZoneFileRequest(server string, name string, zoneFileHash string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zoneFileHash", runtime.ParamLocationPath, zoneFileHash)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/names/%s/zonefile/%s", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAllNamespacesRequest generates requests for GetAllNamespaces
func NewGetAllNamespacesRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/namespaces")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNamespaceNamesRequest generates requests for GetNamespaceNames
func NewGetNamespaceNamesRequest(server string, tld string, params *GetNamespaceNamesParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tld", runtime.ParamLocationPath, tld)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v1/namespaces/%s/names", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetAccountInfoRequest generates requests for GetAccountInfo
func NewGetAccountInfoRequest(server string, principal string, params *GetAccountInfoParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "principal", runtime.ParamLocationPath, principal)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/accounts/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Proof != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Tip != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewCallReadOnlyFunctionRequest calls the generic CallReadOnlyFunction builder with application/json body
func NewCallReadOnlyFunctionRequest(server string, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewCallReadOnlyFunctionRequestWithBody(server, contractAddress, contractName, functionName, params, "application/json", bodyReader)
}


// NewCallReadOnlyFunctionRequestWithBody generates requests for CallReadOnlyFunction with any type of body
func NewCallReadOnlyFunctionRequestWithBody(server string, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "function_name", runtime.ParamLocationPath, functionName)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/contracts/call-read/%s/%s/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Tip != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetContractInterfaceRequest generates requests for GetContractInterface
func NewGetContractInterfaceRequest(server string, contractAddress string, contractName string, params *GetContractInterfaceParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/contracts/interface/%s/%s", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Tip != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetContractSourceRequest generates requests for GetContractSource
func NewGetContractSourceRequest(server string, contractAddress string, contractName string, params *GetContractSourceParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/contracts/source/%s/%s", pathParam0, pathParam1)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Proof != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Tip != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewPostFeeTransactionRequest calls the generic PostFeeTransaction builder with application/json body
func NewPostFeeTransactionRequest(server string, body PostFeeTransactionJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPostFeeTransactionRequestWithBody(server, "application/json", bodyReader)
}


// NewPostFeeTransactionRequestWithBody generates requests for PostFeeTransaction with any type of body
func NewPostFeeTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/fees/transaction")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetFeeTransferRequest generates requests for GetFeeTransfer
func NewGetFeeTransferRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/fees/transfer")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetCoreApiInfoRequest generates requests for GetCoreApiInfo
func NewGetCoreApiInfoRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/info")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewGetContractDataMapEntryRequest calls the generic GetContractDataMapEntry builder with application/json body
func NewGetContractDataMapEntryRequest(server string, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewGetContractDataMapEntryRequestWithBody(server, contractAddress, contractName, mapName, params, "application/json", bodyReader)
}


// NewGetContractDataMapEntryRequestWithBody generates requests for GetContractDataMapEntry with any type of body
func NewGetContractDataMapEntryRequestWithBody(server string, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
    if err != nil {
        return nil, err
    }
    

    var pathParam1 string
    
    
    
    pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_name", runtime.ParamLocationPath, contractName)
    if err != nil {
        return nil, err
    }
    

    var pathParam2 string
    
    
    
    pathParam2, err = runtime.StyleParamWithLocation("simple", false, "map_name", runtime.ParamLocationPath, mapName)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/map_entry/%s/%s/%s", pathParam0, pathParam1, pathParam2)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Proof != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "proof", runtime.ParamLocationQuery, *params.Proof); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Tip != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tip", runtime.ParamLocationQuery, *params.Tip); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetPoxInfoRequest generates requests for GetPoxInfo
func NewGetPoxInfoRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/pox")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNamePriceRequest generates requests for GetNamePrice
func NewGetNamePriceRequest(server string, name string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/prices/names/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetNamespacePriceRequest generates requests for GetNamespacePrice
func NewGetNamespacePriceRequest(server string, tld string) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tld", runtime.ParamLocationPath, tld)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/prices/namespaces/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewPostCoreNodeTransactionsRequestWithBody generates requests for PostCoreNodeTransactions with any type of body
func NewPostCoreNodeTransactionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/v2/transactions")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
    for _, r := range c.RequestEditors {
        if err := r(ctx, req); err != nil {
            return err
        }
    }
    for _, r := range additionalEditors {
        if err := r(ctx, req); err != nil {
            return err
        }
    }
    return nil
}
// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
    ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
    client, err := NewClient(server, opts...)
    if err != nil {
        return nil, err
    }
    return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
// GetAddressMempoolTransactions request
    GetAddressMempoolTransactionsWithResponse(ctx context.Context, address string, params *GetAddressMempoolTransactionsParams, reqEditors... RequestEditorFn) (*GetAddressMempoolTransactionsResponse, error)

// GetAccountAssets request
    GetAccountAssetsWithResponse(ctx context.Context, principal string, params *GetAccountAssetsParams, reqEditors... RequestEditorFn) (*GetAccountAssetsResponse, error)

// GetAccountBalance request
    GetAccountBalanceWithResponse(ctx context.Context, principal string, params *GetAccountBalanceParams, reqEditors... RequestEditorFn) (*GetAccountBalanceResponse, error)

// GetAccountNft request
    GetAccountNftWithResponse(ctx context.Context, principal string, params *GetAccountNftParams, reqEditors... RequestEditorFn) (*GetAccountNftResponse, error)

// GetAccountNonces request
    GetAccountNoncesWithResponse(ctx context.Context, principal string, params *GetAccountNoncesParams, reqEditors... RequestEditorFn) (*GetAccountNoncesResponse, error)

// GetAccountStxBalance request
    GetAccountStxBalanceWithResponse(ctx context.Context, principal string, params *GetAccountStxBalanceParams, reqEditors... RequestEditorFn) (*GetAccountStxBalanceResponse, error)

// GetAccountInbound request
    GetAccountInboundWithResponse(ctx context.Context, principal string, params *GetAccountInboundParams, reqEditors... RequestEditorFn) (*GetAccountInboundResponse, error)

// GetAccountTransactions request
    GetAccountTransactionsWithResponse(ctx context.Context, principal string, params *GetAccountTransactionsParams, reqEditors... RequestEditorFn) (*GetAccountTransactionsResponse, error)

// GetAccountTransactionsWithTransfers request
    GetAccountTransactionsWithTransfersWithResponse(ctx context.Context, principal string, params *GetAccountTransactionsWithTransfersParams, reqEditors... RequestEditorFn) (*GetAccountTransactionsWithTransfersResponse, error)

// GetSingleTransactionWithTransfers request
    GetSingleTransactionWithTransfersWithResponse(ctx context.Context, principal string, txId string, reqEditors... RequestEditorFn) (*GetSingleTransactionWithTransfersResponse, error)

// GetBlockList request
    GetBlockListWithResponse(ctx context.Context, params *GetBlockListParams, reqEditors... RequestEditorFn) (*GetBlockListResponse, error)

// GetBlockByBurnBlockHash request
    GetBlockByBurnBlockHashWithResponse(ctx context.Context, burnBlockHash string, reqEditors... RequestEditorFn) (*GetBlockByBurnBlockHashResponse, error)

// GetBlockByBurnBlockHeight request
    GetBlockByBurnBlockHeightWithResponse(ctx context.Context, burnBlockHeight float32, reqEditors... RequestEditorFn) (*GetBlockByBurnBlockHeightResponse, error)

// GetBlockByHeight request
    GetBlockByHeightWithResponse(ctx context.Context, height float32, reqEditors... RequestEditorFn) (*GetBlockByHeightResponse, error)

// GetBlockByHash request
    GetBlockByHashWithResponse(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*GetBlockByHashResponse, error)

// GetBurnchainRewardSlotHolders request
    GetBurnchainRewardSlotHoldersWithResponse(ctx context.Context, params *GetBurnchainRewardSlotHoldersParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardSlotHoldersResponse, error)

// GetBurnchainRewardSlotHoldersByAddress request
    GetBurnchainRewardSlotHoldersByAddressWithResponse(ctx context.Context, address string, params *GetBurnchainRewardSlotHoldersByAddressParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardSlotHoldersByAddressResponse, error)

// GetBurnchainRewardList request
    GetBurnchainRewardListWithResponse(ctx context.Context, params *GetBurnchainRewardListParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardListResponse, error)

// GetBurnchainRewardListByAddress request
    GetBurnchainRewardListByAddressWithResponse(ctx context.Context, address string, params *GetBurnchainRewardListByAddressParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardListByAddressResponse, error)

// GetBurnchainRewardsTotalByAddress request
    GetBurnchainRewardsTotalByAddressWithResponse(ctx context.Context, address string, reqEditors... RequestEditorFn) (*GetBurnchainRewardsTotalByAddressResponse, error)

// GetContractsByTrait request
    GetContractsByTraitWithResponse(ctx context.Context, params *GetContractsByTraitParams, reqEditors... RequestEditorFn) (*GetContractsByTraitResponse, error)

// GetContractById request
    GetContractByIdWithResponse(ctx context.Context, contractId string, params *GetContractByIdParams, reqEditors... RequestEditorFn) (*GetContractByIdResponse, error)

// GetContractEventsById request
    GetContractEventsByIdWithResponse(ctx context.Context, contractId string, params *GetContractEventsByIdParams, reqEditors... RequestEditorFn) (*GetContractEventsByIdResponse, error)

// RunFaucetBtc request with any body
    RunFaucetBtcWithBodyWithResponse(ctx context.Context, params *RunFaucetBtcParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RunFaucetBtcResponse, error)

    RunFaucetBtcWithResponse(ctx context.Context, params *RunFaucetBtcParams, body RunFaucetBtcJSONRequestBody, reqEditors... RequestEditorFn) (*RunFaucetBtcResponse, error)

// RunFaucetStx request with any body
    RunFaucetStxWithBodyWithResponse(ctx context.Context, params *RunFaucetStxParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RunFaucetStxResponse, error)

    RunFaucetStxWithResponse(ctx context.Context, params *RunFaucetStxParams, body RunFaucetStxJSONRequestBody, reqEditors... RequestEditorFn) (*RunFaucetStxResponse, error)

// FetchFeeRate request with any body
    FetchFeeRateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*FetchFeeRateResponse, error)

    FetchFeeRateWithResponse(ctx context.Context, body FetchFeeRateJSONRequestBody, reqEditors... RequestEditorFn) (*FetchFeeRateResponse, error)

// GetNetworkBlockTimeByNetwork request
    GetNetworkBlockTimeByNetworkWithResponse(ctx context.Context, network GetNetworkBlockTimeByNetworkParamsNetwork, reqEditors... RequestEditorFn) (*GetNetworkBlockTimeByNetworkResponse, error)

// GetNetworkBlockTimes request
    GetNetworkBlockTimesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetNetworkBlockTimesResponse, error)

// GetMicroblockList request
    GetMicroblockListWithResponse(ctx context.Context, params *GetMicroblockListParams, reqEditors... RequestEditorFn) (*GetMicroblockListResponse, error)

// GetUnanchoredTxs request
    GetUnanchoredTxsWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetUnanchoredTxsResponse, error)

// GetMicroblockByHash request
    GetMicroblockByHashWithResponse(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*GetMicroblockByHashResponse, error)

// SearchById request
    SearchByIdWithResponse(ctx context.Context, id string, params *SearchByIdParams, reqEditors... RequestEditorFn) (*SearchByIdResponse, error)

// GetStatus request
    GetStatusWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStatusResponse, error)

// GetStxSupply request
    GetStxSupplyWithResponse(ctx context.Context, params *GetStxSupplyParams, reqEditors... RequestEditorFn) (*GetStxSupplyResponse, error)

// GetStxSupplyCirculatingPlain request
    GetStxSupplyCirculatingPlainWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStxSupplyCirculatingPlainResponse, error)

// GetTotalStxSupplyLegacyFormat request
    GetTotalStxSupplyLegacyFormatWithResponse(ctx context.Context, params *GetTotalStxSupplyLegacyFormatParams, reqEditors... RequestEditorFn) (*GetTotalStxSupplyLegacyFormatResponse, error)

// GetStxSupplyTotalSupplyPlain request
    GetStxSupplyTotalSupplyPlainWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStxSupplyTotalSupplyPlainResponse, error)

// GetFtMetadataList request
    GetFtMetadataListWithResponse(ctx context.Context, params *GetFtMetadataListParams, reqEditors... RequestEditorFn) (*GetFtMetadataListResponse, error)

// GetNftHistory request
    GetNftHistoryWithResponse(ctx context.Context, params *GetNftHistoryParams, reqEditors... RequestEditorFn) (*GetNftHistoryResponse, error)

// GetNftHoldings request
    GetNftHoldingsWithResponse(ctx context.Context, params *GetNftHoldingsParams, reqEditors... RequestEditorFn) (*GetNftHoldingsResponse, error)

// GetNftMetadataList request
    GetNftMetadataListWithResponse(ctx context.Context, params *GetNftMetadataListParams, reqEditors... RequestEditorFn) (*GetNftMetadataListResponse, error)

// GetNftMints request
    GetNftMintsWithResponse(ctx context.Context, params *GetNftMintsParams, reqEditors... RequestEditorFn) (*GetNftMintsResponse, error)

// GetContractFtMetadata request
    GetContractFtMetadataWithResponse(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*GetContractFtMetadataResponse, error)

// GetContractNftMetadata request
    GetContractNftMetadataWithResponse(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*GetContractNftMetadataResponse, error)

// GetTransactionList request
    GetTransactionListWithResponse(ctx context.Context, params *GetTransactionListParams, reqEditors... RequestEditorFn) (*GetTransactionListResponse, error)

// GetTransactionsByBlockHash request
    GetTransactionsByBlockHashWithResponse(ctx context.Context, blockHash string, params *GetTransactionsByBlockHashParams, reqEditors... RequestEditorFn) (*GetTransactionsByBlockHashResponse, error)

// GetTransactionsByBlockHeight request
    GetTransactionsByBlockHeightWithResponse(ctx context.Context, height int, params *GetTransactionsByBlockHeightParams, reqEditors... RequestEditorFn) (*GetTransactionsByBlockHeightResponse, error)

// GetFilteredEvents request
    GetFilteredEventsWithResponse(ctx context.Context, params *GetFilteredEventsParams, reqEditors... RequestEditorFn) (*GetFilteredEventsResponse, error)

// GetMempoolTransactionList request
    GetMempoolTransactionListWithResponse(ctx context.Context, params *GetMempoolTransactionListParams, reqEditors... RequestEditorFn) (*GetMempoolTransactionListResponse, error)

// GetDroppedMempoolTransactionList request
    GetDroppedMempoolTransactionListWithResponse(ctx context.Context, params *GetDroppedMempoolTransactionListParams, reqEditors... RequestEditorFn) (*GetDroppedMempoolTransactionListResponse, error)

// GetTxListDetails request
    GetTxListDetailsWithResponse(ctx context.Context, params *GetTxListDetailsParams, reqEditors... RequestEditorFn) (*GetTxListDetailsResponse, error)

// GetTransactionById request
    GetTransactionByIdWithResponse(ctx context.Context, txId string, params *GetTransactionByIdParams, reqEditors... RequestEditorFn) (*GetTransactionByIdResponse, error)

// GetRawTransactionById request
    GetRawTransactionByIdWithResponse(ctx context.Context, txId string, reqEditors... RequestEditorFn) (*GetRawTransactionByIdResponse, error)

// RosettaAccountBalance request with any body
    RosettaAccountBalanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaAccountBalanceResponse, error)

    RosettaAccountBalanceWithResponse(ctx context.Context, body RosettaAccountBalanceJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaAccountBalanceResponse, error)

// RosettaBlock request with any body
    RosettaBlockWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaBlockResponse, error)

    RosettaBlockWithResponse(ctx context.Context, body RosettaBlockJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaBlockResponse, error)

// RosettaBlockTransaction request with any body
    RosettaBlockTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaBlockTransactionResponse, error)

    RosettaBlockTransactionWithResponse(ctx context.Context, body RosettaBlockTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaBlockTransactionResponse, error)

// RosettaConstructionCombine request with any body
    RosettaConstructionCombineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionCombineResponse, error)

    RosettaConstructionCombineWithResponse(ctx context.Context, body RosettaConstructionCombineJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionCombineResponse, error)

// RosettaConstructionDerive request with any body
    RosettaConstructionDeriveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionDeriveResponse, error)

    RosettaConstructionDeriveWithResponse(ctx context.Context, body RosettaConstructionDeriveJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionDeriveResponse, error)

// RosettaConstructionHash request with any body
    RosettaConstructionHashWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionHashResponse, error)

    RosettaConstructionHashWithResponse(ctx context.Context, body RosettaConstructionHashJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionHashResponse, error)

// RosettaConstructionMetadata request with any body
    RosettaConstructionMetadataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionMetadataResponse, error)

    RosettaConstructionMetadataWithResponse(ctx context.Context, body RosettaConstructionMetadataJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionMetadataResponse, error)

// RosettaConstructionParse request with any body
    RosettaConstructionParseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionParseResponse, error)

    RosettaConstructionParseWithResponse(ctx context.Context, body RosettaConstructionParseJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionParseResponse, error)

// RosettaConstructionPayloads request with any body
    RosettaConstructionPayloadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionPayloadsResponse, error)

    RosettaConstructionPayloadsWithResponse(ctx context.Context, body RosettaConstructionPayloadsJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionPayloadsResponse, error)

// RosettaConstructionPreprocess request with any body
    RosettaConstructionPreprocessWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionPreprocessResponse, error)

    RosettaConstructionPreprocessWithResponse(ctx context.Context, body RosettaConstructionPreprocessJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionPreprocessResponse, error)

// RosettaConstructionSubmit request with any body
    RosettaConstructionSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionSubmitResponse, error)

    RosettaConstructionSubmitWithResponse(ctx context.Context, body RosettaConstructionSubmitJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionSubmitResponse, error)

// RosettaMempool request with any body
    RosettaMempoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaMempoolResponse, error)

    RosettaMempoolWithResponse(ctx context.Context, body RosettaMempoolJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaMempoolResponse, error)

// RosettaMempoolTransaction request with any body
    RosettaMempoolTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaMempoolTransactionResponse, error)

    RosettaMempoolTransactionWithResponse(ctx context.Context, body RosettaMempoolTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaMempoolTransactionResponse, error)

// RosettaNetworkList request
    RosettaNetworkListWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*RosettaNetworkListResponse, error)

// RosettaNetworkOptions request with any body
    RosettaNetworkOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaNetworkOptionsResponse, error)

    RosettaNetworkOptionsWithResponse(ctx context.Context, body RosettaNetworkOptionsJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaNetworkOptionsResponse, error)

// RosettaNetworkStatus request with any body
    RosettaNetworkStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaNetworkStatusResponse, error)

    RosettaNetworkStatusWithResponse(ctx context.Context, body RosettaNetworkStatusJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaNetworkStatusResponse, error)

// GetNamesOwnedByAddress request
    GetNamesOwnedByAddressWithResponse(ctx context.Context, blockchain string, address string, reqEditors... RequestEditorFn) (*GetNamesOwnedByAddressResponse, error)

// GetAllNames request
    GetAllNamesWithResponse(ctx context.Context, params *GetAllNamesParams, reqEditors... RequestEditorFn) (*GetAllNamesResponse, error)

// GetNameInfo request
    GetNameInfoWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*GetNameInfoResponse, error)

// FetchSubdomainsListForName request
    FetchSubdomainsListForNameWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*FetchSubdomainsListForNameResponse, error)

// FetchZoneFile request
    FetchZoneFileWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*FetchZoneFileResponse, error)

// GetHistoricalZoneFile request
    GetHistoricalZoneFileWithResponse(ctx context.Context, name string, zoneFileHash string, reqEditors... RequestEditorFn) (*GetHistoricalZoneFileResponse, error)

// GetAllNamespaces request
    GetAllNamespacesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetAllNamespacesResponse, error)

// GetNamespaceNames request
    GetNamespaceNamesWithResponse(ctx context.Context, tld string, params *GetNamespaceNamesParams, reqEditors... RequestEditorFn) (*GetNamespaceNamesResponse, error)

// GetAccountInfo request
    GetAccountInfoWithResponse(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors... RequestEditorFn) (*GetAccountInfoResponse, error)

// CallReadOnlyFunction request with any body
    CallReadOnlyFunctionWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*CallReadOnlyFunctionResponse, error)

    CallReadOnlyFunctionWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors... RequestEditorFn) (*CallReadOnlyFunctionResponse, error)

// GetContractInterface request
    GetContractInterfaceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors... RequestEditorFn) (*GetContractInterfaceResponse, error)

// GetContractSource request
    GetContractSourceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors... RequestEditorFn) (*GetContractSourceResponse, error)

// PostFeeTransaction request with any body
    PostFeeTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostFeeTransactionResponse, error)

    PostFeeTransactionWithResponse(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*PostFeeTransactionResponse, error)

// GetFeeTransfer request
    GetFeeTransferWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetFeeTransferResponse, error)

// GetCoreApiInfo request
    GetCoreApiInfoWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetCoreApiInfoResponse, error)

// GetContractDataMapEntry request with any body
    GetContractDataMapEntryWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*GetContractDataMapEntryResponse, error)

    GetContractDataMapEntryWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors... RequestEditorFn) (*GetContractDataMapEntryResponse, error)

// GetPoxInfo request
    GetPoxInfoWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetPoxInfoResponse, error)

// GetNamePrice request
    GetNamePriceWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*GetNamePriceResponse, error)

// GetNamespacePrice request
    GetNamespacePriceWithResponse(ctx context.Context, tld string, reqEditors... RequestEditorFn) (*GetNamespacePriceResponse, error)

// PostCoreNodeTransactions request with any body
    PostCoreNodeTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostCoreNodeTransactionsResponse, error)


}


type GetAddressMempoolTransactionsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAddressMempoolTransactionsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddressMempoolTransactionsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountAssetsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountAssetsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountAssetsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountBalanceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    FungibleTokens 200_FungibleTokens`json:"fungible_tokens"`
    NonFungibleTokens 200_NonFungibleTokens`json:"non_fungible_tokens"`
    Stx struct {
    Balance string`json:"balance"`

// The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
    BurnchainLockHeight int`json:"burnchain_lock_height"`

// The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
    BurnchainUnlockHeight int`json:"burnchain_unlock_height"`

// The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
    LockHeight int`json:"lock_height"`

// The transaction where the lock event occurred. Empty if no tokens are locked.
    LockTxId string`json:"lock_tx_id"`

// The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
    Locked string`json:"locked"`
    TotalFeesSent string`json:"total_fees_sent"`
    TotalMinerRewardsReceived string`json:"total_miner_rewards_received"`
    TotalReceived string`json:"total_received"`
    TotalSent string`json:"total_sent"`
}`json:"stx"`

// Token Offering Locked
    TokenOfferingLocked *struct {
// Micro-STX amount still locked at current block height.
    TotalLocked string`json:"total_locked"`

// Micro-STX amount unlocked at current block height.
    TotalUnlocked string`json:"total_unlocked"`
    UnlockSchedule []struct {
// Micro-STX amount locked at this block height.
    Amount string`json:"amount"`
    BlockHeight float32`json:"block_height"`
}`json:"unlock_schedule"`
}`json:"token_offering_locked,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountBalanceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountBalanceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountNftResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    NftEvents []struct {
    AssetIdentifier string`json:"asset_identifier"`
    BlockHeight float32`json:"block_height"`
    Recipient string`json:"recipient"`
    Sender string`json:"sender"`
    TxId string`json:"tx_id"`

// Identifier of the NFT
    Value struct {
// Hex string representing the identifier of the NFT
    Hex string`json:"hex"`

// Readable string of the NFT identifier
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_events"`
    Offset int`json:"offset"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountNftResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountNftResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountNoncesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Nonces that appear to be missing and likely causing a mempool transaction to be stuck.
    DetectedMissingNonces []int`json:"detected_missing_nonces"`

// The latest nonce found within transactions sent by this address, including unanchored microblock transactions. Will be null if there are no current transactions for this address.
    LastExecutedTxNonce *int`json:"last_executed_tx_nonce"`

// The latest nonce found within mempool transactions sent by this address. Will be null if there are no current mempool transactions for this address.
    LastMempoolTxNonce *int`json:"last_mempool_tx_nonce"`

// The likely nonce required for creating the next transaction, based on the last nonces seen by the API. This can be incorrect if the API's mempool or transactions aren't fully synchronized, even by a small amount, or if a previous transaction is still propagating through the Stacks blockchain network when this endpoint is called.
    PossibleNextNonce int`json:"possible_next_nonce"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountNoncesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountNoncesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountStxBalanceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Balance string`json:"balance"`

// The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
    BurnchainLockHeight int`json:"burnchain_lock_height"`

// The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
    BurnchainUnlockHeight int`json:"burnchain_unlock_height"`

// The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
    LockHeight int`json:"lock_height"`

// The transaction where the lock event occurred. Empty if no tokens are locked.
    LockTxId string`json:"lock_tx_id"`

// The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
    Locked string`json:"locked"`

// Token Offering Locked
    TokenOfferingLocked *struct {
// Micro-STX amount still locked at current block height.
    TotalLocked string`json:"total_locked"`

// Micro-STX amount unlocked at current block height.
    TotalUnlocked string`json:"total_unlocked"`
    UnlockSchedule []struct {
// Micro-STX amount locked at this block height.
    Amount string`json:"amount"`
    BlockHeight float32`json:"block_height"`
}`json:"unlock_schedule"`
}`json:"token_offering_locked,omitempty"`
    TotalFeesSent string`json:"total_fees_sent"`
    TotalMinerRewardsReceived string`json:"total_miner_rewards_received"`
    TotalReceived string`json:"total_received"`
    TotalSent string`json:"total_sent"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountStxBalanceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountStxBalanceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountInboundResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []struct {
// Transfer amount in micro-STX as integer string
    Amount string`json:"amount"`

// Block height at which this transfer occurred
    BlockHeight float32`json:"block_height"`

// Hex encoded memo bytes associated with the transfer
    Memo string`json:"memo"`

// Principal that sent this transfer
    Sender string`json:"sender"`

// Indicates if the transfer is from a stx-transfer transaction or a contract-call transaction
    TransferType N200ResultsTransferType`json:"transfer_type"`

// The transaction ID in which this transfer occurred
    TxId string`json:"tx_id"`

// Index of the transaction within a block
    TxIndex float32`json:"tx_index"`
}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountInboundResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInboundResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountTransactionsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountTransactionsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountTransactionsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountTransactionsWithTransfersResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []struct {
    FtTransfers *[]struct {
// Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
    Amount string`json:"amount"`

// Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`
}`json:"ft_transfers,omitempty"`
    NftTransfers *[]struct {
// Non Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`

// Non Fungible Token asset value.
    Value struct {
    Hex string`json:"hex"`
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_transfers,omitempty"`

// Total received by the given address in micro-STX as an integer string.
    StxReceived string`json:"stx_received"`

// Total sent from the given address, including the tx fee, in micro-STX as an integer string.
    StxSent string`json:"stx_sent"`
    StxTransfers []struct {
// Amount transferred in micro-STX as an integer string.
    Amount string`json:"amount"`

// Principal that received STX. This is unspecified if the STX were burned.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent STX. This is unspecified if the STX were minted.
    Sender *string`json:"sender,omitempty"`
}`json:"stx_transfers"`

// Describes all transaction types on Stacks 2.0 blockchain
    Tx interface{}`json:"tx"`
}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountTransactionsWithTransfersResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountTransactionsWithTransfersResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetSingleTransactionWithTransfersResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    FtTransfers *[]struct {
// Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
    Amount string`json:"amount"`

// Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`
}`json:"ft_transfers,omitempty"`
    NftTransfers *[]struct {
// Non Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`

// Non Fungible Token asset value.
    Value struct {
    Hex string`json:"hex"`
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_transfers,omitempty"`

// Total received by the given address in micro-STX as an integer string.
    StxReceived string`json:"stx_received"`

// Total sent from the given address, including the tx fee, in micro-STX as an integer string.
    StxSent string`json:"stx_sent"`
    StxTransfers []struct {
// Amount transferred in micro-STX as an integer string.
    Amount string`json:"amount"`

// Principal that received STX. This is unspecified if the STX were burned.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent STX. This is unspecified if the STX were minted.
    Sender *string`json:"sender,omitempty"`
}`json:"stx_transfers"`

// Describes all transaction types on Stacks 2.0 blockchain
    Tx interface{}`json:"tx"`
}
}

// Status returns HTTPResponse.Status
func (r GetSingleTransactionWithTransfersResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleTransactionWithTransfersResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBlockListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of blocks to return
    Limit int`json:"limit"`

// The number to blocks to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}`json:"results"`

// The number of blocks available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetBlockListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBlockByBurnBlockHashResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
}

// Status returns HTTPResponse.Status
func (r GetBlockByBurnBlockHashResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockByBurnBlockHashResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBlockByBurnBlockHeightResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
}

// Status returns HTTPResponse.Status
func (r GetBlockByBurnBlockHeightResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockByBurnBlockHeightResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBlockByHeightResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
}

// Status returns HTTPResponse.Status
func (r GetBlockByHeightResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockByHeightResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBlockByHashResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
}

// Status returns HTTPResponse.Status
func (r GetBlockByHashResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockByHashResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBurnchainRewardSlotHoldersResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of items to return
    Limit int`json:"limit"`

// The number of items to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    Address string`json:"address"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
    SlotIndex int`json:"slot_index"`
}`json:"results"`

// Total number of available items
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetBurnchainRewardSlotHoldersResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnchainRewardSlotHoldersResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBurnchainRewardSlotHoldersByAddressResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of items to return
    Limit int`json:"limit"`

// The number of items to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    Address string`json:"address"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
    SlotIndex int`json:"slot_index"`
}`json:"results"`

// Total number of available items
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetBurnchainRewardSlotHoldersByAddressResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnchainRewardSlotHoldersByAddressResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBurnchainRewardListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of burnchain rewards to return
    Limit int`json:"limit"`

// The number to burnchain rewards to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
    BurnAmount string`json:"burn_amount"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
    RewardIndex int`json:"reward_index"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}`json:"results"`
}
}

// Status returns HTTPResponse.Status
func (r GetBurnchainRewardListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnchainRewardListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBurnchainRewardListByAddressResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of burnchain rewards to return
    Limit int`json:"limit"`

// The number to burnchain rewards to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
    BurnAmount string`json:"burn_amount"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
    RewardIndex int`json:"reward_index"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}`json:"results"`
}
}

// Status returns HTTPResponse.Status
func (r GetBurnchainRewardListByAddressResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnchainRewardListByAddressResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetBurnchainRewardsTotalByAddressResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The total amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}
}

// Status returns HTTPResponse.Status
func (r GetBurnchainRewardsTotalByAddressResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBurnchainRewardsTotalByAddressResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractsByTraitResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of contracts to return
    Limit int`json:"limit"`

// The number to contracts to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
    Abi string`json:"abi"`
    BlockHeight int`json:"block_height"`
    Canonical bool`json:"canonical"`
    SourceCode string`json:"source_code"`
    TxId string`json:"tx_id"`
}`json:"results"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractsByTraitResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractsByTraitResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractByIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
    AnchorMode N200AnchorMode`json:"anchor_mode"`

// Hash of the blocked this transactions was associated with
    BlockHash string`json:"block_hash"`

// Height of the block this transactions was associated with
    BlockHeight int`json:"block_height"`

// Unix timestamp (in seconds) indicating when this block was mined
    BurnBlockTime int`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Number of transaction events
    EventCount int`json:"event_count"`

// List of transaction events
    Events []interface{}`json:"events"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Transaction fee as Integer string (64-bit unsigned integer).
    FeeRate string`json:"fee_rate"`

// True if the transaction is included in a microblock that has not been confirmed by an anchor block.
    IsUnanchored bool`json:"is_unanchored"`

// Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
    MicroblockHash string`json:"microblock_hash"`

// The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
    MicroblockSequence int`json:"microblock_sequence"`

// Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
    Nonce int`json:"nonce"`

// Hash of the previous block.
    ParentBlockHash string`json:"parent_block_hash"`

// Unix timestamp (in seconds) indicating when this parent block was mined
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`
    PostConditionMode N200PostConditionMode`json:"post_condition_mode"`
    PostConditions []interface{}`json:"post_conditions"`

// Address of the transaction initiator
    SenderAddress string`json:"sender_address"`
    SmartContract struct {
// Contract identifier formatted as `<principaladdress>.<contract_name>`
    ContractId string`json:"contract_id"`

// Clarity code of the smart contract being deployed
    SourceCode string`json:"source_code"`
}`json:"smart_contract"`
    SponsorAddress *string`json:"sponsor_address,omitempty"`
    SponsorNonce *int`json:"sponsor_nonce,omitempty"`

// Denotes whether the originating account is the same as the paying account
    Sponsored bool`json:"sponsored"`

// Transaction ID
    TxId string`json:"tx_id"`

// Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
    TxIndex int`json:"tx_index"`

// Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
    TxResult struct {
// Hex string representing the value fo the transaction result
    Hex string`json:"hex"`

// Readable string of the transaction result
    Repr string`json:"repr"`
}`json:"tx_result"`

// Status of the transaction
    TxStatus N200TxStatus`json:"tx_status"`
    TxType N200TxType`json:"tx_type"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractByIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractByIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractEventsByIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *interface{}
}

// Status returns HTTPResponse.Status
func (r GetContractEventsByIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractEventsByIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RunFaucetBtcResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Indicates if the faucet call was successful
    Success bool`json:"success"`

// The transaction ID for the faucet call
    TxId *string`json:"txId,omitempty"`

// Raw transaction in hex string representation
    TxRaw *string`json:"txRaw,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r RunFaucetBtcResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFaucetBtcResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RunFaucetStxResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Indicates if the faucet call was successful
    Success bool`json:"success"`

// The transaction ID for the faucet call
    TxId *string`json:"txId,omitempty"`

// Raw transaction in hex string representation
    TxRaw *string`json:"txRaw,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r RunFaucetStxResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFaucetStxResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type FetchFeeRateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    FeeRate int`json:"fee_rate"`
}
}

// Status returns HTTPResponse.Status
func (r FetchFeeRateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFeeRateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNetworkBlockTimeByNetworkResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    TargetBlockTime int`json:"target_block_time"`
}
}

// Status returns HTTPResponse.Status
func (r GetNetworkBlockTimeByNetworkResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkBlockTimeByNetworkResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNetworkBlockTimesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Mainnet struct {
    TargetBlockTime int`json:"target_block_time"`
}`json:"mainnet"`
    Testnet struct {
    TargetBlockTime int`json:"target_block_time"`
}`json:"testnet"`
}
}

// Status returns HTTPResponse.Status
func (r GetNetworkBlockTimesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkBlockTimesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetMicroblockListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of microblocks to return
    Limit int`json:"limit"`

// The number to microblocks to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
    BlockHash *string`json:"block_hash"`

// The anchor block height that confirmed this microblock.
    BlockHeight int`json:"block_height"`

// Set to `true` if the microblock corresponds to the canonical chain tip.
    Canonical bool`json:"canonical"`

// Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The SHA512/256 hash of this microblock.
    MicroblockHash string`json:"microblock_hash"`

// The SHA512/256 hash of the previous signed microblock in this stream.
    MicroblockParentHash string`json:"microblock_parent_hash"`

// A hint to describe how to order a set of microblocks. Starts at 0.
    MicroblockSequence int`json:"microblock_sequence"`

// The hash of the anchor block that preceded this microblock.
    ParentBlockHash string`json:"parent_block_hash"`

// The height of the anchor block that preceded this microblock.
    ParentBlockHeight int`json:"parent_block_height"`

// The hash of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHash string`json:"parent_burn_block_hash"`

// The height of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHeight int`json:"parent_burn_block_height"`

// The block timestamp of the Bitcoin block that preceded this microblock.
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`

// List of transactions included in the microblock
    Txs []string`json:"txs"`
}`json:"results"`

// The number of microblocks available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetMicroblockListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMicroblockListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetUnanchoredTxsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Results []interface{}`json:"results"`

// The number of unanchored transactions available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetUnanchoredTxsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnanchoredTxsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetMicroblockByHashResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
    BlockHash *string`json:"block_hash"`

// The anchor block height that confirmed this microblock.
    BlockHeight int`json:"block_height"`

// Set to `true` if the microblock corresponds to the canonical chain tip.
    Canonical bool`json:"canonical"`

// Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The SHA512/256 hash of this microblock.
    MicroblockHash string`json:"microblock_hash"`

// The SHA512/256 hash of the previous signed microblock in this stream.
    MicroblockParentHash string`json:"microblock_parent_hash"`

// A hint to describe how to order a set of microblocks. Starts at 0.
    MicroblockSequence int`json:"microblock_sequence"`

// The hash of the anchor block that preceded this microblock.
    ParentBlockHash string`json:"parent_block_hash"`

// The height of the anchor block that preceded this microblock.
    ParentBlockHeight int`json:"parent_block_height"`

// The hash of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHash string`json:"parent_burn_block_hash"`

// The height of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHeight int`json:"parent_burn_block_height"`

// The block timestamp of the Bitcoin block that preceded this microblock.
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`

// List of transactions included in the microblock
    Txs []string`json:"txs"`
}
}

// Status returns HTTPResponse.Status
func (r GetMicroblockByHashResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMicroblockByHashResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type SearchByIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *interface{}
}

// Status returns HTTPResponse.Status
func (r SearchByIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchByIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetStatusResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Current chain tip information
    ChainTip *struct {
// the current block hash
    BlockHash string`json:"block_hash"`

// the current block height
    BlockHeight int`json:"block_height"`

// the current index block hash
    IndexBlockHash string`json:"index_block_hash"`

// the current microblock hash
    MicroblockHash *string`json:"microblock_hash,omitempty"`

// the current microblock sequence number
    MicroblockSequence *int`json:"microblock_sequence,omitempty"`
}`json:"chain_tip,omitempty"`

// the server version that is currently running
    ServerVersion *string`json:"server_version,omitempty"`

// the current server status
    Status string`json:"status"`
}
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetStxSupplyResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The block height at which this information was queried
    BlockHeight int`json:"block_height"`

// String quoted decimal number of the total possible number of STX
    TotalStx string`json:"total_stx"`

// String quoted decimal number of the percentage of STX that have unlocked
    UnlockedPercent string`json:"unlocked_percent"`

// String quoted decimal number of the STX that have been mined or unlocked
    UnlockedStx string`json:"unlocked_stx"`
}
}

// Status returns HTTPResponse.Status
func (r GetStxSupplyResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStxSupplyResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetStxSupplyCirculatingPlainResponse struct {
    Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStxSupplyCirculatingPlainResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStxSupplyCirculatingPlainResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTotalStxSupplyLegacyFormatResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The block height at which this information was queried
    BlockHeight string`json:"blockHeight"`

// String quoted decimal number of the total possible number of STX
    TotalStacks string`json:"totalStacks"`

// Same as `totalStacks` but formatted with comma thousands separators
    TotalStacksFormatted string`json:"totalStacksFormatted"`

// String quoted decimal number of the percentage of STX that have unlocked
    UnlockedPercent string`json:"unlockedPercent"`

// String quoted decimal number of the STX that have been mined or unlocked
    UnlockedSupply string`json:"unlockedSupply"`

// Same as `unlockedSupply` but formatted with comma thousands separators
    UnlockedSupplyFormatted string`json:"unlockedSupplyFormatted"`
}
}

// Status returns HTTPResponse.Status
func (r GetTotalStxSupplyLegacyFormatResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTotalStxSupplyLegacyFormatResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetStxSupplyTotalSupplyPlainResponse struct {
    Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetStxSupplyTotalSupplyPlainResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStxSupplyTotalSupplyPlainResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetFtMetadataListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of tokens metadata to return
    Limit int`json:"limit"`

// The number to tokens metadata to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The number of decimal places in a token.
    Decimals float32`json:"decimals"`

// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
    Symbol string`json:"symbol"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}`json:"results"`

// The number of tokens metadata available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetFtMetadataListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFtMetadataListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNftHistoryResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of events to return
    Limit int`json:"limit"`

// The number to events to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of events available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetNftHistoryResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNftHistoryResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNftHoldingsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of Non-Fungible Token holdings to return
    Limit int`json:"limit"`

// The number to Non-Fungible Token holdings to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of Non-Fungible Token holdings available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetNftHoldingsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNftHoldingsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNftMetadataListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of tokens metadata to return
    Limit int`json:"limit"`

// The number to tokens metadata to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}`json:"results"`

// The number of tokens metadata available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetNftMetadataListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNftMetadataListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNftMintsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of mint events to return
    Limit int`json:"limit"`

// The number to mint events to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of mint events available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetNftMintsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNftMintsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractFtMetadataResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of decimal places in a token.
    Decimals float32`json:"decimals"`

// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
    Symbol string`json:"symbol"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractFtMetadataResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractFtMetadataResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractNftMetadataResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractNftMetadataResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractNftMetadataResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTransactionListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetTransactionListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTransactionsByBlockHashResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetTransactionsByBlockHashResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsByBlockHashResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTransactionsByBlockHeightResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetTransactionsByBlockHeightResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsByBlockHeightResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetFilteredEventsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
}
}

// Status returns HTTPResponse.Status
func (r GetFilteredEventsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilteredEventsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetMempoolTransactionListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetMempoolTransactionListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMempoolTransactionListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetDroppedMempoolTransactionListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
}

// Status returns HTTPResponse.Status
func (r GetDroppedMempoolTransactionListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDroppedMempoolTransactionListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTxListDetailsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
AdditionalProperties map[string]interface{} `json:"-"`
}
}

// Status returns HTTPResponse.Status
func (r GetTxListDetailsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTxListDetailsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTransactionByIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *interface{}
}

// Status returns HTTPResponse.Status
func (r GetTransactionByIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionByIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetRawTransactionByIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// A hex encoded serialized transaction
    RawTx string`json:"raw_tx"`
}
}

// Status returns HTTPResponse.Status
func (r GetRawTransactionByIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRawTransactionByIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaAccountBalanceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// A single account balance may have multiple currencies
    Balances []struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"balances"`

// The block_identifier uniquely identifies a block in a particular network.
    BlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"block_identifier"`

// If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.
    Coins *[]struct {
// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coins,omitempty"`

// Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
    Metadata *struct {
    SequenceNumber int`json:"sequence_number"`
}`json:"metadata,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaAccountBalanceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaAccountBalanceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaBlockResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be inalterable: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents.
    Block *struct {
// The block_identifier uniquely identifies a block in a particular network.
    BlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"block_identifier"`

// meta data
    Metadata *struct {
    Difficulty string`json:"difficulty"`
    TransactionsRoot string`json:"transactions_root"`
}`json:"metadata,omitempty"`

// The block_identifier uniquely identifies a block in a particular network.
    ParentBlockIdentifier struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"parent_block_identifier"`

// The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
    Timestamp int`json:"timestamp"`

// All the transactions in the block
    Transactions []struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200BlockTransactionsOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transactions"`
}`json:"block,omitempty"`

// Some blockchains may require additional transactions to be fetched that weren't returned in the block response (ex: block only returns transaction hashes). For blockchains with a lot of transactions in each block, this can be very useful as consumers can concurrently fetch all transactions returned.
    OtherTransactions *[]struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"other_transactions,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaBlockResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaBlockResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaBlockTransactionResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
    Transaction struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200TransactionOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transaction"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaBlockTransactionResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaBlockTransactionResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionCombineResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Signed transaction bytes in hex
    SignedTransaction string`json:"signed_transaction"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionCombineResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionCombineResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionDeriveResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier,omitempty"`

// [DEPRECATED by account_identifier in v1.4.4] Address in network-specific format.
    Address *string`json:"address,omitempty"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionDeriveResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionDeriveResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionHashResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionHashResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionHashResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionMetadataResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Metadata struct {
    AccountSequence *int`json:"account_sequence,omitempty"`
    RecentBlockHash *string`json:"recent_block_hash,omitempty"`
}`json:"metadata"`
    SuggestedFee *[]struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"suggested_fee,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionMetadataResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionMetadataResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionParseResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    AccountIdentifierSigners *[]struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier_signers,omitempty"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200OperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// [DEPRECATED by account_identifier_signers in v1.4.4] All signers (addresses) of a particular transaction. If the transaction is unsigned, it should be empty.
    Signers *[]interface{}`json:"signers,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionParseResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionParseResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionPayloadsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// An array of payloads that must be signed by the caller
    Payloads []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier,omitempty"`

// [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
    Address *string`json:"address,omitempty"`
    HexBytes string`json:"hex_bytes"`

// SignatureType is the type of a cryptographic signature.
    SignatureType *N200PayloadsSignatureType`json:"signature_type,omitempty"`
}`json:"payloads"`

// This is an unsigned transaction blob (that is usually needed to construct the a network transaction from a collection of signatures)
    UnsignedTransaction string`json:"unsigned_transaction"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionPayloadsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionPayloadsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionPreprocessResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The options that will be sent directly to /construction/metadata by the caller.
    Options *struct {
// Amount to be transfered.
    Amount *string`json:"amount,omitempty"`

// Set the burnchain (BTC) block for stacking lock to start.
    BurnBlockHeight *int`json:"burn_block_height,omitempty"`

// Address of the contract to call.
    ContractAddress *string`json:"contract_address,omitempty"`

// Name of the contract to call.
    ContractName *string`json:"contract_name,omitempty"`

// Number of decimal places
    Decimals *int`json:"decimals,omitempty"`

// Delegator address for when calling `delegate-stacking`.
    DelegateTo *string`json:"delegate_to,omitempty"`

// Fee for this transaction
    Fee *string`json:"fee,omitempty"`

// Maximum price a user is willing to pay.
    GasLimit *float32`json:"gas_limit,omitempty"`

// Cost necessary to perform a transaction on the network
    GasPrice *float32`json:"gas_price,omitempty"`

// Maximum fee user is willing to pay
    MaxFee *string`json:"max_fee,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// Number of cycles when stacking.
    NumberOfCycles *int`json:"number_of_cycles,omitempty"`

// The reward address for stacking transaction. It should be a valid Bitcoin address
    PoxAddr *string`json:"pox_addr,omitempty"`

// sender's address 
    SenderAddress *string`json:"sender_address,omitempty"`

// Transaction approximative size (used to calculate total fee).
    Size *int`json:"size,omitempty"`

// This value indicates the state of the operations
    Status *string`json:"status,omitempty"`

//  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
    SuggestedFeeMultiplier *float32`json:"suggested_fee_multiplier,omitempty"`

// Currency symbol e.g STX
    Symbol *string`json:"symbol,omitempty"`

// Recipient's address
    TokenTransferRecipientAddress *string`json:"token_transfer_recipient_address,omitempty"`

// Type of operation e.g transfer
    Type *string`json:"type,omitempty"`
}`json:"options,omitempty"`
    RequiredPublicKeys *[]struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"required_public_keys,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionPreprocessResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionPreprocessResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaConstructionSubmitResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaConstructionSubmitResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaConstructionSubmitResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaMempoolResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
    TransactionIdentifiers []struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifiers"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaMempoolResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaMempoolResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaMempoolTransactionResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
    Transaction struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200TransactionOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transaction"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaMempoolTransactionResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaMempoolTransactionResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaNetworkListResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifiers []struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifiers"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaNetworkListResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaNetworkListResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaNetworkOptionsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Allow specifies supported Operation status, Operation types, and all possible error statuses. This Allow object is used by clients to validate the correctness of a Rosetta Server implementation. It is expected that these clients will error if they receive some response that contains any of the above information that is not specified here.
    Allow struct {
// All Errors that this implementation could return. Any error that is returned during parsing that is not listed here will cause client validation to error.
    Errors []struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}`json:"errors"`

// Any Rosetta implementation that supports querying the balance of an account at any height in the past should set this to true.
    HistoricalBalanceLookup bool`json:"historical_balance_lookup"`

// All Operation.Status this implementation supports. Any status that is returned during parsing that is not listed here will cause client validation to error.
    OperationStatuses []struct {
// The status is the network-specific status of the operation.
    Status string`json:"status"`

// An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.
    Successful bool`json:"successful"`
}`json:"operation_statuses"`

// All Operation.Type this implementation supports. Any type that is returned during parsing that is not listed here will cause client validation to error.
    OperationTypes []interface{}`json:"operation_types"`
}`json:"allow"`

// The Version object is utilized to inform the client of the versions of different components of the Rosetta implementation.
    Version struct {
// Any other information that may be useful about versioning of dependent services should be returned here.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// When a middleware server is used to adhere to the Rosetta interface, it should return its version here. This can help clients manage deployments.
    MiddlewareVersion *string`json:"middleware_version,omitempty"`

// The node_version is the canonical version of the node runtime. This can help clients manage deployments.
    NodeVersion string`json:"node_version"`

// The rosetta_version is the version of the Rosetta interface the implementation adheres to. This can be useful for clients looking to reliably parse responses.
    RosettaVersion string`json:"rosetta_version"`
}`json:"version"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaNetworkOptionsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaNetworkOptionsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type RosettaNetworkStatusResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// The block_identifier uniquely identifies a block in a particular network.
    CurrentBlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"current_block_identifier"`

// The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
    CurrentBlockTimestamp int`json:"current_block_timestamp"`

// The block_identifier uniquely identifies a block in a particular network.
    GenesisBlockIdentifier struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"genesis_block_identifier"`

// The block_identifier uniquely identifies a block in a particular network.
    OldestBlockIdentifier *struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"oldest_block_identifier,omitempty"`

// Peers information
    Peers []struct {
// meta data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// peer id
    PeerId string`json:"peer_id"`
}`json:"peers"`

// SyncStatus is used to provide additional context about an implementation's sync status. It is often used to indicate that an implementation is healthy when it cannot be queried until some sync phase occurs. If an implementation is immediately queryable, this model is often not populated.
    SyncStatus *struct {
// CurrentIndex is the index of the last synced block in the current stage.
    CurrentIndex int`json:"current_index"`

// Stage is the phase of the sync process.
    Stage *string`json:"stage,omitempty"`

// Synced indicates if an implementation has synced up to the most recent block.
    Synced *bool`json:"synced,omitempty"`

// TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.
    TargetIndex *int`json:"target_index,omitempty"`
}`json:"sync_status,omitempty"`
}
    JSON400 *struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
}

// Status returns HTTPResponse.Status
func (r RosettaNetworkStatusResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RosettaNetworkStatusResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNamesOwnedByAddressResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Names []string`json:"names"`
}
    JSON404 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetNamesOwnedByAddressResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamesOwnedByAddressResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAllNamesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]string
    JSON400 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetAllNamesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllNamesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNameInfoResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Address string`json:"address"`
    Blockchain string`json:"blockchain"`
    ExpireBlock *int`json:"expire_block,omitempty"`
    GracePeriod *int`json:"grace_period,omitempty"`
    LastTxid string`json:"last_txid"`
    Resolver *string`json:"resolver,omitempty"`
    Status string`json:"status"`
    Zonefile string`json:"zonefile"`
    ZonefileHash string`json:"zonefile_hash"`
}
    JSON400 *struct {
    Error *string`json:"error,omitempty"`
}
    JSON404 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetNameInfoResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameInfoResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type FetchSubdomainsListForNameResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]string
}

// Status returns HTTPResponse.Status
func (r FetchSubdomainsListForNameResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSubdomainsListForNameResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type FetchZoneFileResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *interface{}
    JSON400 *struct {
    Error *string`json:"error,omitempty"`
}
    JSON404 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r FetchZoneFileResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchZoneFileResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetHistoricalZoneFileResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *interface{}
    JSON400 *struct {
    Error *string`json:"error,omitempty"`
}
    JSON404 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetHistoricalZoneFileResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHistoricalZoneFileResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAllNamespacesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Namespaces []string`json:"namespaces"`
}
}

// Status returns HTTPResponse.Status
func (r GetAllNamespacesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllNamespacesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNamespaceNamesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]string
    JSON400 *struct {
    Error *string`json:"error,omitempty"`
}
    JSON404 *struct {
    Error *string`json:"error,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetNamespaceNamesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespaceNamesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetAccountInfoResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Balance string`json:"balance"`
    BalanceProof string`json:"balance_proof"`
    Locked string`json:"locked"`
    Nonce int`json:"nonce"`
    NonceProof string`json:"nonce_proof"`
    UnlockHeight int`json:"unlock_height"`
}
}

// Status returns HTTPResponse.Status
func (r GetAccountInfoResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInfoResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type CallReadOnlyFunctionResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Cause *string`json:"cause,omitempty"`
    Okay bool`json:"okay"`
    Result *string`json:"result,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r CallReadOnlyFunctionResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CallReadOnlyFunctionResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractInterfaceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// List of defined methods
    Functions []map[string]interface{}`json:"functions"`

// List of fungible tokens in the contract
    FungibleTokens []map[string]interface{}`json:"fungible_tokens"`

// List of defined data-maps
    Maps []map[string]interface{}`json:"maps"`

// List of non-fungible tokens in the contract
    NonFungibleTokens []map[string]interface{}`json:"non_fungible_tokens"`

// List of defined variables
    Variables []map[string]interface{}`json:"variables"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractInterfaceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractInterfaceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractSourceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Proof string`json:"proof"`
    PublishHeight int`json:"publish_height"`
    Source string`json:"source"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractSourceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractSourceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PostFeeTransactionResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    CostScalarChangeByByte *float32`json:"cost_scalar_change_by_byte,omitempty"`
    EstimatedCost struct {
    ReadCount int`json:"read_count"`
    ReadLength int`json:"read_length"`
    Runtime int`json:"runtime"`
    WriteCount int`json:"write_count"`
    WriteLength int`json:"write_length"`
}`json:"estimated_cost"`
    EstimatedCostScalar int`json:"estimated_cost_scalar"`
    Estimations *[]struct {
    Fee *float32`json:"fee,omitempty"`
    FeeRate *float32`json:"fee_rate,omitempty"`
}`json:"estimations,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r PostFeeTransactionResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFeeTransactionResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetFeeTransferResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *string
}

// Status returns HTTPResponse.Status
func (r GetFeeTransferResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeeTransferResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetCoreApiInfoResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// latest bitcoin chain height
    BurnBlockHeight int`json:"burn_block_height"`

// the block height at which the testnet network will be reset. not applicable for mainnet
    ExitAtBlockHeight int`json:"exit_at_block_height"`

// is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change
    NetworkId int`json:"network_id"`

// same as network_id, but for bitcoin
    ParentNetworkId int`json:"parent_network_id"`

// identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade
    PeerVersion int`json:"peer_version"`

// is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block
    PoxConsensus string`json:"pox_consensus"`

// is a version descriptor
    ServerVersion string`json:"server_version"`

// leftover from stacks 1.0, basically always burn_block_height - 1
    StableBurnBlockHeight int`json:"stable_burn_block_height"`

// same as burn_consensus, but evaluated at stable_burn_block_height
    StablePoxConsensus string`json:"stable_pox_consensus"`

// the best known block hash for the Stack chain (not including any pending microblocks)
    StacksTip string`json:"stacks_tip"`

// the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined
    StacksTipConsensusHash string`json:"stacks_tip_consensus_hash"`

// the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height
    StacksTipHeight int`json:"stacks_tip_height"`

// the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned
    UnanchoredTip string`json:"unanchored_tip"`
}
}

// Status returns HTTPResponse.Status
func (r GetCoreApiInfoResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoreApiInfoResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetContractDataMapEntryResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
// Hex-encoded string of clarity value. It is always an optional tuple.
    Data string`json:"data"`

// Hex-encoded string of the MARF proof for the data
    Proof *string`json:"proof,omitempty"`
}
}

// Status returns HTTPResponse.Status
func (r GetContractDataMapEntryResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContractDataMapEntryResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetPoxInfoResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    ContractId string`json:"contract_id"`
    FirstBurnchainBlockHeight int`json:"first_burnchain_block_height"`
    MinAmountUstx int`json:"min_amount_ustx"`
    RegistrationWindowLength int`json:"registration_window_length"`
    RejectionFraction int`json:"rejection_fraction"`
    RejectionVotesLeftRequired int`json:"rejection_votes_left_required"`
    RewardCycleId int`json:"reward_cycle_id"`
    RewardCycleLength int`json:"reward_cycle_length"`
    TotalLiquidSupplyUstx int`json:"total_liquid_supply_ustx"`
}
}

// Status returns HTTPResponse.Status
func (r GetPoxInfoResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoxInfoResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNamePriceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Amount string`json:"amount"`
    Units string`json:"units"`
}
}

// Status returns HTTPResponse.Status
func (r GetNamePriceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamePriceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetNamespacePriceResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Amount string`json:"amount"`
    Units string`json:"units"`
}
}

// Status returns HTTPResponse.Status
func (r GetNamespacePriceResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamespacePriceResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PostCoreNodeTransactionsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON400 *struct {
// The error
    Error string`json:"error"`

// The reason for the error
    Reason string`json:"reason"`

// More details about the reason
    ReasonData map[string]interface{}`json:"reason_data"`

// The relevant transaction id
    Txid string`json:"txid"`
}
}

// Status returns HTTPResponse.Status
func (r PostCoreNodeTransactionsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCoreNodeTransactionsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}






// GetAddressMempoolTransactionsWithResponse request returning *GetAddressMempoolTransactionsResponse
func (c *ClientWithResponses) GetAddressMempoolTransactionsWithResponse(ctx context.Context, address string, params *GetAddressMempoolTransactionsParams, reqEditors... RequestEditorFn) (*GetAddressMempoolTransactionsResponse, error){
    rsp, err := c.GetAddressMempoolTransactions(ctx, address, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAddressMempoolTransactionsResponse(rsp)
}






// GetAccountAssetsWithResponse request returning *GetAccountAssetsResponse
func (c *ClientWithResponses) GetAccountAssetsWithResponse(ctx context.Context, principal string, params *GetAccountAssetsParams, reqEditors... RequestEditorFn) (*GetAccountAssetsResponse, error){
    rsp, err := c.GetAccountAssets(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountAssetsResponse(rsp)
}






// GetAccountBalanceWithResponse request returning *GetAccountBalanceResponse
func (c *ClientWithResponses) GetAccountBalanceWithResponse(ctx context.Context, principal string, params *GetAccountBalanceParams, reqEditors... RequestEditorFn) (*GetAccountBalanceResponse, error){
    rsp, err := c.GetAccountBalance(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountBalanceResponse(rsp)
}






// GetAccountNftWithResponse request returning *GetAccountNftResponse
func (c *ClientWithResponses) GetAccountNftWithResponse(ctx context.Context, principal string, params *GetAccountNftParams, reqEditors... RequestEditorFn) (*GetAccountNftResponse, error){
    rsp, err := c.GetAccountNft(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountNftResponse(rsp)
}






// GetAccountNoncesWithResponse request returning *GetAccountNoncesResponse
func (c *ClientWithResponses) GetAccountNoncesWithResponse(ctx context.Context, principal string, params *GetAccountNoncesParams, reqEditors... RequestEditorFn) (*GetAccountNoncesResponse, error){
    rsp, err := c.GetAccountNonces(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountNoncesResponse(rsp)
}






// GetAccountStxBalanceWithResponse request returning *GetAccountStxBalanceResponse
func (c *ClientWithResponses) GetAccountStxBalanceWithResponse(ctx context.Context, principal string, params *GetAccountStxBalanceParams, reqEditors... RequestEditorFn) (*GetAccountStxBalanceResponse, error){
    rsp, err := c.GetAccountStxBalance(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountStxBalanceResponse(rsp)
}






// GetAccountInboundWithResponse request returning *GetAccountInboundResponse
func (c *ClientWithResponses) GetAccountInboundWithResponse(ctx context.Context, principal string, params *GetAccountInboundParams, reqEditors... RequestEditorFn) (*GetAccountInboundResponse, error){
    rsp, err := c.GetAccountInbound(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountInboundResponse(rsp)
}






// GetAccountTransactionsWithResponse request returning *GetAccountTransactionsResponse
func (c *ClientWithResponses) GetAccountTransactionsWithResponse(ctx context.Context, principal string, params *GetAccountTransactionsParams, reqEditors... RequestEditorFn) (*GetAccountTransactionsResponse, error){
    rsp, err := c.GetAccountTransactions(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountTransactionsResponse(rsp)
}






// GetAccountTransactionsWithTransfersWithResponse request returning *GetAccountTransactionsWithTransfersResponse
func (c *ClientWithResponses) GetAccountTransactionsWithTransfersWithResponse(ctx context.Context, principal string, params *GetAccountTransactionsWithTransfersParams, reqEditors... RequestEditorFn) (*GetAccountTransactionsWithTransfersResponse, error){
    rsp, err := c.GetAccountTransactionsWithTransfers(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountTransactionsWithTransfersResponse(rsp)
}






// GetSingleTransactionWithTransfersWithResponse request returning *GetSingleTransactionWithTransfersResponse
func (c *ClientWithResponses) GetSingleTransactionWithTransfersWithResponse(ctx context.Context, principal string, txId string, reqEditors... RequestEditorFn) (*GetSingleTransactionWithTransfersResponse, error){
    rsp, err := c.GetSingleTransactionWithTransfers(ctx, principal, txId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetSingleTransactionWithTransfersResponse(rsp)
}






// GetBlockListWithResponse request returning *GetBlockListResponse
func (c *ClientWithResponses) GetBlockListWithResponse(ctx context.Context, params *GetBlockListParams, reqEditors... RequestEditorFn) (*GetBlockListResponse, error){
    rsp, err := c.GetBlockList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBlockListResponse(rsp)
}






// GetBlockByBurnBlockHashWithResponse request returning *GetBlockByBurnBlockHashResponse
func (c *ClientWithResponses) GetBlockByBurnBlockHashWithResponse(ctx context.Context, burnBlockHash string, reqEditors... RequestEditorFn) (*GetBlockByBurnBlockHashResponse, error){
    rsp, err := c.GetBlockByBurnBlockHash(ctx, burnBlockHash, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBlockByBurnBlockHashResponse(rsp)
}






// GetBlockByBurnBlockHeightWithResponse request returning *GetBlockByBurnBlockHeightResponse
func (c *ClientWithResponses) GetBlockByBurnBlockHeightWithResponse(ctx context.Context, burnBlockHeight float32, reqEditors... RequestEditorFn) (*GetBlockByBurnBlockHeightResponse, error){
    rsp, err := c.GetBlockByBurnBlockHeight(ctx, burnBlockHeight, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBlockByBurnBlockHeightResponse(rsp)
}






// GetBlockByHeightWithResponse request returning *GetBlockByHeightResponse
func (c *ClientWithResponses) GetBlockByHeightWithResponse(ctx context.Context, height float32, reqEditors... RequestEditorFn) (*GetBlockByHeightResponse, error){
    rsp, err := c.GetBlockByHeight(ctx, height, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBlockByHeightResponse(rsp)
}






// GetBlockByHashWithResponse request returning *GetBlockByHashResponse
func (c *ClientWithResponses) GetBlockByHashWithResponse(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*GetBlockByHashResponse, error){
    rsp, err := c.GetBlockByHash(ctx, hash, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBlockByHashResponse(rsp)
}






// GetBurnchainRewardSlotHoldersWithResponse request returning *GetBurnchainRewardSlotHoldersResponse
func (c *ClientWithResponses) GetBurnchainRewardSlotHoldersWithResponse(ctx context.Context, params *GetBurnchainRewardSlotHoldersParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardSlotHoldersResponse, error){
    rsp, err := c.GetBurnchainRewardSlotHolders(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBurnchainRewardSlotHoldersResponse(rsp)
}






// GetBurnchainRewardSlotHoldersByAddressWithResponse request returning *GetBurnchainRewardSlotHoldersByAddressResponse
func (c *ClientWithResponses) GetBurnchainRewardSlotHoldersByAddressWithResponse(ctx context.Context, address string, params *GetBurnchainRewardSlotHoldersByAddressParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardSlotHoldersByAddressResponse, error){
    rsp, err := c.GetBurnchainRewardSlotHoldersByAddress(ctx, address, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBurnchainRewardSlotHoldersByAddressResponse(rsp)
}






// GetBurnchainRewardListWithResponse request returning *GetBurnchainRewardListResponse
func (c *ClientWithResponses) GetBurnchainRewardListWithResponse(ctx context.Context, params *GetBurnchainRewardListParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardListResponse, error){
    rsp, err := c.GetBurnchainRewardList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBurnchainRewardListResponse(rsp)
}






// GetBurnchainRewardListByAddressWithResponse request returning *GetBurnchainRewardListByAddressResponse
func (c *ClientWithResponses) GetBurnchainRewardListByAddressWithResponse(ctx context.Context, address string, params *GetBurnchainRewardListByAddressParams, reqEditors... RequestEditorFn) (*GetBurnchainRewardListByAddressResponse, error){
    rsp, err := c.GetBurnchainRewardListByAddress(ctx, address, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBurnchainRewardListByAddressResponse(rsp)
}






// GetBurnchainRewardsTotalByAddressWithResponse request returning *GetBurnchainRewardsTotalByAddressResponse
func (c *ClientWithResponses) GetBurnchainRewardsTotalByAddressWithResponse(ctx context.Context, address string, reqEditors... RequestEditorFn) (*GetBurnchainRewardsTotalByAddressResponse, error){
    rsp, err := c.GetBurnchainRewardsTotalByAddress(ctx, address, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetBurnchainRewardsTotalByAddressResponse(rsp)
}






// GetContractsByTraitWithResponse request returning *GetContractsByTraitResponse
func (c *ClientWithResponses) GetContractsByTraitWithResponse(ctx context.Context, params *GetContractsByTraitParams, reqEditors... RequestEditorFn) (*GetContractsByTraitResponse, error){
    rsp, err := c.GetContractsByTrait(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractsByTraitResponse(rsp)
}






// GetContractByIdWithResponse request returning *GetContractByIdResponse
func (c *ClientWithResponses) GetContractByIdWithResponse(ctx context.Context, contractId string, params *GetContractByIdParams, reqEditors... RequestEditorFn) (*GetContractByIdResponse, error){
    rsp, err := c.GetContractById(ctx, contractId, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractByIdResponse(rsp)
}






// GetContractEventsByIdWithResponse request returning *GetContractEventsByIdResponse
func (c *ClientWithResponses) GetContractEventsByIdWithResponse(ctx context.Context, contractId string, params *GetContractEventsByIdParams, reqEditors... RequestEditorFn) (*GetContractEventsByIdResponse, error){
    rsp, err := c.GetContractEventsById(ctx, contractId, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractEventsByIdResponse(rsp)
}






// RunFaucetBtcWithBodyWithResponse request with arbitrary body returning *RunFaucetBtcResponse
func (c *ClientWithResponses) RunFaucetBtcWithBodyWithResponse(ctx context.Context, params *RunFaucetBtcParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RunFaucetBtcResponse, error){
    rsp, err := c.RunFaucetBtcWithBody(ctx, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRunFaucetBtcResponse(rsp)
}


func (c *ClientWithResponses) RunFaucetBtcWithResponse(ctx context.Context, params *RunFaucetBtcParams, body RunFaucetBtcJSONRequestBody, reqEditors... RequestEditorFn) (*RunFaucetBtcResponse, error) {
    rsp, err := c.RunFaucetBtc(ctx, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRunFaucetBtcResponse(rsp)
}





// RunFaucetStxWithBodyWithResponse request with arbitrary body returning *RunFaucetStxResponse
func (c *ClientWithResponses) RunFaucetStxWithBodyWithResponse(ctx context.Context, params *RunFaucetStxParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RunFaucetStxResponse, error){
    rsp, err := c.RunFaucetStxWithBody(ctx, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRunFaucetStxResponse(rsp)
}


func (c *ClientWithResponses) RunFaucetStxWithResponse(ctx context.Context, params *RunFaucetStxParams, body RunFaucetStxJSONRequestBody, reqEditors... RequestEditorFn) (*RunFaucetStxResponse, error) {
    rsp, err := c.RunFaucetStx(ctx, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRunFaucetStxResponse(rsp)
}





// FetchFeeRateWithBodyWithResponse request with arbitrary body returning *FetchFeeRateResponse
func (c *ClientWithResponses) FetchFeeRateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*FetchFeeRateResponse, error){
    rsp, err := c.FetchFeeRateWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseFetchFeeRateResponse(rsp)
}


func (c *ClientWithResponses) FetchFeeRateWithResponse(ctx context.Context, body FetchFeeRateJSONRequestBody, reqEditors... RequestEditorFn) (*FetchFeeRateResponse, error) {
    rsp, err := c.FetchFeeRate(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseFetchFeeRateResponse(rsp)
}





// GetNetworkBlockTimeByNetworkWithResponse request returning *GetNetworkBlockTimeByNetworkResponse
func (c *ClientWithResponses) GetNetworkBlockTimeByNetworkWithResponse(ctx context.Context, network GetNetworkBlockTimeByNetworkParamsNetwork, reqEditors... RequestEditorFn) (*GetNetworkBlockTimeByNetworkResponse, error){
    rsp, err := c.GetNetworkBlockTimeByNetwork(ctx, network, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNetworkBlockTimeByNetworkResponse(rsp)
}






// GetNetworkBlockTimesWithResponse request returning *GetNetworkBlockTimesResponse
func (c *ClientWithResponses) GetNetworkBlockTimesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetNetworkBlockTimesResponse, error){
    rsp, err := c.GetNetworkBlockTimes(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNetworkBlockTimesResponse(rsp)
}






// GetMicroblockListWithResponse request returning *GetMicroblockListResponse
func (c *ClientWithResponses) GetMicroblockListWithResponse(ctx context.Context, params *GetMicroblockListParams, reqEditors... RequestEditorFn) (*GetMicroblockListResponse, error){
    rsp, err := c.GetMicroblockList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetMicroblockListResponse(rsp)
}






// GetUnanchoredTxsWithResponse request returning *GetUnanchoredTxsResponse
func (c *ClientWithResponses) GetUnanchoredTxsWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetUnanchoredTxsResponse, error){
    rsp, err := c.GetUnanchoredTxs(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetUnanchoredTxsResponse(rsp)
}






// GetMicroblockByHashWithResponse request returning *GetMicroblockByHashResponse
func (c *ClientWithResponses) GetMicroblockByHashWithResponse(ctx context.Context, hash string, reqEditors... RequestEditorFn) (*GetMicroblockByHashResponse, error){
    rsp, err := c.GetMicroblockByHash(ctx, hash, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetMicroblockByHashResponse(rsp)
}






// SearchByIdWithResponse request returning *SearchByIdResponse
func (c *ClientWithResponses) SearchByIdWithResponse(ctx context.Context, id string, params *SearchByIdParams, reqEditors... RequestEditorFn) (*SearchByIdResponse, error){
    rsp, err := c.SearchById(ctx, id, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseSearchByIdResponse(rsp)
}






// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStatusResponse, error){
    rsp, err := c.GetStatus(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetStatusResponse(rsp)
}






// GetStxSupplyWithResponse request returning *GetStxSupplyResponse
func (c *ClientWithResponses) GetStxSupplyWithResponse(ctx context.Context, params *GetStxSupplyParams, reqEditors... RequestEditorFn) (*GetStxSupplyResponse, error){
    rsp, err := c.GetStxSupply(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetStxSupplyResponse(rsp)
}






// GetStxSupplyCirculatingPlainWithResponse request returning *GetStxSupplyCirculatingPlainResponse
func (c *ClientWithResponses) GetStxSupplyCirculatingPlainWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStxSupplyCirculatingPlainResponse, error){
    rsp, err := c.GetStxSupplyCirculatingPlain(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetStxSupplyCirculatingPlainResponse(rsp)
}






// GetTotalStxSupplyLegacyFormatWithResponse request returning *GetTotalStxSupplyLegacyFormatResponse
func (c *ClientWithResponses) GetTotalStxSupplyLegacyFormatWithResponse(ctx context.Context, params *GetTotalStxSupplyLegacyFormatParams, reqEditors... RequestEditorFn) (*GetTotalStxSupplyLegacyFormatResponse, error){
    rsp, err := c.GetTotalStxSupplyLegacyFormat(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTotalStxSupplyLegacyFormatResponse(rsp)
}






// GetStxSupplyTotalSupplyPlainWithResponse request returning *GetStxSupplyTotalSupplyPlainResponse
func (c *ClientWithResponses) GetStxSupplyTotalSupplyPlainWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetStxSupplyTotalSupplyPlainResponse, error){
    rsp, err := c.GetStxSupplyTotalSupplyPlain(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetStxSupplyTotalSupplyPlainResponse(rsp)
}






// GetFtMetadataListWithResponse request returning *GetFtMetadataListResponse
func (c *ClientWithResponses) GetFtMetadataListWithResponse(ctx context.Context, params *GetFtMetadataListParams, reqEditors... RequestEditorFn) (*GetFtMetadataListResponse, error){
    rsp, err := c.GetFtMetadataList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetFtMetadataListResponse(rsp)
}






// GetNftHistoryWithResponse request returning *GetNftHistoryResponse
func (c *ClientWithResponses) GetNftHistoryWithResponse(ctx context.Context, params *GetNftHistoryParams, reqEditors... RequestEditorFn) (*GetNftHistoryResponse, error){
    rsp, err := c.GetNftHistory(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNftHistoryResponse(rsp)
}






// GetNftHoldingsWithResponse request returning *GetNftHoldingsResponse
func (c *ClientWithResponses) GetNftHoldingsWithResponse(ctx context.Context, params *GetNftHoldingsParams, reqEditors... RequestEditorFn) (*GetNftHoldingsResponse, error){
    rsp, err := c.GetNftHoldings(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNftHoldingsResponse(rsp)
}






// GetNftMetadataListWithResponse request returning *GetNftMetadataListResponse
func (c *ClientWithResponses) GetNftMetadataListWithResponse(ctx context.Context, params *GetNftMetadataListParams, reqEditors... RequestEditorFn) (*GetNftMetadataListResponse, error){
    rsp, err := c.GetNftMetadataList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNftMetadataListResponse(rsp)
}






// GetNftMintsWithResponse request returning *GetNftMintsResponse
func (c *ClientWithResponses) GetNftMintsWithResponse(ctx context.Context, params *GetNftMintsParams, reqEditors... RequestEditorFn) (*GetNftMintsResponse, error){
    rsp, err := c.GetNftMints(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNftMintsResponse(rsp)
}






// GetContractFtMetadataWithResponse request returning *GetContractFtMetadataResponse
func (c *ClientWithResponses) GetContractFtMetadataWithResponse(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*GetContractFtMetadataResponse, error){
    rsp, err := c.GetContractFtMetadata(ctx, contractId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractFtMetadataResponse(rsp)
}






// GetContractNftMetadataWithResponse request returning *GetContractNftMetadataResponse
func (c *ClientWithResponses) GetContractNftMetadataWithResponse(ctx context.Context, contractId string, reqEditors... RequestEditorFn) (*GetContractNftMetadataResponse, error){
    rsp, err := c.GetContractNftMetadata(ctx, contractId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractNftMetadataResponse(rsp)
}






// GetTransactionListWithResponse request returning *GetTransactionListResponse
func (c *ClientWithResponses) GetTransactionListWithResponse(ctx context.Context, params *GetTransactionListParams, reqEditors... RequestEditorFn) (*GetTransactionListResponse, error){
    rsp, err := c.GetTransactionList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTransactionListResponse(rsp)
}






// GetTransactionsByBlockHashWithResponse request returning *GetTransactionsByBlockHashResponse
func (c *ClientWithResponses) GetTransactionsByBlockHashWithResponse(ctx context.Context, blockHash string, params *GetTransactionsByBlockHashParams, reqEditors... RequestEditorFn) (*GetTransactionsByBlockHashResponse, error){
    rsp, err := c.GetTransactionsByBlockHash(ctx, blockHash, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTransactionsByBlockHashResponse(rsp)
}






// GetTransactionsByBlockHeightWithResponse request returning *GetTransactionsByBlockHeightResponse
func (c *ClientWithResponses) GetTransactionsByBlockHeightWithResponse(ctx context.Context, height int, params *GetTransactionsByBlockHeightParams, reqEditors... RequestEditorFn) (*GetTransactionsByBlockHeightResponse, error){
    rsp, err := c.GetTransactionsByBlockHeight(ctx, height, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTransactionsByBlockHeightResponse(rsp)
}






// GetFilteredEventsWithResponse request returning *GetFilteredEventsResponse
func (c *ClientWithResponses) GetFilteredEventsWithResponse(ctx context.Context, params *GetFilteredEventsParams, reqEditors... RequestEditorFn) (*GetFilteredEventsResponse, error){
    rsp, err := c.GetFilteredEvents(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetFilteredEventsResponse(rsp)
}






// GetMempoolTransactionListWithResponse request returning *GetMempoolTransactionListResponse
func (c *ClientWithResponses) GetMempoolTransactionListWithResponse(ctx context.Context, params *GetMempoolTransactionListParams, reqEditors... RequestEditorFn) (*GetMempoolTransactionListResponse, error){
    rsp, err := c.GetMempoolTransactionList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetMempoolTransactionListResponse(rsp)
}






// GetDroppedMempoolTransactionListWithResponse request returning *GetDroppedMempoolTransactionListResponse
func (c *ClientWithResponses) GetDroppedMempoolTransactionListWithResponse(ctx context.Context, params *GetDroppedMempoolTransactionListParams, reqEditors... RequestEditorFn) (*GetDroppedMempoolTransactionListResponse, error){
    rsp, err := c.GetDroppedMempoolTransactionList(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetDroppedMempoolTransactionListResponse(rsp)
}






// GetTxListDetailsWithResponse request returning *GetTxListDetailsResponse
func (c *ClientWithResponses) GetTxListDetailsWithResponse(ctx context.Context, params *GetTxListDetailsParams, reqEditors... RequestEditorFn) (*GetTxListDetailsResponse, error){
    rsp, err := c.GetTxListDetails(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTxListDetailsResponse(rsp)
}






// GetTransactionByIdWithResponse request returning *GetTransactionByIdResponse
func (c *ClientWithResponses) GetTransactionByIdWithResponse(ctx context.Context, txId string, params *GetTransactionByIdParams, reqEditors... RequestEditorFn) (*GetTransactionByIdResponse, error){
    rsp, err := c.GetTransactionById(ctx, txId, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTransactionByIdResponse(rsp)
}






// GetRawTransactionByIdWithResponse request returning *GetRawTransactionByIdResponse
func (c *ClientWithResponses) GetRawTransactionByIdWithResponse(ctx context.Context, txId string, reqEditors... RequestEditorFn) (*GetRawTransactionByIdResponse, error){
    rsp, err := c.GetRawTransactionById(ctx, txId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetRawTransactionByIdResponse(rsp)
}






// RosettaAccountBalanceWithBodyWithResponse request with arbitrary body returning *RosettaAccountBalanceResponse
func (c *ClientWithResponses) RosettaAccountBalanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaAccountBalanceResponse, error){
    rsp, err := c.RosettaAccountBalanceWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaAccountBalanceResponse(rsp)
}


func (c *ClientWithResponses) RosettaAccountBalanceWithResponse(ctx context.Context, body RosettaAccountBalanceJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaAccountBalanceResponse, error) {
    rsp, err := c.RosettaAccountBalance(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaAccountBalanceResponse(rsp)
}





// RosettaBlockWithBodyWithResponse request with arbitrary body returning *RosettaBlockResponse
func (c *ClientWithResponses) RosettaBlockWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaBlockResponse, error){
    rsp, err := c.RosettaBlockWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaBlockResponse(rsp)
}


func (c *ClientWithResponses) RosettaBlockWithResponse(ctx context.Context, body RosettaBlockJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaBlockResponse, error) {
    rsp, err := c.RosettaBlock(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaBlockResponse(rsp)
}





// RosettaBlockTransactionWithBodyWithResponse request with arbitrary body returning *RosettaBlockTransactionResponse
func (c *ClientWithResponses) RosettaBlockTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaBlockTransactionResponse, error){
    rsp, err := c.RosettaBlockTransactionWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaBlockTransactionResponse(rsp)
}


func (c *ClientWithResponses) RosettaBlockTransactionWithResponse(ctx context.Context, body RosettaBlockTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaBlockTransactionResponse, error) {
    rsp, err := c.RosettaBlockTransaction(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaBlockTransactionResponse(rsp)
}





// RosettaConstructionCombineWithBodyWithResponse request with arbitrary body returning *RosettaConstructionCombineResponse
func (c *ClientWithResponses) RosettaConstructionCombineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionCombineResponse, error){
    rsp, err := c.RosettaConstructionCombineWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionCombineResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionCombineWithResponse(ctx context.Context, body RosettaConstructionCombineJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionCombineResponse, error) {
    rsp, err := c.RosettaConstructionCombine(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionCombineResponse(rsp)
}





// RosettaConstructionDeriveWithBodyWithResponse request with arbitrary body returning *RosettaConstructionDeriveResponse
func (c *ClientWithResponses) RosettaConstructionDeriveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionDeriveResponse, error){
    rsp, err := c.RosettaConstructionDeriveWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionDeriveResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionDeriveWithResponse(ctx context.Context, body RosettaConstructionDeriveJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionDeriveResponse, error) {
    rsp, err := c.RosettaConstructionDerive(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionDeriveResponse(rsp)
}





// RosettaConstructionHashWithBodyWithResponse request with arbitrary body returning *RosettaConstructionHashResponse
func (c *ClientWithResponses) RosettaConstructionHashWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionHashResponse, error){
    rsp, err := c.RosettaConstructionHashWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionHashResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionHashWithResponse(ctx context.Context, body RosettaConstructionHashJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionHashResponse, error) {
    rsp, err := c.RosettaConstructionHash(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionHashResponse(rsp)
}





// RosettaConstructionMetadataWithBodyWithResponse request with arbitrary body returning *RosettaConstructionMetadataResponse
func (c *ClientWithResponses) RosettaConstructionMetadataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionMetadataResponse, error){
    rsp, err := c.RosettaConstructionMetadataWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionMetadataResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionMetadataWithResponse(ctx context.Context, body RosettaConstructionMetadataJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionMetadataResponse, error) {
    rsp, err := c.RosettaConstructionMetadata(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionMetadataResponse(rsp)
}





// RosettaConstructionParseWithBodyWithResponse request with arbitrary body returning *RosettaConstructionParseResponse
func (c *ClientWithResponses) RosettaConstructionParseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionParseResponse, error){
    rsp, err := c.RosettaConstructionParseWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionParseResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionParseWithResponse(ctx context.Context, body RosettaConstructionParseJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionParseResponse, error) {
    rsp, err := c.RosettaConstructionParse(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionParseResponse(rsp)
}





// RosettaConstructionPayloadsWithBodyWithResponse request with arbitrary body returning *RosettaConstructionPayloadsResponse
func (c *ClientWithResponses) RosettaConstructionPayloadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionPayloadsResponse, error){
    rsp, err := c.RosettaConstructionPayloadsWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionPayloadsResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionPayloadsWithResponse(ctx context.Context, body RosettaConstructionPayloadsJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionPayloadsResponse, error) {
    rsp, err := c.RosettaConstructionPayloads(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionPayloadsResponse(rsp)
}





// RosettaConstructionPreprocessWithBodyWithResponse request with arbitrary body returning *RosettaConstructionPreprocessResponse
func (c *ClientWithResponses) RosettaConstructionPreprocessWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionPreprocessResponse, error){
    rsp, err := c.RosettaConstructionPreprocessWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionPreprocessResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionPreprocessWithResponse(ctx context.Context, body RosettaConstructionPreprocessJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionPreprocessResponse, error) {
    rsp, err := c.RosettaConstructionPreprocess(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionPreprocessResponse(rsp)
}





// RosettaConstructionSubmitWithBodyWithResponse request with arbitrary body returning *RosettaConstructionSubmitResponse
func (c *ClientWithResponses) RosettaConstructionSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaConstructionSubmitResponse, error){
    rsp, err := c.RosettaConstructionSubmitWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionSubmitResponse(rsp)
}


func (c *ClientWithResponses) RosettaConstructionSubmitWithResponse(ctx context.Context, body RosettaConstructionSubmitJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaConstructionSubmitResponse, error) {
    rsp, err := c.RosettaConstructionSubmit(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaConstructionSubmitResponse(rsp)
}





// RosettaMempoolWithBodyWithResponse request with arbitrary body returning *RosettaMempoolResponse
func (c *ClientWithResponses) RosettaMempoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaMempoolResponse, error){
    rsp, err := c.RosettaMempoolWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaMempoolResponse(rsp)
}


func (c *ClientWithResponses) RosettaMempoolWithResponse(ctx context.Context, body RosettaMempoolJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaMempoolResponse, error) {
    rsp, err := c.RosettaMempool(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaMempoolResponse(rsp)
}





// RosettaMempoolTransactionWithBodyWithResponse request with arbitrary body returning *RosettaMempoolTransactionResponse
func (c *ClientWithResponses) RosettaMempoolTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaMempoolTransactionResponse, error){
    rsp, err := c.RosettaMempoolTransactionWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaMempoolTransactionResponse(rsp)
}


func (c *ClientWithResponses) RosettaMempoolTransactionWithResponse(ctx context.Context, body RosettaMempoolTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaMempoolTransactionResponse, error) {
    rsp, err := c.RosettaMempoolTransaction(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaMempoolTransactionResponse(rsp)
}





// RosettaNetworkListWithResponse request returning *RosettaNetworkListResponse
func (c *ClientWithResponses) RosettaNetworkListWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*RosettaNetworkListResponse, error){
    rsp, err := c.RosettaNetworkList(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaNetworkListResponse(rsp)
}






// RosettaNetworkOptionsWithBodyWithResponse request with arbitrary body returning *RosettaNetworkOptionsResponse
func (c *ClientWithResponses) RosettaNetworkOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaNetworkOptionsResponse, error){
    rsp, err := c.RosettaNetworkOptionsWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaNetworkOptionsResponse(rsp)
}


func (c *ClientWithResponses) RosettaNetworkOptionsWithResponse(ctx context.Context, body RosettaNetworkOptionsJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaNetworkOptionsResponse, error) {
    rsp, err := c.RosettaNetworkOptions(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaNetworkOptionsResponse(rsp)
}





// RosettaNetworkStatusWithBodyWithResponse request with arbitrary body returning *RosettaNetworkStatusResponse
func (c *ClientWithResponses) RosettaNetworkStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*RosettaNetworkStatusResponse, error){
    rsp, err := c.RosettaNetworkStatusWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaNetworkStatusResponse(rsp)
}


func (c *ClientWithResponses) RosettaNetworkStatusWithResponse(ctx context.Context, body RosettaNetworkStatusJSONRequestBody, reqEditors... RequestEditorFn) (*RosettaNetworkStatusResponse, error) {
    rsp, err := c.RosettaNetworkStatus(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseRosettaNetworkStatusResponse(rsp)
}





// GetNamesOwnedByAddressWithResponse request returning *GetNamesOwnedByAddressResponse
func (c *ClientWithResponses) GetNamesOwnedByAddressWithResponse(ctx context.Context, blockchain string, address string, reqEditors... RequestEditorFn) (*GetNamesOwnedByAddressResponse, error){
    rsp, err := c.GetNamesOwnedByAddress(ctx, blockchain, address, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNamesOwnedByAddressResponse(rsp)
}






// GetAllNamesWithResponse request returning *GetAllNamesResponse
func (c *ClientWithResponses) GetAllNamesWithResponse(ctx context.Context, params *GetAllNamesParams, reqEditors... RequestEditorFn) (*GetAllNamesResponse, error){
    rsp, err := c.GetAllNames(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAllNamesResponse(rsp)
}






// GetNameInfoWithResponse request returning *GetNameInfoResponse
func (c *ClientWithResponses) GetNameInfoWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*GetNameInfoResponse, error){
    rsp, err := c.GetNameInfo(ctx, name, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNameInfoResponse(rsp)
}






// FetchSubdomainsListForNameWithResponse request returning *FetchSubdomainsListForNameResponse
func (c *ClientWithResponses) FetchSubdomainsListForNameWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*FetchSubdomainsListForNameResponse, error){
    rsp, err := c.FetchSubdomainsListForName(ctx, name, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseFetchSubdomainsListForNameResponse(rsp)
}






// FetchZoneFileWithResponse request returning *FetchZoneFileResponse
func (c *ClientWithResponses) FetchZoneFileWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*FetchZoneFileResponse, error){
    rsp, err := c.FetchZoneFile(ctx, name, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseFetchZoneFileResponse(rsp)
}






// GetHistoricalZoneFileWithResponse request returning *GetHistoricalZoneFileResponse
func (c *ClientWithResponses) GetHistoricalZoneFileWithResponse(ctx context.Context, name string, zoneFileHash string, reqEditors... RequestEditorFn) (*GetHistoricalZoneFileResponse, error){
    rsp, err := c.GetHistoricalZoneFile(ctx, name, zoneFileHash, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetHistoricalZoneFileResponse(rsp)
}






// GetAllNamespacesWithResponse request returning *GetAllNamespacesResponse
func (c *ClientWithResponses) GetAllNamespacesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetAllNamespacesResponse, error){
    rsp, err := c.GetAllNamespaces(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAllNamespacesResponse(rsp)
}






// GetNamespaceNamesWithResponse request returning *GetNamespaceNamesResponse
func (c *ClientWithResponses) GetNamespaceNamesWithResponse(ctx context.Context, tld string, params *GetNamespaceNamesParams, reqEditors... RequestEditorFn) (*GetNamespaceNamesResponse, error){
    rsp, err := c.GetNamespaceNames(ctx, tld, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNamespaceNamesResponse(rsp)
}






// GetAccountInfoWithResponse request returning *GetAccountInfoResponse
func (c *ClientWithResponses) GetAccountInfoWithResponse(ctx context.Context, principal string, params *GetAccountInfoParams, reqEditors... RequestEditorFn) (*GetAccountInfoResponse, error){
    rsp, err := c.GetAccountInfo(ctx, principal, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetAccountInfoResponse(rsp)
}






// CallReadOnlyFunctionWithBodyWithResponse request with arbitrary body returning *CallReadOnlyFunctionResponse
func (c *ClientWithResponses) CallReadOnlyFunctionWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*CallReadOnlyFunctionResponse, error){
    rsp, err := c.CallReadOnlyFunctionWithBody(ctx, contractAddress, contractName, functionName, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseCallReadOnlyFunctionResponse(rsp)
}


func (c *ClientWithResponses) CallReadOnlyFunctionWithResponse(ctx context.Context, contractAddress string, contractName string, functionName string, params *CallReadOnlyFunctionParams, body CallReadOnlyFunctionJSONRequestBody, reqEditors... RequestEditorFn) (*CallReadOnlyFunctionResponse, error) {
    rsp, err := c.CallReadOnlyFunction(ctx, contractAddress, contractName, functionName, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseCallReadOnlyFunctionResponse(rsp)
}





// GetContractInterfaceWithResponse request returning *GetContractInterfaceResponse
func (c *ClientWithResponses) GetContractInterfaceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractInterfaceParams, reqEditors... RequestEditorFn) (*GetContractInterfaceResponse, error){
    rsp, err := c.GetContractInterface(ctx, contractAddress, contractName, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractInterfaceResponse(rsp)
}






// GetContractSourceWithResponse request returning *GetContractSourceResponse
func (c *ClientWithResponses) GetContractSourceWithResponse(ctx context.Context, contractAddress string, contractName string, params *GetContractSourceParams, reqEditors... RequestEditorFn) (*GetContractSourceResponse, error){
    rsp, err := c.GetContractSource(ctx, contractAddress, contractName, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractSourceResponse(rsp)
}






// PostFeeTransactionWithBodyWithResponse request with arbitrary body returning *PostFeeTransactionResponse
func (c *ClientWithResponses) PostFeeTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostFeeTransactionResponse, error){
    rsp, err := c.PostFeeTransactionWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostFeeTransactionResponse(rsp)
}


func (c *ClientWithResponses) PostFeeTransactionWithResponse(ctx context.Context, body PostFeeTransactionJSONRequestBody, reqEditors... RequestEditorFn) (*PostFeeTransactionResponse, error) {
    rsp, err := c.PostFeeTransaction(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostFeeTransactionResponse(rsp)
}





// GetFeeTransferWithResponse request returning *GetFeeTransferResponse
func (c *ClientWithResponses) GetFeeTransferWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetFeeTransferResponse, error){
    rsp, err := c.GetFeeTransfer(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetFeeTransferResponse(rsp)
}






// GetCoreApiInfoWithResponse request returning *GetCoreApiInfoResponse
func (c *ClientWithResponses) GetCoreApiInfoWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetCoreApiInfoResponse, error){
    rsp, err := c.GetCoreApiInfo(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetCoreApiInfoResponse(rsp)
}






// GetContractDataMapEntryWithBodyWithResponse request with arbitrary body returning *GetContractDataMapEntryResponse
func (c *ClientWithResponses) GetContractDataMapEntryWithBodyWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*GetContractDataMapEntryResponse, error){
    rsp, err := c.GetContractDataMapEntryWithBody(ctx, contractAddress, contractName, mapName, params, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractDataMapEntryResponse(rsp)
}


func (c *ClientWithResponses) GetContractDataMapEntryWithResponse(ctx context.Context, contractAddress string, contractName string, mapName string, params *GetContractDataMapEntryParams, body GetContractDataMapEntryJSONRequestBody, reqEditors... RequestEditorFn) (*GetContractDataMapEntryResponse, error) {
    rsp, err := c.GetContractDataMapEntry(ctx, contractAddress, contractName, mapName, params, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetContractDataMapEntryResponse(rsp)
}





// GetPoxInfoWithResponse request returning *GetPoxInfoResponse
func (c *ClientWithResponses) GetPoxInfoWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetPoxInfoResponse, error){
    rsp, err := c.GetPoxInfo(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetPoxInfoResponse(rsp)
}






// GetNamePriceWithResponse request returning *GetNamePriceResponse
func (c *ClientWithResponses) GetNamePriceWithResponse(ctx context.Context, name string, reqEditors... RequestEditorFn) (*GetNamePriceResponse, error){
    rsp, err := c.GetNamePrice(ctx, name, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNamePriceResponse(rsp)
}






// GetNamespacePriceWithResponse request returning *GetNamespacePriceResponse
func (c *ClientWithResponses) GetNamespacePriceWithResponse(ctx context.Context, tld string, reqEditors... RequestEditorFn) (*GetNamespacePriceResponse, error){
    rsp, err := c.GetNamespacePrice(ctx, tld, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetNamespacePriceResponse(rsp)
}






// PostCoreNodeTransactionsWithBodyWithResponse request with arbitrary body returning *PostCoreNodeTransactionsResponse
func (c *ClientWithResponses) PostCoreNodeTransactionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostCoreNodeTransactionsResponse, error){
    rsp, err := c.PostCoreNodeTransactionsWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostCoreNodeTransactionsResponse(rsp)
}








// ParseGetAddressMempoolTransactionsResponse parses an HTTP response from a GetAddressMempoolTransactionsWithResponse call
func ParseGetAddressMempoolTransactionsResponse(rsp *http.Response) (*GetAddressMempoolTransactionsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAddressMempoolTransactionsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountAssetsResponse parses an HTTP response from a GetAccountAssetsWithResponse call
func ParseGetAccountAssetsResponse(rsp *http.Response) (*GetAccountAssetsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountAssetsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountBalanceResponse parses an HTTP response from a GetAccountBalanceWithResponse call
func ParseGetAccountBalanceResponse(rsp *http.Response) (*GetAccountBalanceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountBalanceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    FungibleTokens 200_FungibleTokens`json:"fungible_tokens"`
    NonFungibleTokens 200_NonFungibleTokens`json:"non_fungible_tokens"`
    Stx struct {
    Balance string`json:"balance"`

// The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
    BurnchainLockHeight int`json:"burnchain_lock_height"`

// The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
    BurnchainUnlockHeight int`json:"burnchain_unlock_height"`

// The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
    LockHeight int`json:"lock_height"`

// The transaction where the lock event occurred. Empty if no tokens are locked.
    LockTxId string`json:"lock_tx_id"`

// The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
    Locked string`json:"locked"`
    TotalFeesSent string`json:"total_fees_sent"`
    TotalMinerRewardsReceived string`json:"total_miner_rewards_received"`
    TotalReceived string`json:"total_received"`
    TotalSent string`json:"total_sent"`
}`json:"stx"`

// Token Offering Locked
    TokenOfferingLocked *struct {
// Micro-STX amount still locked at current block height.
    TotalLocked string`json:"total_locked"`

// Micro-STX amount unlocked at current block height.
    TotalUnlocked string`json:"total_unlocked"`
    UnlockSchedule []struct {
// Micro-STX amount locked at this block height.
    Amount string`json:"amount"`
    BlockHeight float32`json:"block_height"`
}`json:"unlock_schedule"`
}`json:"token_offering_locked,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountNftResponse parses an HTTP response from a GetAccountNftWithResponse call
func ParseGetAccountNftResponse(rsp *http.Response) (*GetAccountNftResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountNftResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    NftEvents []struct {
    AssetIdentifier string`json:"asset_identifier"`
    BlockHeight float32`json:"block_height"`
    Recipient string`json:"recipient"`
    Sender string`json:"sender"`
    TxId string`json:"tx_id"`

// Identifier of the NFT
    Value struct {
// Hex string representing the identifier of the NFT
    Hex string`json:"hex"`

// Readable string of the NFT identifier
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_events"`
    Offset int`json:"offset"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountNoncesResponse parses an HTTP response from a GetAccountNoncesWithResponse call
func ParseGetAccountNoncesResponse(rsp *http.Response) (*GetAccountNoncesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountNoncesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Nonces that appear to be missing and likely causing a mempool transaction to be stuck.
    DetectedMissingNonces []int`json:"detected_missing_nonces"`

// The latest nonce found within transactions sent by this address, including unanchored microblock transactions. Will be null if there are no current transactions for this address.
    LastExecutedTxNonce *int`json:"last_executed_tx_nonce"`

// The latest nonce found within mempool transactions sent by this address. Will be null if there are no current mempool transactions for this address.
    LastMempoolTxNonce *int`json:"last_mempool_tx_nonce"`

// The likely nonce required for creating the next transaction, based on the last nonces seen by the API. This can be incorrect if the API's mempool or transactions aren't fully synchronized, even by a small amount, or if a previous transaction is still propagating through the Stacks blockchain network when this endpoint is called.
    PossibleNextNonce int`json:"possible_next_nonce"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountStxBalanceResponse parses an HTTP response from a GetAccountStxBalanceWithResponse call
func ParseGetAccountStxBalanceResponse(rsp *http.Response) (*GetAccountStxBalanceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountStxBalanceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Balance string`json:"balance"`

// The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
    BurnchainLockHeight int`json:"burnchain_lock_height"`

// The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
    BurnchainUnlockHeight int`json:"burnchain_unlock_height"`

// The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
    LockHeight int`json:"lock_height"`

// The transaction where the lock event occurred. Empty if no tokens are locked.
    LockTxId string`json:"lock_tx_id"`

// The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
    Locked string`json:"locked"`

// Token Offering Locked
    TokenOfferingLocked *struct {
// Micro-STX amount still locked at current block height.
    TotalLocked string`json:"total_locked"`

// Micro-STX amount unlocked at current block height.
    TotalUnlocked string`json:"total_unlocked"`
    UnlockSchedule []struct {
// Micro-STX amount locked at this block height.
    Amount string`json:"amount"`
    BlockHeight float32`json:"block_height"`
}`json:"unlock_schedule"`
}`json:"token_offering_locked,omitempty"`
    TotalFeesSent string`json:"total_fees_sent"`
    TotalMinerRewardsReceived string`json:"total_miner_rewards_received"`
    TotalReceived string`json:"total_received"`
    TotalSent string`json:"total_sent"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountInboundResponse parses an HTTP response from a GetAccountInboundWithResponse call
func ParseGetAccountInboundResponse(rsp *http.Response) (*GetAccountInboundResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountInboundResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []struct {
// Transfer amount in micro-STX as integer string
    Amount string`json:"amount"`

// Block height at which this transfer occurred
    BlockHeight float32`json:"block_height"`

// Hex encoded memo bytes associated with the transfer
    Memo string`json:"memo"`

// Principal that sent this transfer
    Sender string`json:"sender"`

// Indicates if the transfer is from a stx-transfer transaction or a contract-call transaction
    TransferType N200ResultsTransferType`json:"transfer_type"`

// The transaction ID in which this transfer occurred
    TxId string`json:"tx_id"`

// Index of the transaction within a block
    TxIndex float32`json:"tx_index"`
}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountTransactionsResponse parses an HTTP response from a GetAccountTransactionsWithResponse call
func ParseGetAccountTransactionsResponse(rsp *http.Response) (*GetAccountTransactionsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountTransactionsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetAccountTransactionsWithTransfersResponse parses an HTTP response from a GetAccountTransactionsWithTransfersWithResponse call
func ParseGetAccountTransactionsWithTransfersResponse(rsp *http.Response) (*GetAccountTransactionsWithTransfersResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountTransactionsWithTransfersResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []struct {
    FtTransfers *[]struct {
// Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
    Amount string`json:"amount"`

// Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`
}`json:"ft_transfers,omitempty"`
    NftTransfers *[]struct {
// Non Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`

// Non Fungible Token asset value.
    Value struct {
    Hex string`json:"hex"`
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_transfers,omitempty"`

// Total received by the given address in micro-STX as an integer string.
    StxReceived string`json:"stx_received"`

// Total sent from the given address, including the tx fee, in micro-STX as an integer string.
    StxSent string`json:"stx_sent"`
    StxTransfers []struct {
// Amount transferred in micro-STX as an integer string.
    Amount string`json:"amount"`

// Principal that received STX. This is unspecified if the STX were burned.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent STX. This is unspecified if the STX were minted.
    Sender *string`json:"sender,omitempty"`
}`json:"stx_transfers"`

// Describes all transaction types on Stacks 2.0 blockchain
    Tx interface{}`json:"tx"`
}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetSingleTransactionWithTransfersResponse parses an HTTP response from a GetSingleTransactionWithTransfersWithResponse call
func ParseGetSingleTransactionWithTransfersResponse(rsp *http.Response) (*GetSingleTransactionWithTransfersResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetSingleTransactionWithTransfersResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    FtTransfers *[]struct {
// Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
    Amount string`json:"amount"`

// Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`
}`json:"ft_transfers,omitempty"`
    NftTransfers *[]struct {
// Non Fungible Token asset identifier.
    AssetIdentifier string`json:"asset_identifier"`

// Principal that received the asset.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent the asset.
    Sender *string`json:"sender,omitempty"`

// Non Fungible Token asset value.
    Value struct {
    Hex string`json:"hex"`
    Repr string`json:"repr"`
}`json:"value"`
}`json:"nft_transfers,omitempty"`

// Total received by the given address in micro-STX as an integer string.
    StxReceived string`json:"stx_received"`

// Total sent from the given address, including the tx fee, in micro-STX as an integer string.
    StxSent string`json:"stx_sent"`
    StxTransfers []struct {
// Amount transferred in micro-STX as an integer string.
    Amount string`json:"amount"`

// Principal that received STX. This is unspecified if the STX were burned.
    Recipient *string`json:"recipient,omitempty"`

// Principal that sent STX. This is unspecified if the STX were minted.
    Sender *string`json:"sender,omitempty"`
}`json:"stx_transfers"`

// Describes all transaction types on Stacks 2.0 blockchain
    Tx interface{}`json:"tx"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBlockListResponse parses an HTTP response from a GetBlockListWithResponse call
func ParseGetBlockListResponse(rsp *http.Response) (*GetBlockListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBlockListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of blocks to return
    Limit int`json:"limit"`

// The number to blocks to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}`json:"results"`

// The number of blocks available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBlockByBurnBlockHashResponse parses an HTTP response from a GetBlockByBurnBlockHashWithResponse call
func ParseGetBlockByBurnBlockHashResponse(rsp *http.Response) (*GetBlockByBurnBlockHashResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBlockByBurnBlockHashResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBlockByBurnBlockHeightResponse parses an HTTP response from a GetBlockByBurnBlockHeightWithResponse call
func ParseGetBlockByBurnBlockHeightResponse(rsp *http.Response) (*GetBlockByBurnBlockHeightResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBlockByBurnBlockHeightResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBlockByHeightResponse parses an HTTP response from a GetBlockByHeightWithResponse call
func ParseGetBlockByHeightResponse(rsp *http.Response) (*GetBlockByHeightResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBlockByHeightResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBlockByHashResponse parses an HTTP response from a GetBlockByHashWithResponse call
func ParseGetBlockByHashResponse(rsp *http.Response) (*GetBlockByHashResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBlockByHashResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Hash of the anchor chain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the anchor chain block
    BurnBlockHeight int`json:"burn_block_height"`

// Unix timestamp (in seconds) indicating when this block was mined.
    BurnBlockTime float32`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Hash representing the block
    Hash string`json:"hash"`

// Height of the block
    Height int`json:"height"`

// List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
    MicroblocksAccepted []string`json:"microblocks_accepted"`

// List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
    MicroblocksStreamed []string`json:"microblocks_streamed"`

// Anchor chain transaction ID
    MinerTxid string`json:"miner_txid"`

// Hash of the parent block
    ParentBlockHash string`json:"parent_block_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockHash string`json:"parent_microblock_hash"`

// The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
    ParentMicroblockSequence int`json:"parent_microblock_sequence"`

// List of transactions included in the block
    Txs []string`json:"txs"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBurnchainRewardSlotHoldersResponse parses an HTTP response from a GetBurnchainRewardSlotHoldersWithResponse call
func ParseGetBurnchainRewardSlotHoldersResponse(rsp *http.Response) (*GetBurnchainRewardSlotHoldersResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBurnchainRewardSlotHoldersResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of items to return
    Limit int`json:"limit"`

// The number of items to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    Address string`json:"address"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
    SlotIndex int`json:"slot_index"`
}`json:"results"`

// Total number of available items
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBurnchainRewardSlotHoldersByAddressResponse parses an HTTP response from a GetBurnchainRewardSlotHoldersByAddressWithResponse call
func ParseGetBurnchainRewardSlotHoldersByAddressResponse(rsp *http.Response) (*GetBurnchainRewardSlotHoldersByAddressResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBurnchainRewardSlotHoldersByAddressResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of items to return
    Limit int`json:"limit"`

// The number of items to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    Address string`json:"address"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
    SlotIndex int`json:"slot_index"`
}`json:"results"`

// Total number of available items
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBurnchainRewardListResponse parses an HTTP response from a GetBurnchainRewardListWithResponse call
func ParseGetBurnchainRewardListResponse(rsp *http.Response) (*GetBurnchainRewardListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBurnchainRewardListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of burnchain rewards to return
    Limit int`json:"limit"`

// The number to burnchain rewards to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
    BurnAmount string`json:"burn_amount"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
    RewardIndex int`json:"reward_index"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}`json:"results"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBurnchainRewardListByAddressResponse parses an HTTP response from a GetBurnchainRewardListByAddressWithResponse call
func ParseGetBurnchainRewardListByAddressResponse(rsp *http.Response) (*GetBurnchainRewardListByAddressResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBurnchainRewardListByAddressResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of burnchain rewards to return
    Limit int`json:"limit"`

// The number to burnchain rewards to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
    BurnAmount string`json:"burn_amount"`

// The hash representing the burnchain block
    BurnBlockHash string`json:"burn_block_hash"`

// Height of the burnchain block
    BurnBlockHeight int`json:"burn_block_height"`

// Set to `true` if block corresponds to the canonical burchchain tip
    Canonical bool`json:"canonical"`

// The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
    RewardIndex int`json:"reward_index"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}`json:"results"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetBurnchainRewardsTotalByAddressResponse parses an HTTP response from a GetBurnchainRewardsTotalByAddressWithResponse call
func ParseGetBurnchainRewardsTotalByAddressResponse(rsp *http.Response) (*GetBurnchainRewardsTotalByAddressResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetBurnchainRewardsTotalByAddressResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The total amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
    RewardAmount string`json:"reward_amount"`

// The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
    RewardRecipient string`json:"reward_recipient"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractsByTraitResponse parses an HTTP response from a GetContractsByTraitWithResponse call
func ParseGetContractsByTraitResponse(rsp *http.Response) (*GetContractsByTraitResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractsByTraitResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of contracts to return
    Limit int`json:"limit"`

// The number to contracts to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
    Abi string`json:"abi"`
    BlockHeight int`json:"block_height"`
    Canonical bool`json:"canonical"`
    SourceCode string`json:"source_code"`
    TxId string`json:"tx_id"`
}`json:"results"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractByIdResponse parses an HTTP response from a GetContractByIdWithResponse call
func ParseGetContractByIdResponse(rsp *http.Response) (*GetContractByIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractByIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
    AnchorMode N200AnchorMode`json:"anchor_mode"`

// Hash of the blocked this transactions was associated with
    BlockHash string`json:"block_hash"`

// Height of the block this transactions was associated with
    BlockHeight int`json:"block_height"`

// Unix timestamp (in seconds) indicating when this block was mined
    BurnBlockTime int`json:"burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
    BurnBlockTimeIso string`json:"burn_block_time_iso"`

// Set to `true` if block corresponds to the canonical chain tip
    Canonical bool`json:"canonical"`

// Number of transaction events
    EventCount int`json:"event_count"`

// List of transaction events
    Events []interface{}`json:"events"`

// Execution cost read count.
    ExecutionCostReadCount int`json:"execution_cost_read_count"`

// Execution cost read length.
    ExecutionCostReadLength int`json:"execution_cost_read_length"`

// Execution cost runtime.
    ExecutionCostRuntime int`json:"execution_cost_runtime"`

// Execution cost write count.
    ExecutionCostWriteCount int`json:"execution_cost_write_count"`

// Execution cost write length.
    ExecutionCostWriteLength int`json:"execution_cost_write_length"`

// Transaction fee as Integer string (64-bit unsigned integer).
    FeeRate string`json:"fee_rate"`

// True if the transaction is included in a microblock that has not been confirmed by an anchor block.
    IsUnanchored bool`json:"is_unanchored"`

// Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
    MicroblockHash string`json:"microblock_hash"`

// The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
    MicroblockSequence int`json:"microblock_sequence"`

// Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
    Nonce int`json:"nonce"`

// Hash of the previous block.
    ParentBlockHash string`json:"parent_block_hash"`

// Unix timestamp (in seconds) indicating when this parent block was mined
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`
    PostConditionMode N200PostConditionMode`json:"post_condition_mode"`
    PostConditions []interface{}`json:"post_conditions"`

// Address of the transaction initiator
    SenderAddress string`json:"sender_address"`
    SmartContract struct {
// Contract identifier formatted as `<principaladdress>.<contract_name>`
    ContractId string`json:"contract_id"`

// Clarity code of the smart contract being deployed
    SourceCode string`json:"source_code"`
}`json:"smart_contract"`
    SponsorAddress *string`json:"sponsor_address,omitempty"`
    SponsorNonce *int`json:"sponsor_nonce,omitempty"`

// Denotes whether the originating account is the same as the paying account
    Sponsored bool`json:"sponsored"`

// Transaction ID
    TxId string`json:"tx_id"`

// Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
    TxIndex int`json:"tx_index"`

// Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
    TxResult struct {
// Hex string representing the value fo the transaction result
    Hex string`json:"hex"`

// Readable string of the transaction result
    Repr string`json:"repr"`
}`json:"tx_result"`

// Status of the transaction
    TxStatus N200TxStatus`json:"tx_status"`
    TxType N200TxType`json:"tx_type"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractEventsByIdResponse parses an HTTP response from a GetContractEventsByIdWithResponse call
func ParseGetContractEventsByIdResponse(rsp *http.Response) (*GetContractEventsByIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractEventsByIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest interface{}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseRunFaucetBtcResponse parses an HTTP response from a RunFaucetBtcWithResponse call
func ParseRunFaucetBtcResponse(rsp *http.Response) (*RunFaucetBtcResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RunFaucetBtcResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Indicates if the faucet call was successful
    Success bool`json:"success"`

// The transaction ID for the faucet call
    TxId *string`json:"txId,omitempty"`

// Raw transaction in hex string representation
    TxRaw *string`json:"txRaw,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseRunFaucetStxResponse parses an HTTP response from a RunFaucetStxWithResponse call
func ParseRunFaucetStxResponse(rsp *http.Response) (*RunFaucetStxResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RunFaucetStxResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Indicates if the faucet call was successful
    Success bool`json:"success"`

// The transaction ID for the faucet call
    TxId *string`json:"txId,omitempty"`

// Raw transaction in hex string representation
    TxRaw *string`json:"txRaw,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseFetchFeeRateResponse parses an HTTP response from a FetchFeeRateWithResponse call
func ParseFetchFeeRateResponse(rsp *http.Response) (*FetchFeeRateResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &FetchFeeRateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    FeeRate int`json:"fee_rate"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNetworkBlockTimeByNetworkResponse parses an HTTP response from a GetNetworkBlockTimeByNetworkWithResponse call
func ParseGetNetworkBlockTimeByNetworkResponse(rsp *http.Response) (*GetNetworkBlockTimeByNetworkResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNetworkBlockTimeByNetworkResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    TargetBlockTime int`json:"target_block_time"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNetworkBlockTimesResponse parses an HTTP response from a GetNetworkBlockTimesWithResponse call
func ParseGetNetworkBlockTimesResponse(rsp *http.Response) (*GetNetworkBlockTimesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNetworkBlockTimesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Mainnet struct {
    TargetBlockTime int`json:"target_block_time"`
}`json:"mainnet"`
    Testnet struct {
    TargetBlockTime int`json:"target_block_time"`
}`json:"testnet"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetMicroblockListResponse parses an HTTP response from a GetMicroblockListWithResponse call
func ParseGetMicroblockListResponse(rsp *http.Response) (*GetMicroblockListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetMicroblockListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of microblocks to return
    Limit int`json:"limit"`

// The number to microblocks to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
    BlockHash *string`json:"block_hash"`

// The anchor block height that confirmed this microblock.
    BlockHeight int`json:"block_height"`

// Set to `true` if the microblock corresponds to the canonical chain tip.
    Canonical bool`json:"canonical"`

// Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The SHA512/256 hash of this microblock.
    MicroblockHash string`json:"microblock_hash"`

// The SHA512/256 hash of the previous signed microblock in this stream.
    MicroblockParentHash string`json:"microblock_parent_hash"`

// A hint to describe how to order a set of microblocks. Starts at 0.
    MicroblockSequence int`json:"microblock_sequence"`

// The hash of the anchor block that preceded this microblock.
    ParentBlockHash string`json:"parent_block_hash"`

// The height of the anchor block that preceded this microblock.
    ParentBlockHeight int`json:"parent_block_height"`

// The hash of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHash string`json:"parent_burn_block_hash"`

// The height of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHeight int`json:"parent_burn_block_height"`

// The block timestamp of the Bitcoin block that preceded this microblock.
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`

// List of transactions included in the microblock
    Txs []string`json:"txs"`
}`json:"results"`

// The number of microblocks available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetUnanchoredTxsResponse parses an HTTP response from a GetUnanchoredTxsWithResponse call
func ParseGetUnanchoredTxsResponse(rsp *http.Response) (*GetUnanchoredTxsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetUnanchoredTxsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Results []interface{}`json:"results"`

// The number of unanchored transactions available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetMicroblockByHashResponse parses an HTTP response from a GetMicroblockByHashWithResponse call
func ParseGetMicroblockByHashResponse(rsp *http.Response) (*GetMicroblockByHashResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetMicroblockByHashResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
    BlockHash *string`json:"block_hash"`

// The anchor block height that confirmed this microblock.
    BlockHeight int`json:"block_height"`

// Set to `true` if the microblock corresponds to the canonical chain tip.
    Canonical bool`json:"canonical"`

// Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
    MicroblockCanonical bool`json:"microblock_canonical"`

// The SHA512/256 hash of this microblock.
    MicroblockHash string`json:"microblock_hash"`

// The SHA512/256 hash of the previous signed microblock in this stream.
    MicroblockParentHash string`json:"microblock_parent_hash"`

// A hint to describe how to order a set of microblocks. Starts at 0.
    MicroblockSequence int`json:"microblock_sequence"`

// The hash of the anchor block that preceded this microblock.
    ParentBlockHash string`json:"parent_block_hash"`

// The height of the anchor block that preceded this microblock.
    ParentBlockHeight int`json:"parent_block_height"`

// The hash of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHash string`json:"parent_burn_block_hash"`

// The height of the Bitcoin block that preceded this microblock.
    ParentBurnBlockHeight int`json:"parent_burn_block_height"`

// The block timestamp of the Bitcoin block that preceded this microblock.
    ParentBurnBlockTime int`json:"parent_burn_block_time"`

// The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
    ParentBurnBlockTimeIso string`json:"parent_burn_block_time_iso"`

// List of transactions included in the microblock
    Txs []string`json:"txs"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseSearchByIdResponse parses an HTTP response from a SearchByIdWithResponse call
func ParseSearchByIdResponse(rsp *http.Response) (*SearchByIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &SearchByIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest interface{}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetStatusResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Current chain tip information
    ChainTip *struct {
// the current block hash
    BlockHash string`json:"block_hash"`

// the current block height
    BlockHeight int`json:"block_height"`

// the current index block hash
    IndexBlockHash string`json:"index_block_hash"`

// the current microblock hash
    MicroblockHash *string`json:"microblock_hash,omitempty"`

// the current microblock sequence number
    MicroblockSequence *int`json:"microblock_sequence,omitempty"`
}`json:"chain_tip,omitempty"`

// the server version that is currently running
    ServerVersion *string`json:"server_version,omitempty"`

// the current server status
    Status string`json:"status"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetStxSupplyResponse parses an HTTP response from a GetStxSupplyWithResponse call
func ParseGetStxSupplyResponse(rsp *http.Response) (*GetStxSupplyResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetStxSupplyResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The block height at which this information was queried
    BlockHeight int`json:"block_height"`

// String quoted decimal number of the total possible number of STX
    TotalStx string`json:"total_stx"`

// String quoted decimal number of the percentage of STX that have unlocked
    UnlockedPercent string`json:"unlocked_percent"`

// String quoted decimal number of the STX that have been mined or unlocked
    UnlockedStx string`json:"unlocked_stx"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetStxSupplyCirculatingPlainResponse parses an HTTP response from a GetStxSupplyCirculatingPlainWithResponse call
func ParseGetStxSupplyCirculatingPlainResponse(rsp *http.Response) (*GetStxSupplyCirculatingPlainResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetStxSupplyCirculatingPlainResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    

    return response, nil
}


// ParseGetTotalStxSupplyLegacyFormatResponse parses an HTTP response from a GetTotalStxSupplyLegacyFormatWithResponse call
func ParseGetTotalStxSupplyLegacyFormatResponse(rsp *http.Response) (*GetTotalStxSupplyLegacyFormatResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTotalStxSupplyLegacyFormatResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The block height at which this information was queried
    BlockHeight string`json:"blockHeight"`

// String quoted decimal number of the total possible number of STX
    TotalStacks string`json:"totalStacks"`

// Same as `totalStacks` but formatted with comma thousands separators
    TotalStacksFormatted string`json:"totalStacksFormatted"`

// String quoted decimal number of the percentage of STX that have unlocked
    UnlockedPercent string`json:"unlockedPercent"`

// String quoted decimal number of the STX that have been mined or unlocked
    UnlockedSupply string`json:"unlockedSupply"`

// Same as `unlockedSupply` but formatted with comma thousands separators
    UnlockedSupplyFormatted string`json:"unlockedSupplyFormatted"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetStxSupplyTotalSupplyPlainResponse parses an HTTP response from a GetStxSupplyTotalSupplyPlainWithResponse call
func ParseGetStxSupplyTotalSupplyPlainResponse(rsp *http.Response) (*GetStxSupplyTotalSupplyPlainResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetStxSupplyTotalSupplyPlainResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    

    return response, nil
}


// ParseGetFtMetadataListResponse parses an HTTP response from a GetFtMetadataListWithResponse call
func ParseGetFtMetadataListResponse(rsp *http.Response) (*GetFtMetadataListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetFtMetadataListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of tokens metadata to return
    Limit int`json:"limit"`

// The number to tokens metadata to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// The number of decimal places in a token.
    Decimals float32`json:"decimals"`

// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
    Symbol string`json:"symbol"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}`json:"results"`

// The number of tokens metadata available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNftHistoryResponse parses an HTTP response from a GetNftHistoryWithResponse call
func ParseGetNftHistoryResponse(rsp *http.Response) (*GetNftHistoryResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNftHistoryResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of events to return
    Limit int`json:"limit"`

// The number to events to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of events available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNftHoldingsResponse parses an HTTP response from a GetNftHoldingsWithResponse call
func ParseGetNftHoldingsResponse(rsp *http.Response) (*GetNftHoldingsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNftHoldingsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of Non-Fungible Token holdings to return
    Limit int`json:"limit"`

// The number to Non-Fungible Token holdings to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of Non-Fungible Token holdings available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNftMetadataListResponse parses an HTTP response from a GetNftMetadataListWithResponse call
func ParseGetNftMetadataListResponse(rsp *http.Response) (*GetNftMetadataListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNftMetadataListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of tokens metadata to return
    Limit int`json:"limit"`

// The number to tokens metadata to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []struct {
// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}`json:"results"`

// The number of tokens metadata available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNftMintsResponse parses an HTTP response from a GetNftMintsWithResponse call
func ParseGetNftMintsResponse(rsp *http.Response) (*GetNftMintsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNftMintsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of mint events to return
    Limit int`json:"limit"`

// The number to mint events to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of mint events available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractFtMetadataResponse parses an HTTP response from a GetContractFtMetadataWithResponse call
func ParseGetContractFtMetadataResponse(rsp *http.Response) (*GetContractFtMetadataResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractFtMetadataResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of decimal places in a token.
    Decimals float32`json:"decimals"`

// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
    Symbol string`json:"symbol"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractNftMetadataResponse parses an HTTP response from a GetContractNftMetadataWithResponse call
func ParseGetContractNftMetadataResponse(rsp *http.Response) (*GetContractNftMetadataResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractNftMetadataResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Describes the asset to which this token represents
    Description string`json:"description"`

// The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
    ImageCanonicalUri string`json:"image_canonical_uri"`

// A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
    ImageUri string`json:"image_uri"`

// Identifies the asset to which this token represents
    Name string`json:"name"`

// principle that deployed the contract
    SenderAddress string`json:"sender_address"`

// An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
    TokenUri string`json:"token_uri"`

// Tx id that deployed the contract
    TxId string`json:"tx_id"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetTransactionListResponse parses an HTTP response from a GetTransactionListWithResponse call
func ParseGetTransactionListResponse(rsp *http.Response) (*GetTransactionListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTransactionListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetTransactionsByBlockHashResponse parses an HTTP response from a GetTransactionsByBlockHashWithResponse call
func ParseGetTransactionsByBlockHashResponse(rsp *http.Response) (*GetTransactionsByBlockHashResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTransactionsByBlockHashResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetTransactionsByBlockHeightResponse parses an HTTP response from a GetTransactionsByBlockHeightWithResponse call
func ParseGetTransactionsByBlockHeightResponse(rsp *http.Response) (*GetTransactionsByBlockHeightResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTransactionsByBlockHeightResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The number of transactions to return
    Limit int`json:"limit"`

// The number to transactions to skip (starting at `0`)
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`

// The number of transactions available
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetFilteredEventsResponse parses an HTTP response from a GetFilteredEventsWithResponse call
func ParseGetFilteredEventsResponse(rsp *http.Response) (*GetFilteredEventsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetFilteredEventsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetMempoolTransactionListResponse parses an HTTP response from a GetMempoolTransactionListWithResponse call
func ParseGetMempoolTransactionListResponse(rsp *http.Response) (*GetMempoolTransactionListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetMempoolTransactionListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetDroppedMempoolTransactionListResponse parses an HTTP response from a GetDroppedMempoolTransactionListWithResponse call
func ParseGetDroppedMempoolTransactionListResponse(rsp *http.Response) (*GetDroppedMempoolTransactionListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetDroppedMempoolTransactionListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Limit int`json:"limit"`
    Offset int`json:"offset"`
    Results []interface{}`json:"results"`
    Total int`json:"total"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetTxListDetailsResponse parses an HTTP response from a GetTxListDetailsWithResponse call
func ParseGetTxListDetailsResponse(rsp *http.Response) (*GetTxListDetailsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTxListDetailsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
AdditionalProperties map[string]interface{} `json:"-"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetTransactionByIdResponse parses an HTTP response from a GetTransactionByIdWithResponse call
func ParseGetTransactionByIdResponse(rsp *http.Response) (*GetTransactionByIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTransactionByIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest interface{}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetRawTransactionByIdResponse parses an HTTP response from a GetRawTransactionByIdWithResponse call
func ParseGetRawTransactionByIdResponse(rsp *http.Response) (*GetRawTransactionByIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetRawTransactionByIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// A hex encoded serialized transaction
    RawTx string`json:"raw_tx"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseRosettaAccountBalanceResponse parses an HTTP response from a RosettaAccountBalanceWithResponse call
func ParseRosettaAccountBalanceResponse(rsp *http.Response) (*RosettaAccountBalanceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaAccountBalanceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// A single account balance may have multiple currencies
    Balances []struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"balances"`

// The block_identifier uniquely identifies a block in a particular network.
    BlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"block_identifier"`

// If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.
    Coins *[]struct {
// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coins,omitempty"`

// Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
    Metadata *struct {
    SequenceNumber int`json:"sequence_number"`
}`json:"metadata,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaBlockResponse parses an HTTP response from a RosettaBlockWithResponse call
func ParseRosettaBlockResponse(rsp *http.Response) (*RosettaBlockResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaBlockResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be inalterable: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents.
    Block *struct {
// The block_identifier uniquely identifies a block in a particular network.
    BlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"block_identifier"`

// meta data
    Metadata *struct {
    Difficulty string`json:"difficulty"`
    TransactionsRoot string`json:"transactions_root"`
}`json:"metadata,omitempty"`

// The block_identifier uniquely identifies a block in a particular network.
    ParentBlockIdentifier struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"parent_block_identifier"`

// The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
    Timestamp int`json:"timestamp"`

// All the transactions in the block
    Transactions []struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200BlockTransactionsOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transactions"`
}`json:"block,omitempty"`

// Some blockchains may require additional transactions to be fetched that weren't returned in the block response (ex: block only returns transaction hashes). For blockchains with a lot of transactions in each block, this can be very useful as consumers can concurrently fetch all transactions returned.
    OtherTransactions *[]struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"other_transactions,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaBlockTransactionResponse parses an HTTP response from a RosettaBlockTransactionWithResponse call
func ParseRosettaBlockTransactionResponse(rsp *http.Response) (*RosettaBlockTransactionResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaBlockTransactionResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
    Transaction struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200TransactionOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transaction"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionCombineResponse parses an HTTP response from a RosettaConstructionCombineWithResponse call
func ParseRosettaConstructionCombineResponse(rsp *http.Response) (*RosettaConstructionCombineResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionCombineResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Signed transaction bytes in hex
    SignedTransaction string`json:"signed_transaction"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionDeriveResponse parses an HTTP response from a RosettaConstructionDeriveWithResponse call
func ParseRosettaConstructionDeriveResponse(rsp *http.Response) (*RosettaConstructionDeriveResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionDeriveResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier,omitempty"`

// [DEPRECATED by account_identifier in v1.4.4] Address in network-specific format.
    Address *string`json:"address,omitempty"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionHashResponse parses an HTTP response from a RosettaConstructionHashWithResponse call
func ParseRosettaConstructionHashResponse(rsp *http.Response) (*RosettaConstructionHashResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionHashResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionMetadataResponse parses an HTTP response from a RosettaConstructionMetadataWithResponse call
func ParseRosettaConstructionMetadataResponse(rsp *http.Response) (*RosettaConstructionMetadataResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionMetadataResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Metadata struct {
    AccountSequence *int`json:"account_sequence,omitempty"`
    RecentBlockHash *string`json:"recent_block_hash,omitempty"`
}`json:"metadata"`
    SuggestedFee *[]struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"suggested_fee,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionParseResponse parses an HTTP response from a RosettaConstructionParseWithResponse call
func ParseRosettaConstructionParseResponse(rsp *http.Response) (*RosettaConstructionParseResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionParseResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    AccountIdentifierSigners *[]struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier_signers,omitempty"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200OperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// [DEPRECATED by account_identifier_signers in v1.4.4] All signers (addresses) of a particular transaction. If the transaction is unsigned, it should be empty.
    Signers *[]interface{}`json:"signers,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionPayloadsResponse parses an HTTP response from a RosettaConstructionPayloadsWithResponse call
func ParseRosettaConstructionPayloadsResponse(rsp *http.Response) (*RosettaConstructionPayloadsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionPayloadsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// An array of payloads that must be signed by the caller
    Payloads []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    AccountIdentifier *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account_identifier,omitempty"`

// [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
    Address *string`json:"address,omitempty"`
    HexBytes string`json:"hex_bytes"`

// SignatureType is the type of a cryptographic signature.
    SignatureType *N200PayloadsSignatureType`json:"signature_type,omitempty"`
}`json:"payloads"`

// This is an unsigned transaction blob (that is usually needed to construct the a network transaction from a collection of signatures)
    UnsignedTransaction string`json:"unsigned_transaction"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionPreprocessResponse parses an HTTP response from a RosettaConstructionPreprocessWithResponse call
func ParseRosettaConstructionPreprocessResponse(rsp *http.Response) (*RosettaConstructionPreprocessResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionPreprocessResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The options that will be sent directly to /construction/metadata by the caller.
    Options *struct {
// Amount to be transfered.
    Amount *string`json:"amount,omitempty"`

// Set the burnchain (BTC) block for stacking lock to start.
    BurnBlockHeight *int`json:"burn_block_height,omitempty"`

// Address of the contract to call.
    ContractAddress *string`json:"contract_address,omitempty"`

// Name of the contract to call.
    ContractName *string`json:"contract_name,omitempty"`

// Number of decimal places
    Decimals *int`json:"decimals,omitempty"`

// Delegator address for when calling `delegate-stacking`.
    DelegateTo *string`json:"delegate_to,omitempty"`

// Fee for this transaction
    Fee *string`json:"fee,omitempty"`

// Maximum price a user is willing to pay.
    GasLimit *float32`json:"gas_limit,omitempty"`

// Cost necessary to perform a transaction on the network
    GasPrice *float32`json:"gas_price,omitempty"`

// Maximum fee user is willing to pay
    MaxFee *string`json:"max_fee,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// Number of cycles when stacking.
    NumberOfCycles *int`json:"number_of_cycles,omitempty"`

// The reward address for stacking transaction. It should be a valid Bitcoin address
    PoxAddr *string`json:"pox_addr,omitempty"`

// sender's address 
    SenderAddress *string`json:"sender_address,omitempty"`

// Transaction approximative size (used to calculate total fee).
    Size *int`json:"size,omitempty"`

// This value indicates the state of the operations
    Status *string`json:"status,omitempty"`

//  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
    SuggestedFeeMultiplier *float32`json:"suggested_fee_multiplier,omitempty"`

// Currency symbol e.g STX
    Symbol *string`json:"symbol,omitempty"`

// Recipient's address
    TokenTransferRecipientAddress *string`json:"token_transfer_recipient_address,omitempty"`

// Type of operation e.g transfer
    Type *string`json:"type,omitempty"`
}`json:"options,omitempty"`
    RequiredPublicKeys *[]struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"required_public_keys,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaConstructionSubmitResponse parses an HTTP response from a RosettaConstructionSubmitWithResponse call
func ParseRosettaConstructionSubmitResponse(rsp *http.Response) (*RosettaConstructionSubmitResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaConstructionSubmitResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaMempoolResponse parses an HTTP response from a RosettaMempoolWithResponse call
func ParseRosettaMempoolResponse(rsp *http.Response) (*RosettaMempoolResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaMempoolResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
    TransactionIdentifiers []struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifiers"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaMempoolTransactionResponse parses an HTTP response from a RosettaMempoolTransactionWithResponse call
func ParseRosettaMempoolTransactionResponse(rsp *http.Response) (*RosettaMempoolTransactionResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaMempoolTransactionResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
    Transaction struct {
// Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
    Metadata *struct {
// The locktime
    LockTime *int`json:"lockTime,omitempty"`

// STX token transfer memo.
    Memo *string`json:"memo,omitempty"`

// The Size
    Size *int`json:"size,omitempty"`
}`json:"metadata,omitempty"`

// List of operations
    Operations []struct {
// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
    Account *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
    SubAccount *struct {
// The address may be a cryptographic public key (or some encoding of it) or a provided username.
    Address string`json:"address"`

// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`
}`json:"sub_account,omitempty"`
}`json:"account,omitempty"`

// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
    Amount *struct {
// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
    Currency struct {
// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
    Decimals int`json:"decimals"`

// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Canonical symbol associated with a currency.
    Symbol string`json:"symbol"`
}`json:"currency"`
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
    Value string`json:"value"`
}`json:"amount,omitempty"`

// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
    CoinChange *struct {
// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
    CoinAction N200TransactionOperationsCoinChangeCoinAction`json:"coin_action"`

// CoinIdentifier uniquely identifies a Coin.
    CoinIdentifier struct {
// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
    Identifier string`json:"identifier"`
}`json:"coin_identifier"`
}`json:"coin_change,omitempty"`

// Operations Meta Data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// The operation_identifier uniquely identifies an operation within a transaction.
    OperationIdentifier struct {
// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"operation_identifier"`

// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
    RelatedOperations *[]struct {
// Describes the index of related operation.
    Index int`json:"index"`

// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
    NetworkIndex *int`json:"network_index,omitempty"`
}`json:"related_operations,omitempty"`

// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
    Status *string`json:"status,omitempty"`

// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
    Type string`json:"type"`
}`json:"operations"`

// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
    TransactionIdentifier struct {
// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
    Hash string`json:"hash"`
}`json:"transaction_identifier"`
}`json:"transaction"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaNetworkListResponse parses an HTTP response from a RosettaNetworkListWithResponse call
func ParseRosettaNetworkListResponse(rsp *http.Response) (*RosettaNetworkListResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaNetworkListResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The network_identifier specifies which network a particular object is associated with.
    NetworkIdentifiers []struct {
// Blockchain name
    Blockchain string`json:"blockchain"`

// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
    Network string`json:"network"`

// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
    SubNetworkIdentifier *struct {
// Meta data from subnetwork identifier
    Metadata *struct {
// producer
    Producer string`json:"producer"`
}`json:"metadata,omitempty"`

// Network name
    Network string`json:"network"`
}`json:"sub_network_identifier,omitempty"`
}`json:"network_identifiers"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaNetworkOptionsResponse parses an HTTP response from a RosettaNetworkOptionsWithResponse call
func ParseRosettaNetworkOptionsResponse(rsp *http.Response) (*RosettaNetworkOptionsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaNetworkOptionsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Allow specifies supported Operation status, Operation types, and all possible error statuses. This Allow object is used by clients to validate the correctness of a Rosetta Server implementation. It is expected that these clients will error if they receive some response that contains any of the above information that is not specified here.
    Allow struct {
// All Errors that this implementation could return. Any error that is returned during parsing that is not listed here will cause client validation to error.
    Errors []struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}`json:"errors"`

// Any Rosetta implementation that supports querying the balance of an account at any height in the past should set this to true.
    HistoricalBalanceLookup bool`json:"historical_balance_lookup"`

// All Operation.Status this implementation supports. Any status that is returned during parsing that is not listed here will cause client validation to error.
    OperationStatuses []struct {
// The status is the network-specific status of the operation.
    Status string`json:"status"`

// An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.
    Successful bool`json:"successful"`
}`json:"operation_statuses"`

// All Operation.Type this implementation supports. Any type that is returned during parsing that is not listed here will cause client validation to error.
    OperationTypes []interface{}`json:"operation_types"`
}`json:"allow"`

// The Version object is utilized to inform the client of the versions of different components of the Rosetta implementation.
    Version struct {
// Any other information that may be useful about versioning of dependent services should be returned here.
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// When a middleware server is used to adhere to the Rosetta interface, it should return its version here. This can help clients manage deployments.
    MiddlewareVersion *string`json:"middleware_version,omitempty"`

// The node_version is the canonical version of the node runtime. This can help clients manage deployments.
    NodeVersion string`json:"node_version"`

// The rosetta_version is the version of the Rosetta interface the implementation adheres to. This can be useful for clients looking to reliably parse responses.
    RosettaVersion string`json:"rosetta_version"`
}`json:"version"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseRosettaNetworkStatusResponse parses an HTTP response from a RosettaNetworkStatusWithResponse call
func ParseRosettaNetworkStatusResponse(rsp *http.Response) (*RosettaNetworkStatusResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &RosettaNetworkStatusResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// The block_identifier uniquely identifies a block in a particular network.
    CurrentBlockIdentifier struct {
// This is also known as the block hash.
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"current_block_identifier"`

// The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
    CurrentBlockTimestamp int`json:"current_block_timestamp"`

// The block_identifier uniquely identifies a block in a particular network.
    GenesisBlockIdentifier struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"genesis_block_identifier"`

// The block_identifier uniquely identifies a block in a particular network.
    OldestBlockIdentifier *struct {
// Block hash
    Hash string`json:"hash"`

// This is also known as the block height.
    Index int`json:"index"`
}`json:"oldest_block_identifier,omitempty"`

// Peers information
    Peers []struct {
// meta data
    Metadata *map[string]interface{}`json:"metadata,omitempty"`

// peer id
    PeerId string`json:"peer_id"`
}`json:"peers"`

// SyncStatus is used to provide additional context about an implementation's sync status. It is often used to indicate that an implementation is healthy when it cannot be queried until some sync phase occurs. If an implementation is immediately queryable, this model is often not populated.
    SyncStatus *struct {
// CurrentIndex is the index of the last synced block in the current stage.
    CurrentIndex int`json:"current_index"`

// Stage is the phase of the sync process.
    Stage *string`json:"stage,omitempty"`

// Synced indicates if an implementation has synced up to the most recent block.
    Synced *bool`json:"synced,omitempty"`

// TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.
    TargetIndex *int`json:"target_index,omitempty"`
}`json:"sync_status,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
    Code int`json:"code"`

// Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
    Details *struct {
    Address *string`json:"address,omitempty"`
    Error *string`json:"error,omitempty"`
}`json:"details,omitempty"`

// Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
    Message string`json:"message"`

// An error is retriable if the same request may succeed if submitted again.
    Retriable bool`json:"retriable"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseGetNamesOwnedByAddressResponse parses an HTTP response from a GetNamesOwnedByAddressWithResponse call
func ParseGetNamesOwnedByAddressResponse(rsp *http.Response) (*GetNamesOwnedByAddressResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNamesOwnedByAddressResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Names []string`json:"names"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseGetAllNamesResponse parses an HTTP response from a GetAllNamesWithResponse call
func ParseGetAllNamesResponse(rsp *http.Response) (*GetAllNamesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAllNamesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []string
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}


// ParseGetNameInfoResponse parses an HTTP response from a GetNameInfoWithResponse call
func ParseGetNameInfoResponse(rsp *http.Response) (*GetNameInfoResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNameInfoResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Address string`json:"address"`
    Blockchain string`json:"blockchain"`
    ExpireBlock *int`json:"expire_block,omitempty"`
    GracePeriod *int`json:"grace_period,omitempty"`
    LastTxid string`json:"last_txid"`
    Resolver *string`json:"resolver,omitempty"`
    Status string`json:"status"`
    Zonefile string`json:"zonefile"`
    ZonefileHash string`json:"zonefile_hash"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseFetchSubdomainsListForNameResponse parses an HTTP response from a FetchSubdomainsListForNameWithResponse call
func ParseFetchSubdomainsListForNameResponse(rsp *http.Response) (*FetchSubdomainsListForNameResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &FetchSubdomainsListForNameResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []string
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseFetchZoneFileResponse parses an HTTP response from a FetchZoneFileWithResponse call
func ParseFetchZoneFileResponse(rsp *http.Response) (*FetchZoneFileResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &FetchZoneFileResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest interface{}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseGetHistoricalZoneFileResponse parses an HTTP response from a GetHistoricalZoneFileWithResponse call
func ParseGetHistoricalZoneFileResponse(rsp *http.Response) (*GetHistoricalZoneFileResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetHistoricalZoneFileResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest interface{}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseGetAllNamespacesResponse parses an HTTP response from a GetAllNamespacesWithResponse call
func ParseGetAllNamespacesResponse(rsp *http.Response) (*GetAllNamespacesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAllNamespacesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Namespaces []string`json:"namespaces"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNamespaceNamesResponse parses an HTTP response from a GetNamespaceNamesWithResponse call
func ParseGetNamespaceNamesResponse(rsp *http.Response) (*GetNamespaceNamesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNamespaceNamesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []string
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
var dest struct {
    Error *string`json:"error,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON404 = &dest

}


    return response, nil
}


// ParseGetAccountInfoResponse parses an HTTP response from a GetAccountInfoWithResponse call
func ParseGetAccountInfoResponse(rsp *http.Response) (*GetAccountInfoResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetAccountInfoResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Balance string`json:"balance"`
    BalanceProof string`json:"balance_proof"`
    Locked string`json:"locked"`
    Nonce int`json:"nonce"`
    NonceProof string`json:"nonce_proof"`
    UnlockHeight int`json:"unlock_height"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseCallReadOnlyFunctionResponse parses an HTTP response from a CallReadOnlyFunctionWithResponse call
func ParseCallReadOnlyFunctionResponse(rsp *http.Response) (*CallReadOnlyFunctionResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &CallReadOnlyFunctionResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Cause *string`json:"cause,omitempty"`
    Okay bool`json:"okay"`
    Result *string`json:"result,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractInterfaceResponse parses an HTTP response from a GetContractInterfaceWithResponse call
func ParseGetContractInterfaceResponse(rsp *http.Response) (*GetContractInterfaceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractInterfaceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// List of defined methods
    Functions []map[string]interface{}`json:"functions"`

// List of fungible tokens in the contract
    FungibleTokens []map[string]interface{}`json:"fungible_tokens"`

// List of defined data-maps
    Maps []map[string]interface{}`json:"maps"`

// List of non-fungible tokens in the contract
    NonFungibleTokens []map[string]interface{}`json:"non_fungible_tokens"`

// List of defined variables
    Variables []map[string]interface{}`json:"variables"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractSourceResponse parses an HTTP response from a GetContractSourceWithResponse call
func ParseGetContractSourceResponse(rsp *http.Response) (*GetContractSourceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractSourceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Proof string`json:"proof"`
    PublishHeight int`json:"publish_height"`
    Source string`json:"source"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParsePostFeeTransactionResponse parses an HTTP response from a PostFeeTransactionWithResponse call
func ParsePostFeeTransactionResponse(rsp *http.Response) (*PostFeeTransactionResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PostFeeTransactionResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    CostScalarChangeByByte *float32`json:"cost_scalar_change_by_byte,omitempty"`
    EstimatedCost struct {
    ReadCount int`json:"read_count"`
    ReadLength int`json:"read_length"`
    Runtime int`json:"runtime"`
    WriteCount int`json:"write_count"`
    WriteLength int`json:"write_length"`
}`json:"estimated_cost"`
    EstimatedCostScalar int`json:"estimated_cost_scalar"`
    Estimations *[]struct {
    Fee *float32`json:"fee,omitempty"`
    FeeRate *float32`json:"fee_rate,omitempty"`
}`json:"estimations,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetFeeTransferResponse parses an HTTP response from a GetFeeTransferWithResponse call
func ParseGetFeeTransferResponse(rsp *http.Response) (*GetFeeTransferResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetFeeTransferResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest string
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetCoreApiInfoResponse parses an HTTP response from a GetCoreApiInfoWithResponse call
func ParseGetCoreApiInfoResponse(rsp *http.Response) (*GetCoreApiInfoResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetCoreApiInfoResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// latest bitcoin chain height
    BurnBlockHeight int`json:"burn_block_height"`

// the block height at which the testnet network will be reset. not applicable for mainnet
    ExitAtBlockHeight int`json:"exit_at_block_height"`

// is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change
    NetworkId int`json:"network_id"`

// same as network_id, but for bitcoin
    ParentNetworkId int`json:"parent_network_id"`

// identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade
    PeerVersion int`json:"peer_version"`

// is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block
    PoxConsensus string`json:"pox_consensus"`

// is a version descriptor
    ServerVersion string`json:"server_version"`

// leftover from stacks 1.0, basically always burn_block_height - 1
    StableBurnBlockHeight int`json:"stable_burn_block_height"`

// same as burn_consensus, but evaluated at stable_burn_block_height
    StablePoxConsensus string`json:"stable_pox_consensus"`

// the best known block hash for the Stack chain (not including any pending microblocks)
    StacksTip string`json:"stacks_tip"`

// the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined
    StacksTipConsensusHash string`json:"stacks_tip_consensus_hash"`

// the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height
    StacksTipHeight int`json:"stacks_tip_height"`

// the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned
    UnanchoredTip string`json:"unanchored_tip"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetContractDataMapEntryResponse parses an HTTP response from a GetContractDataMapEntryWithResponse call
func ParseGetContractDataMapEntryResponse(rsp *http.Response) (*GetContractDataMapEntryResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetContractDataMapEntryResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
// Hex-encoded string of clarity value. It is always an optional tuple.
    Data string`json:"data"`

// Hex-encoded string of the MARF proof for the data
    Proof *string`json:"proof,omitempty"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetPoxInfoResponse parses an HTTP response from a GetPoxInfoWithResponse call
func ParseGetPoxInfoResponse(rsp *http.Response) (*GetPoxInfoResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetPoxInfoResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    ContractId string`json:"contract_id"`
    FirstBurnchainBlockHeight int`json:"first_burnchain_block_height"`
    MinAmountUstx int`json:"min_amount_ustx"`
    RegistrationWindowLength int`json:"registration_window_length"`
    RejectionFraction int`json:"rejection_fraction"`
    RejectionVotesLeftRequired int`json:"rejection_votes_left_required"`
    RewardCycleId int`json:"reward_cycle_id"`
    RewardCycleLength int`json:"reward_cycle_length"`
    TotalLiquidSupplyUstx int`json:"total_liquid_supply_ustx"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNamePriceResponse parses an HTTP response from a GetNamePriceWithResponse call
func ParseGetNamePriceResponse(rsp *http.Response) (*GetNamePriceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNamePriceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Amount string`json:"amount"`
    Units string`json:"units"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetNamespacePriceResponse parses an HTTP response from a GetNamespacePriceWithResponse call
func ParseGetNamespacePriceResponse(rsp *http.Response) (*GetNamespacePriceResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetNamespacePriceResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Amount string`json:"amount"`
    Units string`json:"units"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParsePostCoreNodeTransactionsResponse parses an HTTP response from a PostCoreNodeTransactionsWithResponse call
func ParsePostCoreNodeTransactionsResponse(rsp *http.Response) (*PostCoreNodeTransactionsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PostCoreNodeTransactionsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
var dest struct {
// The error
    Error string`json:"error"`

// The reason for the error
    Reason string`json:"reason"`

// More details about the reason
    ReasonData map[string]interface{}`json:"reason_data"`

// The relevant transaction id
    Txid string`json:"txid"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON400 = &dest

}


    return response, nil
}



