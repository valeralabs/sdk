/*
Stacks Blockchain API

Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 

API version: STACKS_API_VERSION
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RosettaApiService RosettaApi service
type RosettaApiService service

type ApiRosettaAccountBalanceRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaAccountBalanceRequest *RosettaAccountBalanceRequest
}

func (r ApiRosettaAccountBalanceRequest) RosettaAccountBalanceRequest(rosettaAccountBalanceRequest RosettaAccountBalanceRequest) ApiRosettaAccountBalanceRequest {
	r.rosettaAccountBalanceRequest = &rosettaAccountBalanceRequest
	return r
}

func (r ApiRosettaAccountBalanceRequest) Execute() (*RosettaAccountBalanceResponse, *http.Response, error) {
	return r.ApiService.RosettaAccountBalanceExecute(r)
}

/*
RosettaAccountBalance Get an Account Balance

An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint.
If the block_identifier is populated, a historical balance query should be performed.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaAccountBalanceRequest
*/
func (a *RosettaApiService) RosettaAccountBalance(ctx context.Context) ApiRosettaAccountBalanceRequest {
	return ApiRosettaAccountBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaAccountBalanceResponse
func (a *RosettaApiService) RosettaAccountBalanceExecute(r ApiRosettaAccountBalanceRequest) (*RosettaAccountBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaAccountBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaAccountBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/account/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaAccountBalanceRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaAccountBalanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaAccountBalanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaBlockRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaBlockRequest *RosettaBlockRequest
}

func (r ApiRosettaBlockRequest) RosettaBlockRequest(rosettaBlockRequest RosettaBlockRequest) ApiRosettaBlockRequest {
	r.rosettaBlockRequest = &rosettaBlockRequest
	return r
}

func (r ApiRosettaBlockRequest) Execute() (*RosettaBlockResponse, *http.Response, error) {
	return r.ApiService.RosettaBlockExecute(r)
}

/*
RosettaBlock Get a Block

Retrieves the Block information for a given block identifier including a list of all transactions in the block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaBlockRequest
*/
func (a *RosettaApiService) RosettaBlock(ctx context.Context) ApiRosettaBlockRequest {
	return ApiRosettaBlockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaBlockResponse
func (a *RosettaApiService) RosettaBlockExecute(r ApiRosettaBlockRequest) (*RosettaBlockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaBlockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/block"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaBlockRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaBlockRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaBlockRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RosettaError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaBlockTransactionRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaBlockTransactionRequest *RosettaBlockTransactionRequest
}

func (r ApiRosettaBlockTransactionRequest) RosettaBlockTransactionRequest(rosettaBlockTransactionRequest RosettaBlockTransactionRequest) ApiRosettaBlockTransactionRequest {
	r.rosettaBlockTransactionRequest = &rosettaBlockTransactionRequest
	return r
}

func (r ApiRosettaBlockTransactionRequest) Execute() (*RosettaBlockTransactionResponse, *http.Response, error) {
	return r.ApiService.RosettaBlockTransactionExecute(r)
}

/*
RosettaBlockTransaction Get a Block Transaction

Retrieves a Transaction included in a block that is not returned in a BlockResponse.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaBlockTransactionRequest
*/
func (a *RosettaApiService) RosettaBlockTransaction(ctx context.Context) ApiRosettaBlockTransactionRequest {
	return ApiRosettaBlockTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaBlockTransactionResponse
func (a *RosettaApiService) RosettaBlockTransactionExecute(r ApiRosettaBlockTransactionRequest) (*RosettaBlockTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaBlockTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaBlockTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/block/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaBlockTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaBlockTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaBlockTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionCombineRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionCombineRequest *RosettaConstructionCombineRequest
}

func (r ApiRosettaConstructionCombineRequest) RosettaConstructionCombineRequest(rosettaConstructionCombineRequest RosettaConstructionCombineRequest) ApiRosettaConstructionCombineRequest {
	r.rosettaConstructionCombineRequest = &rosettaConstructionCombineRequest
	return r
}

func (r ApiRosettaConstructionCombineRequest) Execute() (*RosettaConstructionCombineResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionCombineExecute(r)
}

/*
RosettaConstructionCombine Create Network Transaction from Signatures

Take unsigned transaction and signature, combine both and return signed transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionCombineRequest
*/
func (a *RosettaApiService) RosettaConstructionCombine(ctx context.Context) ApiRosettaConstructionCombineRequest {
	return ApiRosettaConstructionCombineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionCombineResponse
func (a *RosettaApiService) RosettaConstructionCombineExecute(r ApiRosettaConstructionCombineRequest) (*RosettaConstructionCombineResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionCombineResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionCombine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/combine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionCombineRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionCombineRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionCombineRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionDeriveRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionDeriveRequest *RosettaConstructionDeriveRequest
}

func (r ApiRosettaConstructionDeriveRequest) RosettaConstructionDeriveRequest(rosettaConstructionDeriveRequest RosettaConstructionDeriveRequest) ApiRosettaConstructionDeriveRequest {
	r.rosettaConstructionDeriveRequest = &rosettaConstructionDeriveRequest
	return r
}

func (r ApiRosettaConstructionDeriveRequest) Execute() (*RosettaConstructionDeriveResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionDeriveExecute(r)
}

/*
RosettaConstructionDerive Derive an AccountIdentifier from a PublicKey

Retrieves the Account Identifier information based on a Public Key for a given network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionDeriveRequest
*/
func (a *RosettaApiService) RosettaConstructionDerive(ctx context.Context) ApiRosettaConstructionDeriveRequest {
	return ApiRosettaConstructionDeriveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionDeriveResponse
func (a *RosettaApiService) RosettaConstructionDeriveExecute(r ApiRosettaConstructionDeriveRequest) (*RosettaConstructionDeriveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionDeriveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionDerive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/derive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionDeriveRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionDeriveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionDeriveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionHashRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionHashRequest *RosettaConstructionHashRequest
}

func (r ApiRosettaConstructionHashRequest) RosettaConstructionHashRequest(rosettaConstructionHashRequest RosettaConstructionHashRequest) ApiRosettaConstructionHashRequest {
	r.rosettaConstructionHashRequest = &rosettaConstructionHashRequest
	return r
}

func (r ApiRosettaConstructionHashRequest) Execute() (*RosettaConstructionHashResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionHashExecute(r)
}

/*
RosettaConstructionHash Get the Hash of a Signed Transaction

Retrieves the network-specific transaction hash for a signed transaction.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionHashRequest
*/
func (a *RosettaApiService) RosettaConstructionHash(ctx context.Context) ApiRosettaConstructionHashRequest {
	return ApiRosettaConstructionHashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionHashResponse
func (a *RosettaApiService) RosettaConstructionHashExecute(r ApiRosettaConstructionHashRequest) (*RosettaConstructionHashResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionHashResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionHash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/hash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionHashRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionHashRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionHashRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionMetadataRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionMetadataRequest *RosettaConstructionMetadataRequest
}

func (r ApiRosettaConstructionMetadataRequest) RosettaConstructionMetadataRequest(rosettaConstructionMetadataRequest RosettaConstructionMetadataRequest) ApiRosettaConstructionMetadataRequest {
	r.rosettaConstructionMetadataRequest = &rosettaConstructionMetadataRequest
	return r
}

func (r ApiRosettaConstructionMetadataRequest) Execute() (*RosettaConstructionMetadataResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionMetadataExecute(r)
}

/*
RosettaConstructionMetadata Get Metadata for Transaction Construction

To Do

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionMetadataRequest
*/
func (a *RosettaApiService) RosettaConstructionMetadata(ctx context.Context) ApiRosettaConstructionMetadataRequest {
	return ApiRosettaConstructionMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionMetadataResponse
func (a *RosettaApiService) RosettaConstructionMetadataExecute(r ApiRosettaConstructionMetadataRequest) (*RosettaConstructionMetadataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionMetadataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionMetadataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionParseRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionParseRequest *RosettaConstructionParseRequest
}

func (r ApiRosettaConstructionParseRequest) RosettaConstructionParseRequest(rosettaConstructionParseRequest RosettaConstructionParseRequest) ApiRosettaConstructionParseRequest {
	r.rosettaConstructionParseRequest = &rosettaConstructionParseRequest
	return r
}

func (r ApiRosettaConstructionParseRequest) Execute() (*RosettaConstructionParseResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionParseExecute(r)
}

/*
RosettaConstructionParse Parse a Transaction

TODO

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionParseRequest
*/
func (a *RosettaApiService) RosettaConstructionParse(ctx context.Context) ApiRosettaConstructionParseRequest {
	return ApiRosettaConstructionParseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionParseResponse
func (a *RosettaApiService) RosettaConstructionParseExecute(r ApiRosettaConstructionParseRequest) (*RosettaConstructionParseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionParseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionParse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionParseRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionParseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionParseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionPayloadsRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionPayloadsRequest *RosettaConstructionPayloadsRequest
}

func (r ApiRosettaConstructionPayloadsRequest) RosettaConstructionPayloadsRequest(rosettaConstructionPayloadsRequest RosettaConstructionPayloadsRequest) ApiRosettaConstructionPayloadsRequest {
	r.rosettaConstructionPayloadsRequest = &rosettaConstructionPayloadsRequest
	return r
}

func (r ApiRosettaConstructionPayloadsRequest) Execute() (*RosettaConstructionPayloadResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionPayloadsExecute(r)
}

/*
RosettaConstructionPayloads Generate an Unsigned Transaction and Signing Payloads

Generate and unsigned transaction from operations and metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionPayloadsRequest
*/
func (a *RosettaApiService) RosettaConstructionPayloads(ctx context.Context) ApiRosettaConstructionPayloadsRequest {
	return ApiRosettaConstructionPayloadsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionPayloadResponse
func (a *RosettaApiService) RosettaConstructionPayloadsExecute(r ApiRosettaConstructionPayloadsRequest) (*RosettaConstructionPayloadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionPayloadResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionPayloads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/payloads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionPayloadsRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionPayloadsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionPayloadsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionPreprocessRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionPreprocessRequest *RosettaConstructionPreprocessRequest
}

func (r ApiRosettaConstructionPreprocessRequest) RosettaConstructionPreprocessRequest(rosettaConstructionPreprocessRequest RosettaConstructionPreprocessRequest) ApiRosettaConstructionPreprocessRequest {
	r.rosettaConstructionPreprocessRequest = &rosettaConstructionPreprocessRequest
	return r
}

func (r ApiRosettaConstructionPreprocessRequest) Execute() (*RosettaConstructionPreprocessResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionPreprocessExecute(r)
}

/*
RosettaConstructionPreprocess Create a Request to Fetch Metadata

TODO

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionPreprocessRequest
*/
func (a *RosettaApiService) RosettaConstructionPreprocess(ctx context.Context) ApiRosettaConstructionPreprocessRequest {
	return ApiRosettaConstructionPreprocessRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionPreprocessResponse
func (a *RosettaApiService) RosettaConstructionPreprocessExecute(r ApiRosettaConstructionPreprocessRequest) (*RosettaConstructionPreprocessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionPreprocessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionPreprocess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/preprocess"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionPreprocessRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionPreprocessRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionPreprocessRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaConstructionSubmitRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaConstructionSubmitRequest *RosettaConstructionSubmitRequest
}

func (r ApiRosettaConstructionSubmitRequest) RosettaConstructionSubmitRequest(rosettaConstructionSubmitRequest RosettaConstructionSubmitRequest) ApiRosettaConstructionSubmitRequest {
	r.rosettaConstructionSubmitRequest = &rosettaConstructionSubmitRequest
	return r
}

func (r ApiRosettaConstructionSubmitRequest) Execute() (*RosettaConstructionSubmitResponse, *http.Response, error) {
	return r.ApiService.RosettaConstructionSubmitExecute(r)
}

/*
RosettaConstructionSubmit Submit a Signed Transaction

Submit a pre-signed transaction to the node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaConstructionSubmitRequest
*/
func (a *RosettaApiService) RosettaConstructionSubmit(ctx context.Context) ApiRosettaConstructionSubmitRequest {
	return ApiRosettaConstructionSubmitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaConstructionSubmitResponse
func (a *RosettaApiService) RosettaConstructionSubmitExecute(r ApiRosettaConstructionSubmitRequest) (*RosettaConstructionSubmitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaConstructionSubmitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaConstructionSubmit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/construction/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaConstructionSubmitRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaConstructionSubmitRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaConstructionSubmitRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaMempoolRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaMempoolRequest *RosettaMempoolRequest
}

func (r ApiRosettaMempoolRequest) RosettaMempoolRequest(rosettaMempoolRequest RosettaMempoolRequest) ApiRosettaMempoolRequest {
	r.rosettaMempoolRequest = &rosettaMempoolRequest
	return r
}

func (r ApiRosettaMempoolRequest) Execute() (*RosettaMempoolResponse, *http.Response, error) {
	return r.ApiService.RosettaMempoolExecute(r)
}

/*
RosettaMempool Get All Mempool Transactions

Retrieves a list of transcations currently in the mempool for a given network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaMempoolRequest
*/
func (a *RosettaApiService) RosettaMempool(ctx context.Context) ApiRosettaMempoolRequest {
	return ApiRosettaMempoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaMempoolResponse
func (a *RosettaApiService) RosettaMempoolExecute(r ApiRosettaMempoolRequest) (*RosettaMempoolResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaMempoolResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaMempool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/mempool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaMempoolRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaMempoolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaMempoolRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaMempoolTransactionRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaMempoolTransactionRequest *RosettaMempoolTransactionRequest
}

func (r ApiRosettaMempoolTransactionRequest) RosettaMempoolTransactionRequest(rosettaMempoolTransactionRequest RosettaMempoolTransactionRequest) ApiRosettaMempoolTransactionRequest {
	r.rosettaMempoolTransactionRequest = &rosettaMempoolTransactionRequest
	return r
}

func (r ApiRosettaMempoolTransactionRequest) Execute() (*RosettaMempoolTransactionResponse, *http.Response, error) {
	return r.ApiService.RosettaMempoolTransactionExecute(r)
}

/*
RosettaMempoolTransaction Get a Mempool Transaction

Retrieves transaction details from the mempool for a given transaction id from a given network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaMempoolTransactionRequest
*/
func (a *RosettaApiService) RosettaMempoolTransaction(ctx context.Context) ApiRosettaMempoolTransactionRequest {
	return ApiRosettaMempoolTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaMempoolTransactionResponse
func (a *RosettaApiService) RosettaMempoolTransactionExecute(r ApiRosettaMempoolTransactionRequest) (*RosettaMempoolTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaMempoolTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaMempoolTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/mempool/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaMempoolTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaMempoolTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaMempoolTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaNetworkListRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
}

func (r ApiRosettaNetworkListRequest) Execute() (*RosettaNetworkListResponse, *http.Response, error) {
	return r.ApiService.RosettaNetworkListExecute(r)
}

/*
RosettaNetworkList Get List of Available Networks

Retrieves a list of NetworkIdentifiers that the Rosetta server supports.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaNetworkListRequest
*/
func (a *RosettaApiService) RosettaNetworkList(ctx context.Context) ApiRosettaNetworkListRequest {
	return ApiRosettaNetworkListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaNetworkListResponse
func (a *RosettaApiService) RosettaNetworkListExecute(r ApiRosettaNetworkListRequest) (*RosettaNetworkListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaNetworkListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaNetworkList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/network/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaNetworkOptionsRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaOptionsRequest *RosettaOptionsRequest
}

func (r ApiRosettaNetworkOptionsRequest) RosettaOptionsRequest(rosettaOptionsRequest RosettaOptionsRequest) ApiRosettaNetworkOptionsRequest {
	r.rosettaOptionsRequest = &rosettaOptionsRequest
	return r
}

func (r ApiRosettaNetworkOptionsRequest) Execute() (*RosettaNetworkOptionsResponse, *http.Response, error) {
	return r.ApiService.RosettaNetworkOptionsExecute(r)
}

/*
RosettaNetworkOptions Get Network Options

Retrieves the version information and allowed network-specific types for a NetworkIdentifier.
Any NetworkIdentifier returned by /network/list should be accessible here.
Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaNetworkOptionsRequest
*/
func (a *RosettaApiService) RosettaNetworkOptions(ctx context.Context) ApiRosettaNetworkOptionsRequest {
	return ApiRosettaNetworkOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaNetworkOptionsResponse
func (a *RosettaApiService) RosettaNetworkOptionsExecute(r ApiRosettaNetworkOptionsRequest) (*RosettaNetworkOptionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaNetworkOptionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaNetworkOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/network/options"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaOptionsRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaOptionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaOptionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRosettaNetworkStatusRequest struct {
	ctx context.Context
	ApiService *RosettaApiService
	rosettaStatusRequest *RosettaStatusRequest
}

func (r ApiRosettaNetworkStatusRequest) RosettaStatusRequest(rosettaStatusRequest RosettaStatusRequest) ApiRosettaNetworkStatusRequest {
	r.rosettaStatusRequest = &rosettaStatusRequest
	return r
}

func (r ApiRosettaNetworkStatusRequest) Execute() (*RosettaNetworkStatusResponse, *http.Response, error) {
	return r.ApiService.RosettaNetworkStatusExecute(r)
}

/*
RosettaNetworkStatus Get Network Status

Retrieves the current status of the network requested.
Any NetworkIdentifier returned by /network/list should be accessible here.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRosettaNetworkStatusRequest
*/
func (a *RosettaApiService) RosettaNetworkStatus(ctx context.Context) ApiRosettaNetworkStatusRequest {
	return ApiRosettaNetworkStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RosettaNetworkStatusResponse
func (a *RosettaApiService) RosettaNetworkStatusExecute(r ApiRosettaNetworkStatusRequest) (*RosettaNetworkStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RosettaNetworkStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RosettaApiService.RosettaNetworkStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rosetta/v1/network/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rosettaStatusRequest == nil {
		return localVarReturnValue, nil, reportError("rosettaStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rosettaStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
