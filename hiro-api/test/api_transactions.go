/*
Stacks Blockchain API

Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 

API version: STACKS_API_VERSION
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"os"
)


// TransactionsApiService TransactionsApi service
type TransactionsApiService service

type ApiGetAddressMempoolTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	address string
	limit *int32
	offset *int32
	unanchored *bool
}

// max number of transactions to fetch
func (r ApiGetAddressMempoolTransactionsRequest) Limit(limit int32) ApiGetAddressMempoolTransactionsRequest {
	r.limit = &limit
	return r
}

// index of first transaction to fetch
func (r ApiGetAddressMempoolTransactionsRequest) Offset(offset int32) ApiGetAddressMempoolTransactionsRequest {
	r.offset = &offset
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetAddressMempoolTransactionsRequest) Unanchored(unanchored bool) ApiGetAddressMempoolTransactionsRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetAddressMempoolTransactionsRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.GetAddressMempoolTransactionsExecute(r)
}

/*
GetAddressMempoolTransactions Transactions for address

Retrieves all transactions for a given address that are currently in mempool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param address Transactions for the address
 @return ApiGetAddressMempoolTransactionsRequest
*/
func (a *TransactionsApiService) GetAddressMempoolTransactions(ctx context.Context, address string) ApiGetAddressMempoolTransactionsRequest {
	return ApiGetAddressMempoolTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		address: address,
	}
}

// Execute executes the request
//  @return Object
func (a *TransactionsApiService) GetAddressMempoolTransactionsExecute(r ApiGetAddressMempoolTransactionsRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetAddressMempoolTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/address/{address}/mempool"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", url.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDroppedMempoolTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	limit *int32
	offset *int32
}

// max number of mempool transactions to fetch
func (r ApiGetDroppedMempoolTransactionListRequest) Limit(limit int32) ApiGetDroppedMempoolTransactionListRequest {
	r.limit = &limit
	return r
}

// index of first mempool transaction to fetch
func (r ApiGetDroppedMempoolTransactionListRequest) Offset(offset int32) ApiGetDroppedMempoolTransactionListRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDroppedMempoolTransactionListRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.GetDroppedMempoolTransactionListExecute(r)
}

/*
GetDroppedMempoolTransactionList Get dropped mempool transactions

Retrieves all recently-broadcast transactions that have been dropped from the mempool.

Transactions are dropped from the mempool if:
 * they were stale and awaiting garbage collection or,
 * were expensive,  or
 * were replaced with a new fee


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDroppedMempoolTransactionListRequest
*/
func (a *TransactionsApiService) GetDroppedMempoolTransactionList(ctx context.Context) ApiGetDroppedMempoolTransactionListRequest {
	return ApiGetDroppedMempoolTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Object
func (a *TransactionsApiService) GetDroppedMempoolTransactionListExecute(r ApiGetDroppedMempoolTransactionListRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetDroppedMempoolTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/mempool/dropped"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredEventsRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	txId *string
	address *string
	limit *int32
	offset *int32
	type_ *[]string
}

// Hash of transaction
func (r ApiGetFilteredEventsRequest) TxId(txId string) ApiGetFilteredEventsRequest {
	r.txId = &txId
	return r
}

// Stacks address or a Contract identifier
func (r ApiGetFilteredEventsRequest) Address(address string) ApiGetFilteredEventsRequest {
	r.address = &address
	return r
}

// number of items to return
func (r ApiGetFilteredEventsRequest) Limit(limit int32) ApiGetFilteredEventsRequest {
	r.limit = &limit
	return r
}

// number of items to skip
func (r ApiGetFilteredEventsRequest) Offset(offset int32) ApiGetFilteredEventsRequest {
	r.offset = &offset
	return r
}

// Filter the events on event type
func (r ApiGetFilteredEventsRequest) Type_(type_ []string) ApiGetFilteredEventsRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetFilteredEventsRequest) Execute() (*TransactionEventsResponse, *http.Response, error) {
	return r.ApiService.GetFilteredEventsExecute(r)
}

/*
GetFilteredEvents Transaction Events

Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types. The list of event types is ('smart_contract_log', 'stx_lock', 'stx_asset', 'fungible_token_asset', 'non_fungible_token_asset').

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilteredEventsRequest
*/
func (a *TransactionsApiService) GetFilteredEvents(ctx context.Context) ApiGetFilteredEventsRequest {
	return ApiGetFilteredEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionEventsResponse
func (a *TransactionsApiService) GetFilteredEventsExecute(r ApiGetFilteredEventsRequest) (*TransactionEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetFilteredEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.txId != nil {
		localVarQueryParams.Add("tx_id", parameterToString(*r.txId, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMempoolTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	senderAddress *string
	recipientAddress *string
	address *string
	limit *int32
	offset *int32
	unanchored *bool
}

// Filter to only return transactions with this sender address.
func (r ApiGetMempoolTransactionListRequest) SenderAddress(senderAddress string) ApiGetMempoolTransactionListRequest {
	r.senderAddress = &senderAddress
	return r
}

// Filter to only return transactions with this recipient address (only applicable for STX transfer tx types).
func (r ApiGetMempoolTransactionListRequest) RecipientAddress(recipientAddress string) ApiGetMempoolTransactionListRequest {
	r.recipientAddress = &recipientAddress
	return r
}

// Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types).
func (r ApiGetMempoolTransactionListRequest) Address(address string) ApiGetMempoolTransactionListRequest {
	r.address = &address
	return r
}

// max number of mempool transactions to fetch
func (r ApiGetMempoolTransactionListRequest) Limit(limit int32) ApiGetMempoolTransactionListRequest {
	r.limit = &limit
	return r
}

// index of first mempool transaction to fetch
func (r ApiGetMempoolTransactionListRequest) Offset(offset int32) ApiGetMempoolTransactionListRequest {
	r.offset = &offset
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetMempoolTransactionListRequest) Unanchored(unanchored bool) ApiGetMempoolTransactionListRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetMempoolTransactionListRequest) Execute() (*MempoolTransactionListResponse, *http.Response, error) {
	return r.ApiService.GetMempoolTransactionListExecute(r)
}

/*
GetMempoolTransactionList Get mempool transactions

Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.

If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMempoolTransactionListRequest
*/
func (a *TransactionsApiService) GetMempoolTransactionList(ctx context.Context) ApiGetMempoolTransactionListRequest {
	return ApiGetMempoolTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MempoolTransactionListResponse
func (a *TransactionsApiService) GetMempoolTransactionListExecute(r ApiGetMempoolTransactionListRequest) (*MempoolTransactionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MempoolTransactionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetMempoolTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/mempool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.senderAddress != nil {
		localVarQueryParams.Add("sender_address", parameterToString(*r.senderAddress, ""))
	}
	if r.recipientAddress != nil {
		localVarQueryParams.Add("recipient_address", parameterToString(*r.recipientAddress, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawTransactionByIdRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	txId string
}

func (r ApiGetRawTransactionByIdRequest) Execute() (*GetRawTransactionResult, *http.Response, error) {
	return r.ApiService.GetRawTransactionByIdExecute(r)
}

/*
GetRawTransactionById Get Raw Transaction

Retrieves a hex encoded serialized transaction for a given ID


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txId Hash of transaction
 @return ApiGetRawTransactionByIdRequest
*/
func (a *TransactionsApiService) GetRawTransactionById(ctx context.Context, txId string) ApiGetRawTransactionByIdRequest {
	return ApiGetRawTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
		txId: txId,
	}
}

// Execute executes the request
//  @return GetRawTransactionResult
func (a *TransactionsApiService) GetRawTransactionByIdExecute(r ApiGetRawTransactionByIdRequest) (*GetRawTransactionResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawTransactionResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetRawTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/{tx_id}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"tx_id"+"}", url.PathEscape(parameterToString(r.txId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionByIdRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	txId string
	eventOffset *int32
	eventLimit *int32
	unanchored *bool
}

// The number of events to skip
func (r ApiGetTransactionByIdRequest) EventOffset(eventOffset int32) ApiGetTransactionByIdRequest {
	r.eventOffset = &eventOffset
	return r
}

// The numbers of events to return
func (r ApiGetTransactionByIdRequest) EventLimit(eventLimit int32) ApiGetTransactionByIdRequest {
	r.eventLimit = &eventLimit
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTransactionByIdRequest) Unanchored(unanchored bool) ApiGetTransactionByIdRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTransactionByIdRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.GetTransactionByIdExecute(r)
}

/*
GetTransactionById Get transaction

Retrieves transaction details for a given transaction ID

`import type { Transaction } from '@stacks/stacks-blockchain-api-types';`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txId Hash of transaction
 @return ApiGetTransactionByIdRequest
*/
func (a *TransactionsApiService) GetTransactionById(ctx context.Context, txId string) ApiGetTransactionByIdRequest {
	return ApiGetTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
		txId: txId,
	}
}

// Execute executes the request
//  @return Transaction
func (a *TransactionsApiService) GetTransactionByIdExecute(r ApiGetTransactionByIdRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/{tx_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tx_id"+"}", url.PathEscape(parameterToString(r.txId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventOffset != nil {
		localVarQueryParams.Add("event_offset", parameterToString(*r.eventOffset, ""))
	}
	if r.eventLimit != nil {
		localVarQueryParams.Add("event_limit", parameterToString(*r.eventLimit, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	limit *int32
	offset *int32
	type_ *[]string
	unanchored *bool
}

// max number of transactions to fetch
func (r ApiGetTransactionListRequest) Limit(limit int32) ApiGetTransactionListRequest {
	r.limit = &limit
	return r
}

// index of first transaction to fetch
func (r ApiGetTransactionListRequest) Offset(offset int32) ApiGetTransactionListRequest {
	r.offset = &offset
	return r
}

// Filter by transaction type
func (r ApiGetTransactionListRequest) Type_(type_ []string) ApiGetTransactionListRequest {
	r.type_ = &type_
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTransactionListRequest) Unanchored(unanchored bool) ApiGetTransactionListRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTransactionListRequest) Execute() (*TransactionResults, *http.Response, error) {
	return r.ApiService.GetTransactionListExecute(r)
}

/*
GetTransactionList Get recent transactions

Retrieves all recently mined transactions

If using TypeScript, import typings for this response from our types package:

`import type { TransactionResults } from '@stacks/stacks-blockchain-api-types';`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTransactionListRequest
*/
func (a *TransactionsApiService) GetTransactionList(ctx context.Context) ApiGetTransactionListRequest {
	return ApiGetTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionResults
func (a *TransactionsApiService) GetTransactionListExecute(r ApiGetTransactionListRequest) (*TransactionResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsByBlockHashRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	blockHash string
	limit *int32
	offset *int32
}

// max number of transactions to fetch
func (r ApiGetTransactionsByBlockHashRequest) Limit(limit int32) ApiGetTransactionsByBlockHashRequest {
	r.limit = &limit
	return r
}

// index of first transaction to fetch
func (r ApiGetTransactionsByBlockHashRequest) Offset(offset int32) ApiGetTransactionsByBlockHashRequest {
	r.offset = &offset
	return r
}

func (r ApiGetTransactionsByBlockHashRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.GetTransactionsByBlockHashExecute(r)
}

/*
GetTransactionsByBlockHash Transactions by block hash

Retrieves a list of all transactions within a block for a given block hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockHash Hash of block
 @return ApiGetTransactionsByBlockHashRequest
*/
func (a *TransactionsApiService) GetTransactionsByBlockHash(ctx context.Context, blockHash string) ApiGetTransactionsByBlockHashRequest {
	return ApiGetTransactionsByBlockHashRequest{
		ApiService: a,
		ctx: ctx,
		blockHash: blockHash,
	}
}

// Execute executes the request
//  @return Object
func (a *TransactionsApiService) GetTransactionsByBlockHashExecute(r ApiGetTransactionsByBlockHashRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransactionsByBlockHash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/block/{block_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_hash"+"}", url.PathEscape(parameterToString(r.blockHash, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsByBlockHeightRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	height int32
	limit *int32
	offset *int32
	unanchored *bool
}

// max number of transactions to fetch
func (r ApiGetTransactionsByBlockHeightRequest) Limit(limit int32) ApiGetTransactionsByBlockHeightRequest {
	r.limit = &limit
	return r
}

// index of first transaction to fetch
func (r ApiGetTransactionsByBlockHeightRequest) Offset(offset int32) ApiGetTransactionsByBlockHeightRequest {
	r.offset = &offset
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTransactionsByBlockHeightRequest) Unanchored(unanchored bool) ApiGetTransactionsByBlockHeightRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTransactionsByBlockHeightRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.GetTransactionsByBlockHeightExecute(r)
}

/*
GetTransactionsByBlockHeight Transactions by block height

Retrieves all transactions within a block at a given height

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param height Height of block
 @return ApiGetTransactionsByBlockHeightRequest
*/
func (a *TransactionsApiService) GetTransactionsByBlockHeight(ctx context.Context, height int32) ApiGetTransactionsByBlockHeightRequest {
	return ApiGetTransactionsByBlockHeightRequest{
		ApiService: a,
		ctx: ctx,
		height: height,
	}
}

// Execute executes the request
//  @return Object
func (a *TransactionsApiService) GetTransactionsByBlockHeightExecute(r ApiGetTransactionsByBlockHeightRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTransactionsByBlockHeight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/block_height/{height}"
	localVarPath = strings.Replace(localVarPath, "{"+"height"+"}", url.PathEscape(parameterToString(r.height, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTxListDetailsRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	txId *[]string
	eventOffset *int32
	eventLimit *int32
	unanchored *bool
}

// Array of transaction ids
func (r ApiGetTxListDetailsRequest) TxId(txId []string) ApiGetTxListDetailsRequest {
	r.txId = &txId
	return r
}

// The number of events to skip
func (r ApiGetTxListDetailsRequest) EventOffset(eventOffset int32) ApiGetTxListDetailsRequest {
	r.eventOffset = &eventOffset
	return r
}

// The numbers of events to return
func (r ApiGetTxListDetailsRequest) EventLimit(eventLimit int32) ApiGetTxListDetailsRequest {
	r.eventLimit = &eventLimit
	return r
}

// Include transaction data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTxListDetailsRequest) Unanchored(unanchored bool) ApiGetTxListDetailsRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTxListDetailsRequest) Execute() (*map[string]TransactionList, *http.Response, error) {
	return r.ApiService.GetTxListDetailsExecute(r)
}

/*
GetTxListDetails Get list of details for transactions

Retrieves a list of transactions for a given list of transaction IDs

If using TypeScript, import typings for this response from our types package:

`import type { Transaction } from '@stacks/stacks-blockchain-api-types';`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTxListDetailsRequest
*/
func (a *TransactionsApiService) GetTxListDetails(ctx context.Context) ApiGetTxListDetailsRequest {
	return ApiGetTxListDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]TransactionList
func (a *TransactionsApiService) GetTxListDetailsExecute(r ApiGetTxListDetailsRequest) (*map[string]TransactionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]TransactionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.GetTxListDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/multiple"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.txId == nil {
		return localVarReturnValue, nil, reportError("txId is required and must be specified")
	}

	{
		t := *r.txId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tx_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tx_id", parameterToString(t, "multi"))
		}
	}
	if r.eventOffset != nil {
		localVarQueryParams.Add("event_offset", parameterToString(*r.eventOffset, ""))
	}
	if r.eventLimit != nil {
		localVarQueryParams.Add("event_limit", parameterToString(*r.eventLimit, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCoreNodeTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsApiService
	body **os.File
}

func (r ApiPostCoreNodeTransactionsRequest) Body(body *os.File) ApiPostCoreNodeTransactionsRequest {
	r.body = &body
	return r
}

func (r ApiPostCoreNodeTransactionsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.PostCoreNodeTransactionsExecute(r)
}

/*
PostCoreNodeTransactions Broadcast raw transaction

Broadcasts raw transactions on the network. You can use the [@stacks/transactions](https://github.com/blockstack/stacks.js) project to generate a raw transaction payload.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCoreNodeTransactionsRequest
*/
func (a *TransactionsApiService) PostCoreNodeTransactions(ctx context.Context) ApiPostCoreNodeTransactionsRequest {
	return ApiPostCoreNodeTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *TransactionsApiService) PostCoreNodeTransactionsExecute(r ApiPostCoreNodeTransactionsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsApiService.PostCoreNodeTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostCoreNodeTransactionsError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
