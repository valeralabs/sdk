// Code generated by schema-generate. DO NOT EDIT.
// Source paths:  ./api/address/get-address-assets.schema.json:./api/address/get-address-balances.schema.json:./api/address/get-address-nft-events.schema.json:./api/address/get-address-stx-balance.schema.json:./api/address/get-address-stx-inbound.schema.json:./api/address/get-address-transactions-with-transfers.schema.json:./api/address/get-address-transactions.schema.json:./api/blocks/get-blocks.schema.json:./api/bns/errors/bns-error.schema.json:./api/bns/manage-names/bns-fetch-zone-file-response.schema.json:./api/bns/name-querying/bns-get-all-names-response.schema.json:./api/bns/name-querying/bns-get-all-subdomains-response.schema.json:./api/bns/name-querying/bns-get-historical-zone-file-response.schema.json:./api/bns/name-querying/bns-get-name-info.response.schema.json:./api/bns/name-querying/bns-get-name-price-response.schema.json:./api/bns/name-querying/bns-get-names-owned-by-address-response.schema.json:./api/bns/name-querying/bns-get-subdomain-at-tx-response.schema.json:./api/bns/namespace-operations/bns-get-all-namespaces-names-response.schema.json:./api/bns/namespace-operations/bns-get-all-namespaces-response.schema.json:./api/bns/namespace-operations/bns-get-namespace-price-response.schema.json:./api/bns/subdomains/subdomains-list.schema.json:./api/burnchain/get-reward-slot-holders.schema.json:./api/burnchain/get-rewards.schema.json:./api/contract/post-call-read-only-fn.schema.json:./api/contract/smart-contract-list-response.schema.json:./api/core-node/get-account-data.schema.json:./api/core-node/get-contract-data-map-entry.schema.json:./api/core-node/get-contract-interface.schema.json:./api/core-node/get-contract-source.schema.json:./api/core-node/get-fee-transfer.schema.json:./api/core-node/get-info.schema.json:./api/core-node/get-pox.schema.json:./api/core-node/post-fee-transaction-response.schema.json:./api/core-node/post-fee-transaction.schema.json:./api/faucet/run-faucet.schema.json:./api/info/get-fee-rate-request.schema.json:./api/info/get-fee-rate-response.schema.json:./api/info/get-network-block-time-by-network.schema.json:./api/info/get-network-block-times.schema.json:./api/info/get-status.schema.json:./api/info/get-stx-supply-circulating-plain.schema.json:./api/info/get-stx-supply-legacy-format.schema.json:./api/info/get-stx-supply-total-plain.schema.json:./api/info/get-stx-supply.schema.json:./api/microblocks/get-microblocks.schema.json:./api/microblocks/get-unanchored-txs.schema.json:./api/rosetta/rosetta-account-balance-request.schema.json:./api/rosetta/rosetta-account-response.schema.json:./api/rosetta/rosetta-block-request.schema.json:./api/rosetta/rosetta-block-response.schema.json:./api/rosetta/rosetta-block-transaction-request.schema.json:./api/rosetta/rosetta-block-transaction-response.schema.json:./api/rosetta/rosetta-construction-combine-request.schema.json:./api/rosetta/rosetta-construction-combine-response.schema.json:./api/rosetta/rosetta-construction-derive-request.schema.json:./api/rosetta/rosetta-construction-derive-response.schema.json:./api/rosetta/rosetta-construction-hash-request.schema.json:./api/rosetta/rosetta-construction-hash-response.schema.json:./api/rosetta/rosetta-construction-metadata-request.schema.json:./api/rosetta/rosetta-construction-metadata-response.schema.json:./api/rosetta/rosetta-construction-parse-request.schema.json:./api/rosetta/rosetta-construction-parse-response.schema.json:./api/rosetta/rosetta-construction-payloads-request.schema.json:./api/rosetta/rosetta-construction-payloads-response.schema.json:./api/rosetta/rosetta-construction-preprocess-request.schema.json:./api/rosetta/rosetta-construction-preprocess-response.schema.json:./api/rosetta/rosetta-construction-submit-request.schema.json:./api/rosetta/rosetta-construction-submit-response.schema.json:./api/rosetta/rosetta-mempool-request.schema.json:./api/rosetta/rosetta-mempool-response.schema.json:./api/rosetta/rosetta-mempool-transaction-request.schema.json:./api/rosetta/rosetta-mempool-transaction-response.schema.json:./api/rosetta/rosetta-network-list-request.schema.json:./api/rosetta/rosetta-network-list-response.schema.json:./api/rosetta/rosetta-network-options-request.schema.json:./api/rosetta/rosetta-network-options-response.schema.json:./api/rosetta/rosetta-network-status-request.schema.json:./api/rosetta/rosetta-network-status-response.schema.json:./api/search/search-address.schema.json:./api/search/search-block.schema.json:./api/search/search-contract.schema.json:./api/search/search-error.schema.json:./api/search/search-mempool.schema.json:./api/search/search-success.schema.json:./api/search/search-tx-id.schema.json:./api/search/search.schema.json:./api/tokens/get-fungible-tokens-metadata-list.example.schema.json:./api/tokens/get-fungible-tokens-metadata-list.schema.json:./api/tokens/get-non-fungible-token-history-tx-metadata.example.schema.json:./api/tokens/get-non-fungible-token-history.example.schema.json:./api/tokens/get-non-fungible-token-history.schema.json:./api/tokens/get-non-fungible-token-holdings-tx-metadata.example.schema.json:./api/tokens/get-non-fungible-token-holdings.example.schema.json:./api/tokens/get-non-fungible-token-holdings.schema.json:./api/tokens/get-non-fungible-token-mints-tx-metadata.example.schema.json:./api/tokens/get-non-fungible-token-mints.example.schema.json:./api/tokens/get-non-fungible-token-mints.schema.json:./api/tokens/get-non-fungible-tokens-metadata-list.example.schema.json:./api/tokens/get-non-fungible-tokens-metadata-list.schema.json:./api/transaction/get-mempool-transactions.schema.json:./api/transaction/get-raw-transaction.schema.json:./api/transaction/get-transaction-events.schema.json:./api/transaction/get-transactions.schema.json:./api/transaction/post-core-node-transactions-error.schema.json:./entities/address/address-nonces.schema.json:./entities/address/token-offering-locked.schema.json:./entities/address/transaction-with-transfers.schema.json:./entities/address/unlock-schedule.schema.json:./entities/balance/ft-balance.schema.json:./entities/balance/nft-balance.schema.json:./entities/balance/stx-balance.schema.json:./entities/blocks/block.schema.json:./entities/burnchain/reward-slot-holder.schema.json:./entities/burnchain/reward.schema.json:./entities/burnchain/rewards-total.schema.json:./entities/contracts/read-only-function-args.schema.json:./entities/contracts/smart-contract.schema.json:./entities/info/block-time.schema.json:./entities/info/chain-tip.schema.json:./entities/mempool-transactions/abstract-transaction.schema.json:./entities/mempool-transactions/transaction-0-token-transfer.schema.json:./entities/mempool-transactions/transaction-1-smart-contract.schema.json:./entities/mempool-transactions/transaction-2-contract-call.schema.json:./entities/mempool-transactions/transaction-3-poison-microblock.schema.json:./entities/mempool-transactions/transaction-4-coinbase.schema.json:./entities/mempool-transactions/transaction-status.schema.json:./entities/mempool-transactions/transaction.schema.json:./entities/microblocks/microblock.schema.json:./entities/nft-events/nft-event.schema.json:./entities/post-conditions/post-condition-0-stx.schema.json:./entities/post-conditions/post-condition-1-fungible.schema.json:./entities/post-conditions/post-condition-2-non-fungible.schema.json:./entities/post-conditions/post-condition-fungible-condition-code.schema.json:./entities/post-conditions/post-condition-mode.schema.json:./entities/post-conditions/post-condition-non-fungible-condition-code.schema.json:./entities/post-conditions/post-condition-principal-type.schema.json:./entities/post-conditions/post-condition-principal.schema.json:./entities/post-conditions/post-condition-type.schema.json:./entities/post-conditions/post-condition.schema.json:./entities/rosetta/rosetta-account-identifier.schema.json:./entities/rosetta/rosetta-account.schema.json:./entities/rosetta/rosetta-amount-max-fee.schema.json:./entities/rosetta/rosetta-amount.schema.json:./entities/rosetta/rosetta-block-identifier-hash.schema.json:./entities/rosetta/rosetta-block-identifier-height.schema.json:./entities/rosetta/rosetta-block-identifier.schema.json:./entities/rosetta/rosetta-block.schema.json:./entities/rosetta/rosetta-coin-change.schema.json:./entities/rosetta/rosetta-coin.schema.json:./entities/rosetta/rosetta-construction-options.schema.json:./entities/rosetta/rosetta-currency.schema.json:./entities/rosetta/rosetta-error-no-details.schema.json:./entities/rosetta/rosetta-error.schema.json:./entities/rosetta/rosetta-genesis-block-identifier.schema.json:./entities/rosetta/rosetta-network-identifier.schema.json:./entities/rosetta/rosetta-network-peers.schema.json:./entities/rosetta/rosetta-oldest-block-identifier.schema.json:./entities/rosetta/rosetta-operation-identifier.schema.json:./entities/rosetta/rosetta-operation-statuses.schema.json:./entities/rosetta/rosetta-operation.schema.json:./entities/rosetta/rosetta-other-transaction-identifier.schema.json:./entities/rosetta/rosetta-parent-block-identifier.schema.json:./entities/rosetta/rosetta-partial-block-identifier.schema.json:./entities/rosetta/rosetta-public-key.schema.json:./entities/rosetta/rosetta-related-operation.schema.json:./entities/rosetta/rosetta-signature-type.schema.json:./entities/rosetta/rosetta-signature.schema.json:./entities/rosetta/rosetta-signing-payload.schema.json:./entities/rosetta/rosetta-sub-account.schema.json:./entities/rosetta/rosetta-sync-status.schema.json:./entities/rosetta/rosetta-transaction-identifier.schema.json:./entities/rosetta/rosetta-transaction.schema.json:./entities/tokens/fungible-token.schema.json:./entities/tokens/non-fungible-token-history-event-0-tx-id.example.schema.json:./entities/tokens/non-fungible-token-history-event-0-tx-id.schema.json:./entities/tokens/non-fungible-token-history-event-1-tx-metadata.example.schema.json:./entities/tokens/non-fungible-token-history-event-1-tx-metadata.schema.json:./entities/tokens/non-fungible-token-history-event.schema.json:./entities/tokens/non-fungible-token-holding-0-tx-id.example.schema.json:./entities/tokens/non-fungible-token-holding-0-tx-id.schema.json:./entities/tokens/non-fungible-token-holding-1-tx-metadata.example.schema.json:./entities/tokens/non-fungible-token-holding-1-tx-metadata.schema.json:./entities/tokens/non-fungible-token-holding.schema.json:./entities/tokens/non-fungible-token-mint-0-tx-id.example.schema.json:./entities/tokens/non-fungible-token-mint-0-tx-id.schema.json:./entities/tokens/non-fungible-token-mint-1-tx-metadata.example.schema.json:./entities/tokens/non-fungible-token-mint-1-tx-metadata.schema.json:./entities/tokens/non-fungible-token-mint.schema.json:./entities/tokens/non-fungible-token.schema.json:./entities/transaction-events/abstract-transaction-event.schema.json:./entities/transaction-events/asset-types/transaction-event-asset-type.schema.json:./entities/transaction-events/asset-types/transaction-event-asset.schema.json:./entities/transaction-events/transaction-event-fungible-asset.schema.json:./entities/transaction-events/transaction-event-non-fungible-asset.schema.json:./entities/transaction-events/transaction-event-smart-contract-log.schema.json:./entities/transaction-events/transaction-event-stx-asset.schema.json:./entities/transaction-events/transaction-event-stx-lock.schema.json:./entities/transaction-events/transaction-event-type.schema.json:./entities/transaction-events/transaction-event.schema.json:./entities/transactions/abstract-transaction.schema.json:./entities/transactions/anchor-mode.schema.json:./entities/transactions/base-transaction.schema.json:./entities/transactions/transaction-0-token-transfer-metadata.schema.json:./entities/transactions/transaction-0-token-transfer.schema.json:./entities/transactions/transaction-1-smart-contract-metadata.schema.json:./entities/transactions/transaction-1-smart-contract.schema.json:./entities/transactions/transaction-2-contract-call-metadata.schema.json:./entities/transactions/transaction-2-contract-call.schema.json:./entities/transactions/transaction-3-poison-microblock-metadata.schema.json:./entities/transactions/transaction-3-poison-microblock.schema.json:./entities/transactions/transaction-4-coinbase-metadata.schema.json:./entities/transactions/transaction-4-coinbase.schema.json:./entities/transactions/transaction-found.schema.json:./entities/transactions/transaction-list.schema.json:./entities/transactions/transaction-metadata.schema.json:./entities/transactions/transaction-not-found.schema.json:./entities/transactions/transaction-status.schema.json:./entities/transactions/transaction-type.schema.json:./entities/transactions/transaction.schema.json:./entities/transfers/inbound-stx-transfer.schema.json:./entities/ws-rpc/rpc-address-balance-notification-params.schema.json:./entities/ws-rpc/rpc-address-balance-notification-response.schema.json:./entities/ws-rpc/rpc-address-balance-subscription-params.schema.json:./entities/ws-rpc/rpc-address-balance-subscription-request.schema.json:./entities/ws-rpc/rpc-address-tx-notification-params.schema.json:./entities/ws-rpc/rpc-address-tx-notification-response.schema.json:./entities/ws-rpc/rpc-address-tx-subscription-params.schema.json:./entities/ws-rpc/rpc-address-tx-subscription-request.schema.json:./entities/ws-rpc/rpc-block-notification-response.schema.json:./entities/ws-rpc/rpc-block-subscription-params.schema.json:./entities/ws-rpc/rpc-block-subscription-request.schema.json:./entities/ws-rpc/rpc-mempool-notification-response.schema.json:./entities/ws-rpc/rpc-mempool-subscription-params.schema.json:./entities/ws-rpc/rpc-mempool-subscription-request.schema.json:./entities/ws-rpc/rpc-microblock-notification-response.schema.json:./entities/ws-rpc/rpc-microblock-subscription-params.schema.json:./entities/ws-rpc/rpc-microblock-subscription-request.schema.json:./entities/ws-rpc/rpc-subscription-type.schema.json:./entities/ws-rpc/rpc-tx-update-notification-params.schema.json:./entities/ws-rpc/rpc-tx-update-notification-response.schema.json:./entities/ws-rpc/rpc-tx-update-subscription-params.schema.json:./entities/ws-rpc/rpc-tx-update-subscription-request.schema.json

package main

import (
    "bytes"
    "encoding/json"
    "errors"
    "fmt"
)

var ErrFieldRequired = errors.New("field required validation failed")

// AbstractMempoolTransaction
type AbstractMempoolTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// AbstractTransaction
type AbstractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// AbstractTransactionEvent
type AbstractTransactionEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// AddressAssetsListResponse
type AddressAssetsListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// AddressSearchResult
type AddressSearchResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// AddressStxBalanceResponse
type AddressStxBalanceResponse *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// AddressStxInboundListResponse
type AddressStxInboundListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// AddressTransactionsListResponse
type AddressTransactionsListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// AddressTransactionsWithTransfersListResponse
type AddressTransactionsWithTransfersListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// AddressUnlockSchedule
type AddressUnlockSchedule *AddressUnlockSchedule_InboundStxTransfer

// Block
type Block *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// BlockListResponse
type BlockListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// BlockSearchResult
type BlockSearchResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// BnsError
type BnsError *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// BnsFetchFileZoneResponse
type BnsFetchFileZoneResponse interface{}

// BnsFetchHistoricalZoneFileResponse
type BnsFetchHistoricalZoneFileResponse interface{}

// BnsGetAllNamesResponse
type BnsGetAllNamesResponse []string

// BnsGetAllNamespacesNamesResponse
type BnsGetAllNamespacesNamesResponse []string

// BnsGetAllSubdomainsResponse
type BnsGetAllSubdomainsResponse []string

// BnsGetNamePriceResponse
type BnsGetNamePriceResponse *BnsGetNamePriceResponse_BnsGetNamespacePriceResponse

// BnsGetNamespacePriceResponse
type BnsGetNamespacePriceResponse *BnsGetNamePriceResponse_BnsGetNamespacePriceResponse

// BnsGetSubdomainAtTx
type BnsGetSubdomainAtTx []*BnsGetSubdomainAtTxItems

// BurnchainReward
type BurnchainReward *BurnchainReward_BurnchainRewardsTotal

// BurnchainRewardListResponse
type BurnchainRewardListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// BurnchainRewardSlotHolderListResponse
type BurnchainRewardSlotHolderListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// BurnchainRewardsTotal
type BurnchainRewardsTotal *BurnchainReward_BurnchainRewardsTotal

// CoinbaseTransaction
type CoinbaseTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// ContractCallTransaction
type ContractCallTransaction *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// ContractListResponse
type ContractListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// ContractSearchResult
type ContractSearchResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// CoreNodeFeeResponse
type CoreNodeFeeResponse string

// FeeRateRequest
type FeeRateRequest *FeeRateRequest_RosettaConstructionParseRequest

// FtBalance
type FtBalance *FtBalance_StxBalance

// FungibleTokenMetadata
type FungibleTokenMetadata *FungibleTokenMetadata_NonFungibleTokenMetadata

// FungibleTokensMetadataList
type FungibleTokensMetadataList *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// GetAllSubdomainsInName
type GetAllSubdomainsInName []string

// GetStxCirculatingSupplyPlainResponse
type GetStxCirculatingSupplyPlainResponse string

// GetStxTotalSupplyPlainResponse
type GetStxTotalSupplyPlainResponse string

// InboundStxTransfer
type InboundStxTransfer *AddressUnlockSchedule_InboundStxTransfer

// MempoolCoinbaseTransaction
type MempoolCoinbaseTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolContractCallTransaction
type MempoolContractCallTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolPoisonMicroblockTransaction
type MempoolPoisonMicroblockTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolSmartContractTransaction
type MempoolSmartContractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolTokenTransferTransaction
type MempoolTokenTransferTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolTransaction
type MempoolTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// MempoolTransactionListResponse
type MempoolTransactionListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// MempoolTransactionStatus
type MempoolTransactionStatus string

// MempoolTxSearchResult
type MempoolTxSearchResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// MicroblockListResponse
type MicroblockListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// NetworkBlockTimeResponse
type NetworkBlockTimeResponse *TargetBlockTime

// NftEvent
type NftEvent *NftEvent_NonFungibleTokenHoldingWithTxId

// NonFungibleTokenHistoryEvent
type NonFungibleTokenHistoryEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// NonFungibleTokenHistoryEventList
type NonFungibleTokenHistoryEventList *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// NonFungibleTokenHistoryEventWithTxMetadata
type NonFungibleTokenHistoryEventWithTxMetadata *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// NonFungibleTokenHolding
type NonFungibleTokenHolding *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// NonFungibleTokenHoldingWithTxId
type NonFungibleTokenHoldingWithTxId *NftEvent_NonFungibleTokenHoldingWithTxId

// NonFungibleTokenHoldingsList
type NonFungibleTokenHoldingsList *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// NonFungibleTokenMetadata
type NonFungibleTokenMetadata *FungibleTokenMetadata_NonFungibleTokenMetadata

// NonFungibleTokenMint
type NonFungibleTokenMint *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// NonFungibleTokenMintList
type NonFungibleTokenMintList *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// NonFungibleTokensMetadataList
type NonFungibleTokensMetadataList *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// OtherTransactionIdentifier
type OtherTransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// PoisonMicroblockTransaction
type PoisonMicroblockTransaction *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// PostCondition
type PostCondition interface{}

// PostConditionFungible
type PostConditionFungible *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// PostConditionFungibleConditionCode
type PostConditionFungibleConditionCode string

// PostConditionMode
type PostConditionMode string

// PostConditionNonFungible
type PostConditionNonFungible *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// PostConditionNonFungibleConditionCode
type PostConditionNonFungibleConditionCode string

// PostConditionPrincipal
type PostConditionPrincipal *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// PostConditionPrincipalType
type PostConditionPrincipalType string

// PostConditionStx
type PostConditionStx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// PostConditionType
type PostConditionType string

// Root
type Root interface{}

// RosettaAccount
type RosettaAccount *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount

// RosettaAccountBalanceRequest
type RosettaAccountBalanceRequest *RosettaAccountBalanceRequest_RosettaBlockRequest

// RosettaAccountIdentifier
type RosettaAccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount

// RosettaAmount
type RosettaAmount *RosettaAmount_RosettaMaxFeeAmount

// RosettaBlockIdentifier
type RosettaBlockIdentifier interface{}

// RosettaBlockIdentifierHash
type RosettaBlockIdentifierHash *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// RosettaBlockIdentifierHeight
type RosettaBlockIdentifierHeight *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaBlockRequest
type RosettaBlockRequest *RosettaAccountBalanceRequest_RosettaBlockRequest

// RosettaBlockTransactionRequest
type RosettaBlockTransactionRequest *RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest

// RosettaBlockTransactionResponse
type RosettaBlockTransactionResponse *RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse

// RosettaConstructionCombineResponse
type RosettaConstructionCombineResponse *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest

// RosettaConstructionDeriveRequest
type RosettaConstructionDeriveRequest *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest

// RosettaConstructionHashRequest
type RosettaConstructionHashRequest *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest

// RosettaConstructionHashResponse
type RosettaConstructionHashResponse *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction

// RosettaConstructionParseRequest
type RosettaConstructionParseRequest *FeeRateRequest_RosettaConstructionParseRequest

// RosettaConstructionPayloadsRequest
type RosettaConstructionPayloadsRequest *RosettaConstructionPayloadsRequest_RosettaMempoolRequest

// RosettaConstructionSubmitRequest
type RosettaConstructionSubmitRequest *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest

// RosettaConstructionSubmitResponse
type RosettaConstructionSubmitResponse *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction

// RosettaError
type RosettaError *RosettaError_RosettaErrorNoDetails

// RosettaErrorNoDetails
type RosettaErrorNoDetails *RosettaError_RosettaErrorNoDetails

// RosettaGenesisBlockIdentifier
type RosettaGenesisBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaMaxFeeAmount
type RosettaMaxFeeAmount *RosettaAmount_RosettaMaxFeeAmount

// RosettaMempoolRequest
type RosettaMempoolRequest *RosettaConstructionPayloadsRequest_RosettaMempoolRequest

// RosettaMempoolTransactionRequest
type RosettaMempoolTransactionRequest *RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest

// RosettaMempoolTransactionResponse
type RosettaMempoolTransactionResponse *RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse

// RosettaNetworkListRequest
type RosettaNetworkListRequest *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount

// RosettaOldestBlockIdentifier
type RosettaOldestBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaOperationIdentifier
type RosettaOperationIdentifier *RosettaOperationIdentifier_RosettaRelatedOperation

// RosettaOptionsRequest
type RosettaOptionsRequest *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest

// RosettaParentBlockIdentifier
type RosettaParentBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaPartialBlockIdentifier
type RosettaPartialBlockIdentifier *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// RosettaRelatedOperation
type RosettaRelatedOperation *RosettaOperationIdentifier_RosettaRelatedOperation

// RosettaStatusRequest
type RosettaStatusRequest *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest

// RosettaSubAccount
type RosettaSubAccount *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount

// RosettaTransaction
type RosettaTransaction *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction

// RpcAddressBalanceSubscriptionParams
type RpcAddressBalanceSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams

// RpcAddressTxNotificationParams
type RpcAddressTxNotificationParams *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams

// RpcAddressTxNotificationResponse
type RpcAddressTxNotificationResponse *RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse

// RpcAddressTxSubscriptionParams
type RpcAddressTxSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams

// RpcBlockSubscriptionParams
type RpcBlockSubscriptionParams *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams

// RpcMempoolSubscriptionParams
type RpcMempoolSubscriptionParams *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams

// RpcMicroblockSubscriptionParams
type RpcMicroblockSubscriptionParams *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams

// RpcSubscriptionType
type RpcSubscriptionType string

// RpcTxUpdateNotificationParams
type RpcTxUpdateNotificationParams *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams

// RpcTxUpdateNotificationResponse
type RpcTxUpdateNotificationResponse *RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse

// RpcTxUpdateSubscriptionParams
type RpcTxUpdateSubscriptionParams *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams

// SearchErrorResult
type SearchErrorResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// SearchResult
type SearchResult *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// SearchSuccessResult
type SearchSuccessResult *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// SignatureType
type SignatureType string

// SmartContractTransaction
type SmartContractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// StxBalance
type StxBalance *FtBalance_StxBalance

// TokenTransferTransaction
type TokenTransferTransaction *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// Transaction
type Transaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionAnchorModeType
type TransactionAnchorModeType string

// TransactionEvent
type TransactionEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionEventAssetType
type TransactionEventAssetType string

// TransactionEventFungibleAsset
type TransactionEventFungibleAsset *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionEventNonFungibleAsset
type TransactionEventNonFungibleAsset *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// TransactionEventSmartContractLog
type TransactionEventSmartContractLog *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionEventStxAsset
type TransactionEventStxAsset *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionEventStxLock
type TransactionEventStxLock *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// TransactionEventType
type TransactionEventType string

// TransactionEventsResponse
type TransactionEventsResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// TransactionIdentifier
type TransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// TransactionList
type TransactionList map[string]interface{}

// TransactionMetadata
type TransactionMetadata *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata

// TransactionNotFound
type TransactionNotFound *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// TransactionResults
type TransactionResults *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// TransactionStatus
type TransactionStatus string

// TransactionType
type TransactionType string

// TxSearchResult
type TxSearchResult *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult

// UnanchoredTransactionListResponse
type UnanchoredTransactionListResponse *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse

// AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata 
// Aliased for: AbstractMempoolTransaction, AbstractTransaction, AbstractTransactionEvent, AddressStxBalanceResponse, CoinbaseTransaction, MempoolCoinbaseTransaction, MempoolContractCallTransaction, MempoolPoisonMicroblockTransaction, MempoolSmartContractTransaction, MempoolTokenTransferTransaction, MempoolTransaction, NonFungibleTokenHistoryEvent, NonFungibleTokenHistoryEventWithTxMetadata, NonFungibleTokenHolding, PostConditionFungible, PostConditionNonFungible, PostConditionPrincipal, PostConditionStx, SearchResult, SearchSuccessResult, SmartContractTransaction, Transaction, TransactionEvent, TransactionEventFungibleAsset, TransactionEventSmartContractLog, TransactionEventStxAsset, TransactionMetadata
type AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata struct {
  AssetEventType string `json:"asset_event_type"` // s:8d875b2c95, f:fe527502dd2b8cc379d2
  _asset_event_type_ValidationError error

  EventIndex int `json:"event_index"` // s:121303b5fe, f:a7d7d4a0d6ca664fe2ba
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:9eda4c346b, f:f317cb9c05d07d741f06
  Sender string `json:"sender,omitempty"` // s:c9992a9f75, f:419d568501ac1bc2cbdf
  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"tx"` // s:2914f791da, f:bfc4f831bd83c18c6e54
  _tx_ValidationError error

}

// AccountDataResponse GET request for account data
type AccountDataResponse struct {
  Balance string `json:"balance"` // s:82661eaaf3, f:33b0fa8cd67745ba66d0
  _balance_ValidationError error

  BalanceProof string `json:"balance_proof"` // s:afcbd3817d, f:39c19e4ab1ba68b38e93
  _balance_proof_ValidationError error

  Locked string `json:"locked"` // s:0924962011, f:99c50c8a68dfaed15803
  _locked_ValidationError error

  Nonce int `json:"nonce"` // s:737565fb64, f:af584bfae404c6b4a3f3
  _nonce_ValidationError error

  NonceProof string `json:"nonce_proof"` // s:2e2cd441c2, f:b8d8d6098570d82d5df8
  _nonce_proof_ValidationError error

  UnlockHeight int `json:"unlock_height"` // s:4cf5cd8ef1, f:35fab390b0359351768c
  _unlock_height_ValidationError error

}

// AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse 
// Aliased for: AddressAssetsListResponse, AddressStxInboundListResponse, AddressTransactionsListResponse, AddressTransactionsWithTransfersListResponse, BlockListResponse, BurnchainRewardListResponse, BurnchainRewardSlotHolderListResponse, ContractCallTransaction, ContractListResponse, FungibleTokensMetadataList, MempoolTransactionListResponse, MicroblockListResponse, NonFungibleTokenHistoryEventList, NonFungibleTokenHoldingsList, NonFungibleTokenMint, NonFungibleTokenMintList, NonFungibleTokensMetadataList, PoisonMicroblockTransaction, RosettaPartialBlockIdentifier, TokenTransferTransaction, TransactionEventNonFungibleAsset, TransactionEventStxLock, TransactionEventsResponse, TransactionResults, UnanchoredTransactionListResponse
type AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse struct {

  // The number of microblocks to return
  // The number of blocks to return
  // The number of Non-Fungible Token holdings to return
  // 
  // The number of items to return
  // The number of events to return
  // The number of burnchain rewards to return
  // The number of contracts to return
  // The number of tokens metadata to return
  // The number of transactions to return
  // The number of mint events to return
  Limit int `json:"limit"` // s:ce7d0e157d, f:8dbab04fda08845ac99d
  _limit_ValidationError error


  // The number to microblocks to skip (starting at `0`)
  // The number to Non-Fungible Token holdings to skip (starting at `0`)
  // The number of items to skip (starting at `0`)
  // The number to events to skip (starting at `0`)
  // 
  // The number to tokens metadata to skip (starting at `0`)
  // The number to contracts to skip (starting at `0`)
  // The number to blocks to skip (starting at `0`)
  // The number to transactions to skip (starting at `0`)
  // The number to mint events to skip (starting at `0`)
  // The number to burnchain rewards to skip (starting at `0`)
  Offset int `json:"offset"` // s:09189adc2c, f:13dd781ecec148ac7a44
  _offset_ValidationError error

  Results []*MempoolTransaction `json:"results"` // s:2e3d881a07, f:01dcc061afa15aaafc14
  _results_ValidationError error


  // Total number of available items
  // The number of Non-Fungible Token holdings available
  // The number of microblocks available
  // The number of unanchored transactions available
  // The number of transactions available
  // 
  // The number of blocks available
  // The number of events available
  // The number of mint events available
  // The number of tokens metadata available
  Total int `json:"total"` // s:ff76d4e89b, f:e95fdf5e8ef75c306866
  _total_ValidationError error

}

// AddressBalanceResponse GET request that returns address balances
type AddressBalanceResponse struct {
  FungibleTokens map[string]interface{} `json:"fungible_tokens"` // s:dad2b509e1, f:09bf584dfe7df524df78
  _fungible_tokens_ValidationError error

  NonFungibleTokens map[string]interface{} `json:"non_fungible_tokens"` // s:4047018e22, f:d3fbd976f474723cb7ec
  _non_fungible_tokens_ValidationError error

  Stx *FtBalance_StxBalance `json:"stx"` // s:081498aef5, f:f626cc436fa0fcfc9999
  _stx_ValidationError error

  TokenOfferingLocked *AddressTokenOfferingLocked `json:"token_offering_locked,omitempty"` // s:daf64959f8, f:2aa8eb916f4be6aa6a3b
}

// AddressNftListResponse 
type AddressNftListResponse struct {
  Limit int `json:"limit"` // s:5c05cc5c4e, f:f3fbf5d5d6a77d91e63d
  _limit_ValidationError error

  NftEvents []*NftEvent `json:"nft_events"` // s:45d3c1be08, f:173797736dde74d07551
  _nft_events_ValidationError error

  Offset int `json:"offset"` // s:5d65991a91, f:4acba6c7c2579ea006b1
  _offset_ValidationError error

  Total int `json:"total"` // s:72284f0cb9, f:22bea27ba5e505348f75
  _total_ValidationError error

}

// AddressNonces The latest nonce values used by an account by inspecting the mempool, microblock transactions, and anchored transactions
type AddressNonces struct {

  // Nonces that appear to be missing and likely causing a mempool transaction to be stuck.
  DetectedMissingNonces []int `json:"detected_missing_nonces"` // s:582edf383d, f:d06c24a7dc775173312f
  _detected_missing_nonces_ValidationError error


  // The latest nonce found within transactions sent by this address, including unanchored microblock transactions. Will be null if there are no current transactions for this address.
  LastExecutedTxNonce int `json:"last_executed_tx_nonce"` // s:3dfffe3112, f:055692263aad294b2c67
  _last_executed_tx_nonce_ValidationError error


  // The latest nonce found within mempool transactions sent by this address. Will be null if there are no current mempool transactions for this address.
  LastMempoolTxNonce int `json:"last_mempool_tx_nonce"` // s:573e0ab8df, f:8378461ea5758d9304d6
  _last_mempool_tx_nonce_ValidationError error


  // The likely nonce required for creating the next transaction, based on the last nonces seen by the API. This can be incorrect if the API's mempool or transactions aren't fully synchronized, even by a small amount, or if a previous transaction is still propagating through the Stacks blockchain network when this endpoint is called.
  PossibleNextNonce int `json:"possible_next_nonce"` // s:efc945000d, f:63a138749b5ddb15511b
  _possible_next_nonce_ValidationError error

}

// AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult 
// Aliased for: AddressSearchResult, BlockSearchResult, BnsError, ContractSearchResult, MempoolTxSearchResult, SearchErrorResult, TransactionNotFound, TxSearchResult
type AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult struct {
  Error string `json:"error"` // s:a8e25630bd, f:25372ee326be77d05541
  _error_ValidationError error


  // Indicates if the requested object was found or not
  // 
  Found bool `json:"found"` // s:bd8505bfd5, f:d705c6b51ebccda9f17a
  _found_ValidationError error


  // 
  // This object carries the search result
  Result *Result_0f2d7b8436 `json:"result"` // s:0f2d7b8436, f:fd1685e32142eb050bdc
  _result_ValidationError error

}

// AddressTokenOfferingLocked Token Offering Locked
type AddressTokenOfferingLocked struct {

  // Micro-STX amount still locked at current block height.
  TotalLocked string `json:"total_locked"` // s:b2285522bb, f:353e17b02d18252be887
  _total_locked_ValidationError error


  // Micro-STX amount unlocked at current block height.
  TotalUnlocked string `json:"total_unlocked"` // s:a8d62ce2f6, f:2c57024ea8ee3da2a418
  _total_unlocked_ValidationError error

  UnlockSchedule []*AddressUnlockSchedule `json:"unlock_schedule"` // s:2976c0af91, f:bc6e8d34d4ae5ef3e27d
  _unlock_schedule_ValidationError error

}

// AddressTransactionWithTransfers Transaction with STX transfers for a given address
type AddressTransactionWithTransfers struct {
  FtTransfers []*FtTransfersItems `json:"ft_transfers,omitempty"` // s:ce78a34b64, f:a75cae3e1f3f636f313e
  NftTransfers []*NftTransfersItems `json:"nft_transfers,omitempty"` // s:ede956f3e7, f:d669d23f445eef96e10c

  // Total received by the given address in micro-STX as an integer string.
  StxReceived string `json:"stx_received"` // s:22b0fdc0fc, f:59402287ea1d73c4e36c
  _stx_received_ValidationError error


  // Total sent from the given address, including the tx fee, in micro-STX as an integer string.
  StxSent string `json:"stx_sent"` // s:569992b1ab, f:b035b1771cce0d90a565
  _stx_sent_ValidationError error

  StxTransfers []*StxTransfersItems `json:"stx_transfers"` // s:f6e9f44392, f:e9ce1a4408a996c282a6
  _stx_transfers_ValidationError error

  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"tx"` // s:2914f791da, f:f64b4fc71fa75250b4ea
  _tx_ValidationError error

}

// AddressUnlockSchedule_InboundStxTransfer 
// Aliased for: AddressUnlockSchedule, InboundStxTransfer
type AddressUnlockSchedule_InboundStxTransfer struct {

  // Transfer amount in micro-STX as integer string
  // Micro-STX amount locked at this block height.
  Amount string `json:"amount"` // s:1401d15cb6, f:263309468d3646721ed4
  _amount_ValidationError error


  // Block height at which this transfer occurred
  // 
  BlockHeight float64 `json:"block_height"` // s:2dc6e69142, f:ef7f450d5b9df3a45563
  _block_height_ValidationError error


  // Hex encoded memo bytes associated with the transfer
  Memo string `json:"memo"` // s:d7985cc857, f:e3fef6efed1c84eac115
  _memo_ValidationError error


  // Principal that sent this transfer
  Sender string `json:"sender"` // s:bbe26892e0, f:6f36ae20a89ec7724563
  _sender_ValidationError error


  // Indicates if the transfer is from a stx-transfer transaction or a contract-call transaction
  TransferType string `json:"transfer_type"` // s:09fe3dbbdd, f:15ec2b49dd59eff0e927
  _transfer_type_ValidationError error


  // The transaction ID in which this transfer occurred
  TxId string `json:"tx_id"` // s:b704d5cb57, f:ebece6e41fd168fe3895
  _tx_id_ValidationError error


  // Index of the transaction within a block
  TxIndex float64 `json:"tx_index"` // s:82c66301f1, f:8dab179aba4cdd3d1c5e
  _tx_index_ValidationError error

}

// Allow Allow specifies supported Operation status, Operation types, and all possible error statuses. This Allow object is used by clients to validate the correctness of a Rosetta Server implementation. It is expected that these clients will error if they receive some response that contains any of the above information that is not specified here.
type Allow struct {

  // All Errors that this implementation could return. Any error that is returned during parsing that is not listed here will cause client validation to error.
  Errors []*RosettaErrorNoDetails `json:"errors"` // s:004db05358, f:4175f771ca4ffb72d5b9
  _errors_ValidationError error


  // Any Rosetta implementation that supports querying the balance of an account at any height in the past should set this to true.
  HistoricalBalanceLookup bool `json:"historical_balance_lookup"` // s:8ac8fd341b, f:fcc71b81f37cae3af80c
  _historical_balance_lookup_ValidationError error


  // All Operation.Status this implementation supports. Any status that is returned during parsing that is not listed here will cause client validation to error.
  OperationStatuses []*RosettaOperationStatus `json:"operation_statuses"` // s:4760481f43, f:1a60f9507e141674f070
  _operation_statuses_ValidationError error


  // All Operation.Type this implementation supports. Any type that is returned during parsing that is not listed here will cause client validation to error.
  OperationTypes []interface{} `json:"operation_types"` // s:e8413c41c9, f:92956b9b079cf5ede456
  _operation_types_ValidationError error

}

// BaseTransaction Transaction properties that are available from a raw serialized transactions. These are available for transactions in the mempool as well as mined transactions.
type BaseTransaction struct {
  AnchorMode string `json:"anchor_mode"` // s:f3b2e010e5, f:102bd0120fe4cc93be7e
  _anchor_mode_ValidationError error


  // Transaction fee as Integer string (64-bit unsigned integer).
  FeeRate string `json:"fee_rate"` // s:efe4c59b15, f:a99ad2f7ac7b94216062
  _fee_rate_ValidationError error


  // Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
  Nonce int `json:"nonce"` // s:1981f5f3a8, f:441843cd30c2e735f5f0
  _nonce_ValidationError error

  PostConditionMode string `json:"post_condition_mode"` // s:04bfa9489b, f:0f592f5d911dd1e50022
  _post_condition_mode_ValidationError error

  PostConditions []interface{} `json:"post_conditions"` // s:6a46affebb, f:fc85b5480a8450c32056
  _post_conditions_ValidationError error


  // Address of the transaction initiator
  SenderAddress string `json:"sender_address"` // s:45d4c2dd92, f:9ed557e985d8866e975d
  _sender_address_ValidationError error

  SponsorAddress string `json:"sponsor_address,omitempty"` // s:1938be7d71, f:1bc746a32156cbd91538
  SponsorNonce int `json:"sponsor_nonce,omitempty"` // s:6da775521c, f:9bef945a51e40af83db1

  // Denotes whether the originating account is the same as the paying account
  Sponsored bool `json:"sponsored"` // s:9b77722f84, f:e80bc7861ca3242d1e1c
  _sponsored_ValidationError error


  // Transaction ID
  TxId string `json:"tx_id"` // s:3c2cf6357d, f:e57ed417a7c40dfdf510
  _tx_id_ValidationError error

}

// BlockData Returns basic search result information about the requested id
type BlockData struct {
  BurnBlockTime int `json:"burn_block_time"` // s:2cc6a6891b, f:b290d48c43ffe324f886
  _burn_block_time_ValidationError error


  // If the block lies within the canonical chain
  Canonical bool `json:"canonical"` // s:66c1f26b39, f:a2efcc29a530e980eda9
  _canonical_ValidationError error


  // Refers to the hash of the block
  Hash string `json:"hash"` // s:f8fc3bf545, f:3a63c51a2430ff54faaa
  _hash_ValidationError error

  Height int `json:"height"` // s:8d914f4f86, f:9e90a0e066088a773660
  _height_ValidationError error

  ParentBlockHash string `json:"parent_block_hash"` // s:5599fdaa85, f:26cfe8132d6452fb6fa9
  _parent_block_hash_ValidationError error

}

// Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier 
// Aliased for: Block, OtherTransactionIdentifier, RosettaBlockIdentifierHash, TransactionIdentifier
type Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier struct {

  // Hash of the anchor chain block
  BurnBlockHash string `json:"burn_block_hash"` // s:f75672656c, f:d89c33370a7b9cd67ba2
  _burn_block_hash_ValidationError error


  // Height of the anchor chain block
  BurnBlockHeight int `json:"burn_block_height"` // s:5987dda41c, f:f604f4b41e18112c7a67
  _burn_block_height_ValidationError error


  // Unix timestamp (in seconds) indicating when this block was mined.
  BurnBlockTime float64 `json:"burn_block_time"` // s:388d64356a, f:d423b981d4a5d3041214
  _burn_block_time_ValidationError error


  // An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
  BurnBlockTimeIso string `json:"burn_block_time_iso"` // s:f0f2286c51, f:80709506df254cf86609
  _burn_block_time_iso_ValidationError error


  // Set to `true` if block corresponds to the canonical chain tip
  Canonical bool `json:"canonical"` // s:f529fe38d6, f:86dae79d8deead69aded
  _canonical_ValidationError error


  // Execution cost read count.
  ExecutionCostReadCount int `json:"execution_cost_read_count"` // s:f96302fd26, f:1a3dd50c7e838e82d6a8
  _execution_cost_read_count_ValidationError error


  // Execution cost read length.
  ExecutionCostReadLength int `json:"execution_cost_read_length"` // s:e77bbdbac1, f:52d9b45ae1b9fbf0bd66
  _execution_cost_read_length_ValidationError error


  // Execution cost runtime.
  ExecutionCostRuntime int `json:"execution_cost_runtime"` // s:3eaad3872b, f:212e38bc294ea731a4b4
  _execution_cost_runtime_ValidationError error


  // Execution cost write count.
  ExecutionCostWriteCount int `json:"execution_cost_write_count"` // s:7229989ef9, f:300a7654ed5487063ccb
  _execution_cost_write_count_ValidationError error


  // Execution cost write length.
  ExecutionCostWriteLength int `json:"execution_cost_write_length"` // s:16da456ffa, f:b53aa36c4c1d0adc7b60
  _execution_cost_write_length_ValidationError error


  // Hash representing the block
  // Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
  // This is also known as the block hash.
  Hash string `json:"hash"` // s:e4a3c396f0, f:b07473331365b021218a
  _hash_ValidationError error


  // Height of the block
  Height int `json:"height"` // s:0944a63300, f:2b37abd687bf12208b58
  _height_ValidationError error


  // List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
  MicroblocksAccepted []string `json:"microblocks_accepted"` // s:0851bd99c7, f:e14e064de2ac4db95430
  _microblocks_accepted_ValidationError error


  // List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
  MicroblocksStreamed []string `json:"microblocks_streamed"` // s:b3539e122e, f:c6a974045415eae62e68
  _microblocks_streamed_ValidationError error


  // Anchor chain transaction ID
  MinerTxid string `json:"miner_txid"` // s:66d21057a5, f:056770b61e71a870dd7b
  _miner_txid_ValidationError error


  // Hash of the parent block
  ParentBlockHash string `json:"parent_block_hash"` // s:e8ff0e73a4, f:ef7a409b6f25278461f4
  _parent_block_hash_ValidationError error


  // The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
  ParentMicroblockHash string `json:"parent_microblock_hash"` // s:47a882dc0e, f:7ef80a9e3aa0eca2a43a
  _parent_microblock_hash_ValidationError error


  // The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
  ParentMicroblockSequence int `json:"parent_microblock_sequence"` // s:4130d25575, f:c22bc8484820772c95b3
  _parent_microblock_sequence_ValidationError error


  // List of transactions included in the block
  Txs []string `json:"txs"` // s:af101e83fc, f:66ce01e46939bf2bf0db
  _txs_ValidationError error

}

// BnsGetAllNamespacesResponse Fetch a list of all namespaces known to the node.
type BnsGetAllNamespacesResponse struct {
  Namespaces []string `json:"namespaces"` // s:1604f7a992, f:d21bd64629005c56be1c
  _namespaces_ValidationError error

}

// BnsGetNameInfoResponse Get name details
type BnsGetNameInfoResponse struct {
  Address string `json:"address"` // s:e82ff9e6ec, f:4176d0b5719a045cdb3c
  _address_ValidationError error

  Blockchain string `json:"blockchain"` // s:5b374d9c8c, f:d1c6c9a33f49e87cbcfb
  _blockchain_ValidationError error

  ExpireBlock int `json:"expire_block,omitempty"` // s:92c61957f0, f:90e62679003ab27a60d2
  GracePeriod int `json:"grace_period,omitempty"` // s:823a5acdd6, f:21936c7cbffaf5c254bb
  LastTxid string `json:"last_txid"` // s:c8d19ff584, f:24329910da542bcfee33
  _last_txid_ValidationError error

  Resolver string `json:"resolver,omitempty"` // s:27a5cd022f, f:bb7f40fea03aae6f13ac
  Status string `json:"status"` // s:4c5fec274d, f:b5739a2f94d90bb927c8
  _status_ValidationError error

  Zonefile string `json:"zonefile"` // s:a84b540349, f:b85c668c596bb4b831c8
  _zonefile_ValidationError error

  ZonefileHash string `json:"zonefile_hash"` // s:08f33292b1, f:a92a7b7478b597ef6af3
  _zonefile_hash_ValidationError error

}

// BnsGetNamePriceResponse_BnsGetNamespacePriceResponse 
// Aliased for: BnsGetNamePriceResponse, BnsGetNamespacePriceResponse
type BnsGetNamePriceResponse_BnsGetNamespacePriceResponse struct {
  Amount string `json:"amount"` // s:0206644239, f:bc299411ac050d5f93e8
  _amount_ValidationError error

  Units string `json:"units"` // s:5a98c70dad, f:1b17c375dfe9789b1a4e
  _units_ValidationError error

}

// BnsGetSubdomainAtTxItems 
type BnsGetSubdomainAtTxItems struct {
  Accepted int `json:"accepted,omitempty"` // s:a4254a7b04, f:6c49b33ea20915284998
  BlockHeight int `json:"block_height,omitempty"` // s:e31e6ed1e8, f:b1479fb798eef46fe866
  Domain string `json:"domain,omitempty"` // s:7f891867c0, f:b0e64e57b812e4ffc711
  FullyQualifiedSubdomain string `json:"fully_qualified_subdomain,omitempty"` // s:7d057e6f6e, f:7b7679915fc95cf85704
  Missing string `json:"missing,omitempty"` // s:aea03c3c96, f:11cbe256f10370978e97
  Owner string `json:"owner,omitempty"` // s:535cf0d9e4, f:95116a6076aff0b4a04f
  ParentZonefileHash string `json:"parent_zonefile_hash,omitempty"` // s:676e04c323, f:5b7db63c2d0ce1f63fc3
  ParentZonefileIndex int `json:"parent_zonefile_index,omitempty"` // s:d425a1146c, f:77208080d38032f3d9a2
  Resolver string `json:"resolver,omitempty"` // s:c2b4819297, f:fb51554dbdc2b775cd0f
  Sequence int `json:"sequence,omitempty"` // s:1054848f41, f:b1954d5381d6fa7e084c
  Signature string `json:"signature,omitempty"` // s:af1c1b30a8, f:1e26db8aef873fb70267
  Txid string `json:"txid,omitempty"` // s:f7b32f33a5, f:f9baa09b27201be92a4a
  ZonefileHash string `json:"zonefile_hash,omitempty"` // s:1b3867c67f, f:e9c647f0a8c02da5e9a5
  ZonefileOffset int `json:"zonefile_offset,omitempty"` // s:30fd165f5b, f:77725785a44187fef549
}

// BnsNamesOwnByAddressResponse Retrieves a list of names owned by the address provided.
type BnsNamesOwnByAddressResponse struct {
  Names []string `json:"names"` // s:688e7069e7, f:1e3c74b97e8b13438050
  _names_ValidationError error

}

// BurnchainRewardSlotHolder Reward slot holder on the burnchain
type BurnchainRewardSlotHolder struct {

  // The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
  Address string `json:"address"` // s:76b3cdd107, f:a7af96f55703980fddca
  _address_ValidationError error


  // The hash representing the burnchain block
  BurnBlockHash string `json:"burn_block_hash"` // s:5c1481cb15, f:6154979d4d56cc200ac2
  _burn_block_hash_ValidationError error


  // Height of the burnchain block
  BurnBlockHeight int `json:"burn_block_height"` // s:4678546d06, f:617f716173e4342e4d40
  _burn_block_height_ValidationError error


  // Set to `true` if block corresponds to the canonical burchchain tip
  Canonical bool `json:"canonical"` // s:046b20269c, f:0a89c07376ee50ca721b
  _canonical_ValidationError error


  // The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
  SlotIndex int `json:"slot_index"` // s:fbb06b5f73, f:cd791b310952cd8a543f
  _slot_index_ValidationError error

}

// BurnchainReward_BurnchainRewardsTotal 
// Aliased for: BurnchainReward, BurnchainRewardsTotal
type BurnchainReward_BurnchainRewardsTotal struct {

  // The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
  BurnAmount string `json:"burn_amount"` // s:4db31b3dfa, f:ca119514f2827600f728
  _burn_amount_ValidationError error


  // The hash representing the burnchain block
  BurnBlockHash string `json:"burn_block_hash"` // s:c4bc523816, f:34212f66a383cad8b95a
  _burn_block_hash_ValidationError error


  // Height of the burnchain block
  BurnBlockHeight int `json:"burn_block_height"` // s:75b7e2fc61, f:514e5ff3808a0208491c
  _burn_block_height_ValidationError error


  // Set to `true` if block corresponds to the canonical burchchain tip
  Canonical bool `json:"canonical"` // s:402c9f8f16, f:840aea43f53e6ab784f5
  _canonical_ValidationError error


  // The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
  // The total amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
  RewardAmount string `json:"reward_amount"` // s:ce816cb6fb, f:33eebeaaedd78bb77610
  _reward_amount_ValidationError error


  // The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
  RewardIndex int `json:"reward_index"` // s:27b0321129, f:d2d81f52a894d5b4840a
  _reward_index_ValidationError error


  // The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
  RewardRecipient string `json:"reward_recipient"` // s:97668c26ce, f:c876c43bc6d88615c464
  _reward_recipient_ValidationError error

}

// ChainTip Current chain tip information
type ChainTip struct {

  // the current block hash
  BlockHash string `json:"block_hash"` // s:6d26d7afe3, f:300001a679b2e1750597
  _block_hash_ValidationError error


  // the current block height
  BlockHeight int `json:"block_height"` // s:8f9ad2dfe0, f:adcadd86d25184bc45c6
  _block_height_ValidationError error


  // the current index block hash
  IndexBlockHash string `json:"index_block_hash"` // s:4fc1175198, f:ba411190ed22c730e423
  _index_block_hash_ValidationError error


  // the current microblock hash
  MicroblockHash string `json:"microblock_hash,omitempty"` // s:bb149578de, f:68f2895dde0ca16fffb0

  // the current microblock sequence number
  MicroblockSequence int `json:"microblock_sequence,omitempty"` // s:056e6b6f3f, f:a6c18ed66c379d849b06
}

// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
type CoinIdentifier struct {

  // Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
  Identifier string `json:"identifier"` // s:ab0b264ec6, f:a1d6772d352b3d537865
  _identifier_ValidationError error

}

// CoinbasePayload 
type CoinbasePayload struct {

  // Hex encoded 32-byte scratch space for block leader's use
  Data string `json:"data"` // s:fc0fc9a892, f:fc21ad5c1e2b7a3ed7e2
  _data_ValidationError error

}

// CoinbaseTransactionMetadata Describes representation of a Type 3 Stacks 2.0 transaction: Poison Microblock
type CoinbaseTransactionMetadata struct {
  CoinbasePayload *CoinbasePayload `json:"coinbase_payload"` // s:c017b5e349, f:07725d6fe04c485ec7a0
  _coinbase_payload_ValidationError error

  TxType string `json:"tx_type"` // s:8cf3ccc101, f:194dad4662a725129bc0
  _tx_type_ValidationError error

}

// ContractCall 
type ContractCall struct {

  // Contract identifier formatted as `<principaladdress>.<contract_name>`
  ContractId string `json:"contract_id"` // s:53e88d7a8f, f:429f3f17522f8a112452
  _contract_id_ValidationError error


  // List of arguments used to invoke the function
  FunctionArgs []*FunctionArgsItems `json:"function_args,omitempty"` // s:369be129f2, f:0062841d7def47709d82

  // Name of the Clarity function to be invoked
  FunctionName string `json:"function_name"` // s:3190bdbdbb, f:f7868acecc686d731adc
  _function_name_ValidationError error


  // Function definition, including function name and type as well as parameter names and types
  FunctionSignature string `json:"function_signature"` // s:31516731bb, f:4ce1c74b261b421be91e
  _function_signature_ValidationError error

}

// ContractCallTransactionMetadata Metadata associated with a contract-call type transaction
type ContractCallTransactionMetadata struct {
  ContractCall *ContractCall `json:"contract_call"` // s:a81489ce1f, f:dee2d72754d6f70523be
  _contract_call_ValidationError error

  TxType string `json:"tx_type"` // s:7553d875b6, f:4651ecceb77eef862350
  _tx_type_ValidationError error

}

// ContractInterfaceResponse GET request to get contract interface
type ContractInterfaceResponse struct {

  // List of defined methods
  Functions []*FunctionsItems `json:"functions"` // s:69760e3a09, f:6cde18f07f6b40a9a6c9
  _functions_ValidationError error


  // List of fungible tokens in the contract
  FungibleTokens []*FungibleTokensItems `json:"fungible_tokens"` // s:d4b208f324, f:94b9ee13712a5dc8c579
  _fungible_tokens_ValidationError error


  // List of defined data-maps
  Maps []*MapsItems `json:"maps"` // s:6d1f413da4, f:672a29b5cd8d84ea5191
  _maps_ValidationError error


  // List of non-fungible tokens in the contract
  NonFungibleTokens []*NonFungibleTokensItems `json:"non_fungible_tokens"` // s:26ba358f27, f:b11f620f45791f1eab12
  _non_fungible_tokens_ValidationError error


  // List of defined variables
  Variables []*VariablesItems `json:"variables"` // s:b65a5fa116, f:2bc4041d2a010d8587f1
  _variables_ValidationError error

}

// ContractSourceResponse GET request to get contract source
type ContractSourceResponse struct {
  Proof string `json:"proof"` // s:4dc346d624, f:e65852082f82ab550a98
  _proof_ValidationError error

  PublishHeight int `json:"publish_height"` // s:57bef6dd77, f:6dedc9eed041eca62ee2
  _publish_height_ValidationError error

  Source string `json:"source"` // s:27ecaf880c, f:9f55b86cbb0fd7cbfe7c
  _source_ValidationError error

}

// CoreNodeInfoResponse GET request that core node information
type CoreNodeInfoResponse struct {

  // latest bitcoin chain height
  BurnBlockHeight int `json:"burn_block_height"` // s:a7e25e85f8, f:590ea60ec0a39f0915bf
  _burn_block_height_ValidationError error


  // the block height at which the testnet network will be reset. not applicable for mainnet
  ExitAtBlockHeight int `json:"exit_at_block_height"` // s:02cdccc6a0, f:623445424a64f40549b2
  _exit_at_block_height_ValidationError error


  // is similar to peer_version and will be used to differentiate between different testnets. this value will be different between mainnet and testnet. once launched, this value will not change
  NetworkId int `json:"network_id"` // s:c431ea4ec6, f:fe55e6321f366a0dbee0
  _network_id_ValidationError error


  // same as network_id, but for bitcoin
  ParentNetworkId int `json:"parent_network_id"` // s:3aef585492, f:b50096be67ee62afa9ee
  _parent_network_id_ValidationError error


  // identifies the version number for the networking communication, this should not change while a node is running, and will only change if there's an upgrade
  PeerVersion int `json:"peer_version"` // s:5ea5e1c8c7, f:3d00396b1e691eb8b167
  _peer_version_ValidationError error


  // is a hash used to identify the burnchain view for a node. it incorporates bitcoin chain information and PoX information. nodes that disagree on this value will appear to each other as forks. this value will change after every block
  PoxConsensus string `json:"pox_consensus"` // s:2be7096e52, f:a41cc1d0f94cc513b91f
  _pox_consensus_ValidationError error


  // is a version descriptor
  ServerVersion string `json:"server_version"` // s:64af396ba5, f:66cf44a8deca97fbf3dd
  _server_version_ValidationError error


  // leftover from stacks 1.0, basically always burn_block_height - 1
  StableBurnBlockHeight int `json:"stable_burn_block_height"` // s:e0f1750d30, f:6f4589b55e85a60f54f6
  _stable_burn_block_height_ValidationError error


  // same as burn_consensus, but evaluated at stable_burn_block_height
  StablePoxConsensus string `json:"stable_pox_consensus"` // s:b627699973, f:b8843822a7a7e52da639
  _stable_pox_consensus_ValidationError error


  // the best known block hash for the Stack chain (not including any pending microblocks)
  StacksTip string `json:"stacks_tip"` // s:1d2bb81c79, f:9c23c210171902c72486
  _stacks_tip_ValidationError error


  // the burn chain (i.e., bitcoin) consensus hash at the time that stacks_tip was mined
  StacksTipConsensusHash string `json:"stacks_tip_consensus_hash"` // s:3e4da38361, f:779da4851b82a17104de
  _stacks_tip_consensus_hash_ValidationError error


  // the latest Stacks chain height. Stacks forks can occur independent of the Bitcoin chain, that height doesn't increase 1-to-1 with the Bitcoin height
  StacksTipHeight int `json:"stacks_tip_height"` // s:97fd03ad7a, f:eda61e4d11143f747d7c
  _stacks_tip_height_ValidationError error


  // the latest microblock hash if any microblocks were processed. if no microblock has been processed for the current block, a 000.., hex array is returned
  UnanchoredTip string `json:"unanchored_tip"` // s:a43cb04f5a, f:ef37d134c8e0a36964ba
  _unanchored_tip_ValidationError error

}

// CoreNodePoxResponse Get Proof of Transfer (PoX) information
type CoreNodePoxResponse struct {
  ContractId string `json:"contract_id"` // s:23a909ae7a, f:bd53a23d662ec6b68680
  _contract_id_ValidationError error

  FirstBurnchainBlockHeight int `json:"first_burnchain_block_height"` // s:9ef32c353d, f:1a94f461d41fdfc62bb1
  _first_burnchain_block_height_ValidationError error

  MinAmountUstx int `json:"min_amount_ustx"` // s:49e2a2e6a5, f:3762dbffdca5c7bfb037
  _min_amount_ustx_ValidationError error

  RegistrationWindowLength int `json:"registration_window_length"` // s:f4a3d23c21, f:9d557b06428c6c785587
  _registration_window_length_ValidationError error

  RejectionFraction int `json:"rejection_fraction"` // s:5afb2e2886, f:a4ac067d77984fac6396
  _rejection_fraction_ValidationError error

  RejectionVotesLeftRequired int `json:"rejection_votes_left_required"` // s:1c97afbd7a, f:92980a4530324ac5b7a3
  _rejection_votes_left_required_ValidationError error

  RewardCycleId int `json:"reward_cycle_id"` // s:87fe5dc965, f:74856e32e89239aee14e
  _reward_cycle_id_ValidationError error

  RewardCycleLength int `json:"reward_cycle_length"` // s:8490b98abb, f:fe2125ed03b2f32d227b
  _reward_cycle_length_ValidationError error

  TotalLiquidSupplyUstx int `json:"total_liquid_supply_ustx"` // s:2d1e0ebfa5, f:f7b070de36f3a9ed9780
  _total_liquid_supply_ustx_ValidationError error

}

// Details Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
type Details struct {
  Address string `json:"address,omitempty"` // s:f7f51bbc53, f:f2fdd3b95afefbd861b2
  Error string `json:"error,omitempty"` // s:f4ce79e78a, f:4987d9aceee59c0b58fb
}

// EstimatedCost 
type EstimatedCost struct {
  ReadCount int `json:"read_count"` // s:b262febc47, f:aca226a7f457debbe35d
  _read_count_ValidationError error

  ReadLength int `json:"read_length"` // s:7185326e2d, f:77580ac6fe0e2241b42c
  _read_length_ValidationError error

  Runtime int `json:"runtime"` // s:8da71de453, f:1e1f881617e46f6b81af
  _runtime_ValidationError error

  WriteCount int `json:"write_count"` // s:d18b51e78c, f:41728acce76783938240
  _write_count_ValidationError error

  WriteLength int `json:"write_length"` // s:b8fe2068a6, f:dbec3cc64805480e5a6a
  _write_length_ValidationError error

}

// EstimationsItems 
type EstimationsItems struct {
  Fee float64 `json:"fee,omitempty"` // s:34a7758e7c, f:3ad9d58bb972f7947fec
  FeeRate float64 `json:"fee_rate,omitempty"` // s:525faa2367, f:622de648aea71894c82d
}

// FeeRate Get fee rate information.
type FeeRate struct {
  FeeRate int `json:"fee_rate"` // s:02fdf992a3, f:ade9396320bace52c956
  _fee_rate_ValidationError error

}

// FeeRateRequest_RosettaConstructionParseRequest 
// Aliased for: FeeRateRequest, RosettaConstructionParseRequest
type FeeRateRequest_RosettaConstructionParseRequest struct {
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:888ef0659a66460ab01d
  _network_identifier_ValidationError error


  // Signed is a boolean indicating whether the transaction is signed.
  Signed bool `json:"signed"` // s:36dd3b8c84, f:be249b4fdb6a3c089d34
  _signed_ValidationError error


  // This must be either the unsigned transaction blob returned by /construction/payloads or the signed transaction blob returned by /construction/combine.
  // A serialized transaction
  Transaction string `json:"transaction"` // s:a09aa2df18, f:10d75ab03e5f812fccf3
  _transaction_ValidationError error

}

// FtBalance_StxBalance 
// Aliased for: FtBalance, StxBalance
type FtBalance_StxBalance struct {
  Balance string `json:"balance"` // s:14cd987a4a, f:7afa6edd10845381f4fb
  _balance_ValidationError error


  // The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
  BurnchainLockHeight int `json:"burnchain_lock_height"` // s:ac0891561c, f:0833d2db8c11dfa5d2db
  _burnchain_lock_height_ValidationError error


  // The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
  BurnchainUnlockHeight int `json:"burnchain_unlock_height"` // s:ade9c71a85, f:19fc8c7f2f932d8a4c8d
  _burnchain_unlock_height_ValidationError error


  // The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
  LockHeight int `json:"lock_height"` // s:80395c47d4, f:fb76ca02860865e805de
  _lock_height_ValidationError error


  // The transaction where the lock event occurred. Empty if no tokens are locked.
  LockTxId string `json:"lock_tx_id"` // s:5d4f5324e0, f:8a6e483d172413a33296
  _lock_tx_id_ValidationError error


  // The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
  Locked string `json:"locked"` // s:5b303a8ccd, f:4f805551b721c075c36d
  _locked_ValidationError error

  TotalFeesSent string `json:"total_fees_sent"` // s:04075af3b1, f:ea4a5cc617e71974815e
  _total_fees_sent_ValidationError error

  TotalMinerRewardsReceived string `json:"total_miner_rewards_received"` // s:3bfbc06d7c, f:81d08f780be18a2ff543
  _total_miner_rewards_received_ValidationError error

  TotalReceived string `json:"total_received"` // s:425c21073f, f:4d9873058f95387d0c31
  _total_received_ValidationError error

  TotalSent string `json:"total_sent"` // s:6fb30902bf, f:5b9d0bb93c2325ea1a1a
  _total_sent_ValidationError error

}

// FtTransfersItems 
type FtTransfersItems struct {

  // Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
  Amount string `json:"amount"` // s:1b76d91c55, f:47db6e4d8d6bfd49a5b7
  _amount_ValidationError error


  // Fungible Token asset identifier.
  AssetIdentifier string `json:"asset_identifier"` // s:55dbfad884, f:b7daec04c832f1c0087a
  _asset_identifier_ValidationError error


  // Principal that received the asset.
  Recipient string `json:"recipient,omitempty"` // s:4c94b7c26f, f:bff0bb433e8a2d5bb3b1

  // Principal that sent the asset.
  Sender string `json:"sender,omitempty"` // s:e99240ac0e, f:4da9bc8f4e9b8adc9f84
}

// FunctionArgsItems 
type FunctionArgsItems struct {
  Hex string `json:"hex"` // s:eae442ead7, f:714f1b33d1e1211f7570
  _hex_ValidationError error

  Name string `json:"name"` // s:f34db928c1, f:f81de5e1b4bfc9d643a4
  _name_ValidationError error

  Repr string `json:"repr"` // s:f85dbb0d02, f:c2a913c293f4050e0e26
  _repr_ValidationError error

  Type string `json:"type"` // s:6a97e9ad04, f:94452a552c13f5c962fd
  _type_ValidationError error

}

// FunctionsItems 
type FunctionsItems struct {
}

// FungibleTokenMetadata_NonFungibleTokenMetadata 
// Aliased for: FungibleTokenMetadata, NonFungibleTokenMetadata
type FungibleTokenMetadata_NonFungibleTokenMetadata struct {

  // The number of decimal places in a token.
  Decimals float64 `json:"decimals"` // s:d8b17205f5, f:e411cbfd64276470f878
  _decimals_ValidationError error


  // Describes the asset to which this token represents
  Description string `json:"description"` // s:4f60ecb642, f:b9453e0abac900c9c502
  _description_ValidationError error


  // The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
  ImageCanonicalUri string `json:"image_canonical_uri"` // s:8cb892be8c, f:1993aa2bcf4c8e0273cf
  _image_canonical_uri_ValidationError error


  // A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
  ImageUri string `json:"image_uri"` // s:83fc4c39b1, f:08c6dd2c7a992cfeec57
  _image_uri_ValidationError error


  // Identifies the asset to which this token represents
  Name string `json:"name"` // s:27e709b60b, f:43a730c2df394cb1798d
  _name_ValidationError error


  // principle that deployed the contract
  SenderAddress string `json:"sender_address"` // s:e8d388311e, f:db7558a10fdd06355d44
  _sender_address_ValidationError error


  // A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
  Symbol string `json:"symbol"` // s:7af726d94b, f:8dd70b2229d6ed3744a5
  _symbol_ValidationError error


  // An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
  TokenUri string `json:"token_uri"` // s:01ae55ae73, f:4809fe4c7afb19dc307a
  _token_uri_ValidationError error


  // Tx id that deployed the contract
  TxId string `json:"tx_id"` // s:049e24099c, f:4a791302d11b25f3ec66
  _tx_id_ValidationError error

}

// FungibleTokensItems 
type FungibleTokensItems struct {
}

// GetRawTransactionResult GET raw transaction
type GetRawTransactionResult struct {

  // A hex encoded serialized transaction
  RawTx string `json:"raw_tx"` // s:12f6cdab87, f:b6eb710ee3489fc5f6d4
  _raw_tx_ValidationError error

}

// GetStxSupplyLegacyFormatResponse GET request that returns network target block times
type GetStxSupplyLegacyFormatResponse struct {

  // The block height at which this information was queried
  BlockHeight string `json:"blockHeight"` // s:7ff7d3db73, f:4d2cf2926d0db411c379
  _blockHeight_ValidationError error


  // String quoted decimal number of the total possible number of STX
  TotalStacks string `json:"totalStacks"` // s:d7b1898b6f, f:26f6efc1aa68e9fc1822
  _totalStacks_ValidationError error


  // Same as `totalStacks` but formatted with comma thousands separators
  TotalStacksFormatted string `json:"totalStacksFormatted"` // s:afdc41fde6, f:be0bab39983748a89f42
  _totalStacksFormatted_ValidationError error


  // String quoted decimal number of the percentage of STX that have unlocked
  UnlockedPercent string `json:"unlockedPercent"` // s:081bd7d82d, f:9db30fbc96252f7ba7c7
  _unlockedPercent_ValidationError error


  // String quoted decimal number of the STX that have been mined or unlocked
  UnlockedSupply string `json:"unlockedSupply"` // s:e31dcb0981, f:46648bbffcba0c176ce8
  _unlockedSupply_ValidationError error


  // Same as `unlockedSupply` but formatted with comma thousands separators
  UnlockedSupplyFormatted string `json:"unlockedSupplyFormatted"` // s:b4e551cfe2, f:1cf6a83369590cae36ea
  _unlockedSupplyFormatted_ValidationError error

}

// GetStxSupplyResponse GET request that returns network target block times
type GetStxSupplyResponse struct {

  // The block height at which this information was queried
  BlockHeight int `json:"block_height"` // s:2edc7d87fd, f:4bd5cc87bf7286817d54
  _block_height_ValidationError error


  // String quoted decimal number of the total possible number of STX
  TotalStx string `json:"total_stx"` // s:fbbe66256d, f:9c726b2fb45acb2dcecf
  _total_stx_ValidationError error


  // String quoted decimal number of the percentage of STX that have unlocked
  UnlockedPercent string `json:"unlocked_percent"` // s:c4c4b904c5, f:d801593d35ed1b603e40
  _unlocked_percent_ValidationError error


  // String quoted decimal number of the STX that have been mined or unlocked
  UnlockedStx string `json:"unlocked_stx"` // s:4ff7033099, f:af11835f467a35282e44
  _unlocked_stx_ValidationError error

}

// MapEntryResponse Response of get data map entry request
type MapEntryResponse struct {

  // Hex-encoded string of clarity value. It is always an optional tuple.
  Data string `json:"data"` // s:b2fe49329d, f:e44484f3029d9c50ee3a
  _data_ValidationError error


  // Hex-encoded string of the MARF proof for the data
  Proof string `json:"proof,omitempty"` // s:73c60cdeec, f:b0375bd8073daed4417a
}

// MapsItems 
type MapsItems struct {
}

// Metadata Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
type Metadata struct {
  SequenceNumber int `json:"sequence_number"` // s:4c3d005598, f:b6eaa849dd3b4be7ae00
  _sequence_number_ValidationError error

}

// Metadata_19e9556a06 
type Metadata_19e9556a06 struct {
  AccountSequence int `json:"account_sequence,omitempty"` // s:5e87e90d95, f:47da8d49e126fa3ebdf3
  RecentBlockHash string `json:"recent_block_hash,omitempty"` // s:0a73c89a43, f:84eb4a74ebe4baae1999
}

// Metadata_31438643c8 Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
type Metadata_31438643c8 struct {

  // The locktime
  LockTime int `json:"lockTime,omitempty"` // s:b0e3a137eb, f:a533bd5b1f04ff209a91

  // STX token transfer memo.
  Memo string `json:"memo,omitempty"` // s:448830d55b, f:fd5831b8101db1609ed8

  // The Size
  Size int `json:"size,omitempty"` // s:8dc0c3c4ec, f:a02096ecebeb6c36fd85
}

// Metadata_7cedba8711 Meta data from subnetwork identifier
type Metadata_7cedba8711 struct {

  // producer
  Producer string `json:"producer"` // s:e13db5c5d5, f:c6c806c68a8f31493855
  _producer_ValidationError error

}

// Metadata_8cb828c26a meta data
type Metadata_8cb828c26a struct {
  Difficulty string `json:"difficulty"` // s:e1ed19a376, f:fa38982c4d710f1adc61
  _difficulty_ValidationError error

  TransactionsRoot string `json:"transactions_root"` // s:f55c7f5314, f:0f3b6cf4488a76146fdc
  _transactions_root_ValidationError error

}

// Microblock A microblock
type Microblock struct {

  // The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
  BlockHash string `json:"block_hash"` // s:d2a9a9cd15, f:c7ab4984f1ba1397fa9d
  _block_hash_ValidationError error


  // The anchor block height that confirmed this microblock.
  BlockHeight int `json:"block_height"` // s:d5f8c37f46, f:56bda138f449002f3002
  _block_height_ValidationError error


  // Set to `true` if the microblock corresponds to the canonical chain tip.
  Canonical bool `json:"canonical"` // s:072a857c83, f:824bd1a875b5fce218cd
  _canonical_ValidationError error


  // Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
  MicroblockCanonical bool `json:"microblock_canonical"` // s:1bfc5b29c9, f:c80c879457af2cfb2d0e
  _microblock_canonical_ValidationError error


  // The SHA512/256 hash of this microblock.
  MicroblockHash string `json:"microblock_hash"` // s:0e4fca1a96, f:f1c0747aff6e3bf4d92c
  _microblock_hash_ValidationError error


  // The SHA512/256 hash of the previous signed microblock in this stream.
  MicroblockParentHash string `json:"microblock_parent_hash"` // s:dec30ebd12, f:50f9c03e38fe3ca4e38e
  _microblock_parent_hash_ValidationError error


  // A hint to describe how to order a set of microblocks. Starts at 0.
  MicroblockSequence int `json:"microblock_sequence"` // s:059f2b9ef8, f:cae059f87dd0bdd5b52c
  _microblock_sequence_ValidationError error


  // The hash of the anchor block that preceded this microblock.
  ParentBlockHash string `json:"parent_block_hash"` // s:ce072a42d8, f:37fbcc4e8bac932b069c
  _parent_block_hash_ValidationError error


  // The height of the anchor block that preceded this microblock.
  ParentBlockHeight int `json:"parent_block_height"` // s:682d8f35eb, f:7210073d4017ec573e5d
  _parent_block_height_ValidationError error


  // The hash of the Bitcoin block that preceded this microblock.
  ParentBurnBlockHash string `json:"parent_burn_block_hash"` // s:dc3fb9b34a, f:254574ab8755ce48296f
  _parent_burn_block_hash_ValidationError error


  // The height of the Bitcoin block that preceded this microblock.
  ParentBurnBlockHeight int `json:"parent_burn_block_height"` // s:18ee7fab88, f:530f0ebe2200ffb18525
  _parent_burn_block_height_ValidationError error


  // The block timestamp of the Bitcoin block that preceded this microblock.
  ParentBurnBlockTime int `json:"parent_burn_block_time"` // s:48bfa9874f, f:10071f4d86b7be64f5f6
  _parent_burn_block_time_ValidationError error


  // The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
  ParentBurnBlockTimeIso string `json:"parent_burn_block_time_iso"` // s:a099637bef, f:ff399dd4fa19c26176c8
  _parent_burn_block_time_iso_ValidationError error


  // List of transactions included in the microblock
  Txs []string `json:"txs"` // s:72df85dedb, f:5002b2230ad6e8dd83a8
  _txs_ValidationError error

}

// NetworkBlockTimesResponse GET request that returns network target block times
type NetworkBlockTimesResponse struct {
  Mainnet *TargetBlockTime `json:"mainnet"` // s:44295b20a0, f:3661bb7ddcbbbfe0e3e2
  _mainnet_ValidationError error

  Testnet *TargetBlockTime `json:"testnet"` // s:44295b20a0, f:e824daf69577864a67e0
  _testnet_ValidationError error

}

// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
type NetworkIdentifier struct {

  // Blockchain name
  Blockchain string `json:"blockchain"` // s:2554912a3e, f:93ff6063fcc4b4c413c9
  _blockchain_ValidationError error


  // If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
  Network string `json:"network"` // s:635df4334a, f:a16b595a2ffa70985cd2
  _network_ValidationError error


  // In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
  SubNetworkIdentifier *SubNetworkIdentifier `json:"sub_network_identifier,omitempty"` // s:a579986aa2, f:b0b59327abb859a88160
}

// NftBalance 
type NftBalance struct {
  Count string `json:"count"` // s:1ad61fe1fa, f:05ce097c882ee7e7f8d0
  _count_ValidationError error

  TotalReceived string `json:"total_received"` // s:cb454858ae, f:500b62005e1b43661336
  _total_received_ValidationError error

  TotalSent string `json:"total_sent"` // s:e7e4799d26, f:152c9b513a3ea3feae6e
  _total_sent_ValidationError error

}

// NftEvent_NonFungibleTokenHoldingWithTxId 
// Aliased for: NftEvent, NonFungibleTokenHoldingWithTxId
type NftEvent_NonFungibleTokenHoldingWithTxId struct {
  AssetIdentifier string `json:"asset_identifier"` // s:7bc0bd26e2, f:4fa3b82e60ace99c8891
  _asset_identifier_ValidationError error

  BlockHeight float64 `json:"block_height"` // s:a15f0b9008, f:f0a6f667702da5b36603
  _block_height_ValidationError error

  Recipient string `json:"recipient"` // s:b5d15cf5c3, f:7f207394095bccf7e92b
  _recipient_ValidationError error

  Sender string `json:"sender"` // s:5505a2e389, f:a9a3db39bb91cdf579eb
  _sender_ValidationError error

  TxId string `json:"tx_id"` // s:a646c4f073, f:1683000e42d1fe4bc3b4
  _tx_id_ValidationError error


  // Identifier of the NFT
  // Non-Fungible Token value
  Value *Value `json:"value"` // s:3b917438c0, f:0a1fa63042b5afc8c5ee
  _value_ValidationError error

}

// NftTransfersItems 
type NftTransfersItems struct {

  // Non Fungible Token asset identifier.
  AssetIdentifier string `json:"asset_identifier"` // s:87eee4dbff, f:1eba4edd8148f6286a8f
  _asset_identifier_ValidationError error


  // Principal that received the asset.
  Recipient string `json:"recipient,omitempty"` // s:03c99d82a3, f:f1192f0760456fb04852

  // Principal that sent the asset.
  Sender string `json:"sender,omitempty"` // s:6c81ca2cdd, f:59f0c5013a74d111b2c5

  // Non Fungible Token asset value.
  Value *Value `json:"value"` // s:3b917438c0, f:0a843bd39e1f4c23b8dd
  _value_ValidationError error

}

// NonFungibleTokenHistoryEventWithTxId Non-Fungible Token history event with transaction id
type NonFungibleTokenHistoryEventWithTxId struct {
  AssetEventType string `json:"asset_event_type"` // s:3144c5c95f, f:4a0e6bcb4b3daac28723
  _asset_event_type_ValidationError error

  EventIndex int `json:"event_index"` // s:1e8ea6cae3, f:14825d89360b6828524c
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:6ea87e1eea, f:a05c05d3ff5bcf92a368
  Sender string `json:"sender,omitempty"` // s:8e13eabb77, f:20d661a50172789167b6
  TxId string `json:"tx_id"` // s:3a4bc7304d, f:3d7967f7630a0fc89f70
  _tx_id_ValidationError error

}

// NonFungibleTokenHoldingWithTxMetadata Ownership of a Non-Fungible Token with transaction metadata
type NonFungibleTokenHoldingWithTxMetadata struct {
  AssetIdentifier string `json:"asset_identifier"` // s:5006febcee, f:d592dbcd415b022e3dae
  _asset_identifier_ValidationError error

  BlockHeight float64 `json:"block_height"` // s:974893bf06, f:560953ff7690e8a797aa
  _block_height_ValidationError error

  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"tx"` // s:2914f791da, f:096e943c20c9692acdf5
  _tx_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:3b917438c0, f:5ef2da6caf8f1b69aaab
  _value_ValidationError error

}

// NonFungibleTokenMintWithTxId Non-Fungible Token mint event with transaction id
type NonFungibleTokenMintWithTxId struct {
  EventIndex int `json:"event_index"` // s:377a0d668b, f:56207c7cfba64f9a6f96
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:f3f9e35fbf, f:f3ff03b8de7445b69ded
  TxId string `json:"tx_id"` // s:2fbb7b879a, f:b27f16cdb0637e2c0a30
  _tx_id_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:3b917438c0, f:149fb37ad594ca6168ad
  _value_ValidationError error

}

// NonFungibleTokenMintWithTxMetadata Non-Fungible Token mint event with transaction metadata
type NonFungibleTokenMintWithTxMetadata struct {
  EventIndex int `json:"event_index"` // s:4c979b337d, f:c9a71930c0c4d247d294
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:465fd15657, f:aa0012476e6bceffe68e
  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"tx"` // s:2914f791da, f:cc41b7d0666e18d95859
  _tx_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:3b917438c0, f:7e2a1254561554a56ac6
  _value_ValidationError error

}

// NonFungibleTokensItems 
type NonFungibleTokensItems struct {
}

// PoisonMicroblock 
type PoisonMicroblock struct {

  // Hex encoded microblock header
  MicroblockHeader1 string `json:"microblock_header_1"` // s:0daab4cf9f, f:0f8e191c6f378f3cff99
  _microblock_header_1_ValidationError error


  // Hex encoded microblock header
  MicroblockHeader2 string `json:"microblock_header_2"` // s:9858b2fbb4, f:e89a41670e897c3b9888
  _microblock_header_2_ValidationError error

}

// PoisonMicroblockTransactionMetadata Metadata associated with a poison-microblock type transaction
type PoisonMicroblockTransactionMetadata struct {
  PoisonMicroblock *PoisonMicroblock `json:"poison_microblock"` // s:247c7c5ba8, f:5523298f894817f317ac
  _poison_microblock_ValidationError error

  TxType string `json:"tx_type"` // s:cb2983ee3b, f:c930e1dcb0faf06c1615
  _tx_type_ValidationError error

}

// PostCoreNodeTransactionsError GET request that returns transactions
type PostCoreNodeTransactionsError struct {

  // The error
  Error string `json:"error"` // s:c08104b3ab, f:f754b2e6451f15dd10e2
  _error_ValidationError error


  // The reason for the error
  Reason string `json:"reason"` // s:0ef59146de, f:3c5db9b7c90b2ef1d42f
  _reason_ValidationError error


  // More details about the reason
  ReasonData *ReasonData `json:"reason_data"` // s:cec4e1906c, f:9cb8f22e3c363c7abaab
  _reason_data_ValidationError error


  // The relevant transaction id
  Txid string `json:"txid"` // s:7dbcd61990, f:7f03970167d254552309
  _txid_ValidationError error

}

// ReadOnlyFunctionArgs Describes representation of a Type-0 Stacks 2.0 transaction. https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#type-0-transferring-an-asset
type ReadOnlyFunctionArgs struct {

  // An array of hex serialized Clarity values
  Arguments []string `json:"arguments"` // s:73c523a5ec, f:beb170101c12a10c7b1c
  _arguments_ValidationError error


  // The simulated tx-sender
  Sender string `json:"sender"` // s:a2b74abe5a, f:58680620e9515c2268f6
  _sender_ValidationError error

}

// ReadOnlyFunctionSuccessResponse GET request to get contract source
type ReadOnlyFunctionSuccessResponse struct {
  Cause string `json:"cause,omitempty"` // s:a05e94b86b, f:89592b484a0a590abb57
  Okay bool `json:"okay"` // s:9ed86b2d26, f:4198783497c96de7bbb9
  _okay_ValidationError error

  Result string `json:"result,omitempty"` // s:95b5160cf5, f:ccba27ddb1dbac4c8457
}

// ReasonData More details about the reason
type ReasonData struct {
}

// Result This object carries the search result
type Result struct {

  // The id used to search this query.
  EntityId string `json:"entity_id"` // s:7b14c2d149, f:4ac0b7f153519a665ff0
  _entity_id_ValidationError error

  EntityType string `json:"entity_type"` // s:dc0a902175, f:7442685bbc4350aef203
  _entity_type_ValidationError error

  Metadata *Metadata_8cb828c26a `json:"metadata,omitempty"` // s:8cb828c26a, f:a98ab8a8e2b4369bc5a4

  // Returns basic search result information about the requested id
  TxData *TxData `json:"tx_data,omitempty"` // s:aa798f727e, f:e83264126592d765a67c
}

// Result_0034ed0505 This object carries the search result
type Result_0034ed0505 struct {

  // The id used to search this query.
  EntityId string `json:"entity_id"` // s:83f9531b76, f:c85d83ccb3c162f8a83e
  _entity_id_ValidationError error

  EntityType string `json:"entity_type"` // s:4d0c82e8f0, f:e3bfc0255dfd31d3a87e
  _entity_type_ValidationError error

  Metadata *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"metadata,omitempty"` // s:2914f791da, f:20f1a5d9283d7e57d7ce

  // Returns basic search result information about the requested id
  TxData *TxData `json:"tx_data"` // s:aa798f727e, f:7877b55c3f26c5a022f5
  _tx_data_ValidationError error

}

// Result_0f2d7b8436 This object carries the search result
type Result_0f2d7b8436 struct {

  // Returns basic search result information about the requested id
  BlockData *BlockData `json:"block_data"` // s:28b0627695, f:e965d281126731a0c5c2
  _block_data_ValidationError error


  // The id used to search this query.
  EntityId string `json:"entity_id"` // s:03ea94d770, f:4fbe3bc380953b30c90c
  _entity_id_ValidationError error


  // 
  // Shows the currenty category of entity it is searched in.
  EntityType string `json:"entity_type"` // s:d4146adbb3, f:ba4a8def48b2939e91bb
  _entity_type_ValidationError error

  Metadata *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"metadata,omitempty"` // s:0ba815ac72, f:e73e18b6f2baf0dc59f1
}

// Result_6453106f3a 
type Result_6453106f3a struct {
  TxId string `json:"tx_id"` // s:084906867e, f:db7d2020972b89769b3a
  _tx_id_ValidationError error

}

// Result_fe531e859f This object carries the search result
type Result_fe531e859f struct {

  // The id used to search this query.
  EntityId string `json:"entity_id"` // s:5017fe9bc5, f:4848732768ff0ed32a15
  _entity_id_ValidationError error

  EntityType string `json:"entity_type"` // s:e7f52469c1, f:7322e895fa495b858eab
  _entity_type_ValidationError error

  Metadata *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"metadata,omitempty"` // s:2914f791da, f:23b241f1e7be0448ccb0

  // Returns basic search result information about the requested id
  TxData *TxData `json:"tx_data"` // s:aa798f727e, f:0cc62610fe2c7575038d
  _tx_data_ValidationError error

}

// ResultsItems 
type ResultsItems struct {
}

// RosettaAccountBalanceRequest_RosettaBlockRequest 
// Aliased for: RosettaAccountBalanceRequest, RosettaBlockRequest
type RosettaAccountBalanceRequest_RosettaBlockRequest struct {
  AccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount `json:"account_identifier"` // s:4c49b0597a, f:853f33404047eeb511bf
  _account_identifier_ValidationError error

  BlockIdentifier *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse `json:"block_identifier,omitempty"` // s:59e40a90a2, f:d03f52e0c8f838189272
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:b32d592f4c7225a7e767
  _network_identifier_ValidationError error

}

// RosettaAccountBalanceResponse An AccountBalanceResponse is returned on the /account/balance endpoint. If an account has a balance for each AccountIdentifier describing it (ex: an ERC-20 token balance on a few smart contracts), an account balance request must be made with each AccountIdentifier.
type RosettaAccountBalanceResponse struct {

  // A single account balance may have multiple currencies
  Balances []*RosettaAmount `json:"balances"` // s:b927bec3b5, f:f48ec1bfc3df13d47377
  _balances_ValidationError error

  BlockIdentifier interface{} `json:"block_identifier"` // s:81db75040f, f:12bc13327ea9700c6b0d
  _block_identifier_ValidationError error


  // If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.
  Coins []*RosettaCoin `json:"coins,omitempty"` // s:b018017a35, f:7b67cf58640c91163e81

  // Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:7ebe7076bf7476fde21d
}

// RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount 
// Aliased for: RosettaAccount, RosettaAccountIdentifier, RosettaNetworkListRequest, RosettaSubAccount
type RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount struct {

  // The address may be a cryptographic public key (or some encoding of it) or a provided username.
  Address string `json:"address"` // s:6c7f06bc55, f:e95f6ddb021d1259bc9b
  _address_ValidationError error


  // Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
  // If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
  // A MetadataRequest is utilized in any request where the only argument is optional metadata.
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:7ba100ad299ffa1ca0f0
  SubAccount *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount `json:"sub_account,omitempty"` // s:4c49b0597a, f:cd12a34b1d5216e2edb3
}

// RosettaAmount_RosettaMaxFeeAmount 
// Aliased for: RosettaAmount, RosettaMaxFeeAmount
type RosettaAmount_RosettaMaxFeeAmount struct {
  Currency *RosettaCurrency `json:"currency"` // s:60a8abd7ad, f:f2b434799c7ec1ae4a43
  _currency_ValidationError error

  Metadata *Metadata_31438643c8 `json:"metadata,omitempty"` // s:31438643c8, f:9883b1cc8af4e8f586d0

  // Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
  Value string `json:"value"` // s:b7737c0c1d, f:d5a0e66eccfb886d294b
  _value_ValidationError error

}

// RosettaBlock Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be inalterable: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents.
type RosettaBlock struct {
  BlockIdentifier interface{} `json:"block_identifier"` // s:92bd565c44, f:f37f73dfdfb42565b7e5
  _block_identifier_ValidationError error


  // meta data
  Metadata *Metadata_8cb828c26a `json:"metadata,omitempty"` // s:8cb828c26a, f:a4a82ab2b2aa196ec199
  ParentBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier `json:"parent_block_identifier"` // s:61e19e0771, f:392130e5fbc9f42aa7cc
  _parent_block_identifier_ValidationError error


  // The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
  Timestamp int `json:"timestamp"` // s:ad82779f53, f:a32dd2ca7b2dd038380f
  _timestamp_ValidationError error


  // All the transactions in the block
  Transactions []*RosettaTransaction `json:"transactions"` // s:15fca731ae, f:30f1d9c1ff7005b14e37
  _transactions_ValidationError error

}

// RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier 
// Aliased for: RosettaBlockIdentifierHeight, RosettaGenesisBlockIdentifier, RosettaOldestBlockIdentifier, RosettaParentBlockIdentifier
type RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier struct {

  // Block hash
  Hash string `json:"hash"` // s:542ec11186, f:cdb3c654e39488328c12
  _hash_ValidationError error


  // This is also known as the block height.
  Index int `json:"index"` // s:379db9cb1c, f:cbbffb5873a1907b1c9a
  _index_ValidationError error

}

// RosettaBlockResponse A BlockResponse includes a fully-populated block or a partially-populated block with a list of other transactions to fetch (other_transactions). As a result of the consensus algorithm of some blockchains, blocks can be omitted (i.e. certain block indexes can be skipped). If a query for one of these omitted indexes is made, the response should not include a Block object. It is VERY important to note that blocks MUST still form a canonical, connected chain of blocks where each block has a unique index. In other words, the PartialBlockIdentifier of a block after an omitted block should reference the last non-omitted block.
type RosettaBlockResponse struct {
  Block *RosettaBlock `json:"block,omitempty"` // s:e429a4e462, f:3ca93fc355618ed05f07

  // Some blockchains may require additional transactions to be fetched that weren't returned in the block response (ex: block only returns transaction hashes). For blockchains with a lot of transactions in each block, this can be very useful as consumers can concurrently fetch all transactions returned.
  OtherTransactions []*OtherTransactionIdentifier `json:"other_transactions,omitempty"` // s:77a437e0dd, f:f32424b63e46b1484d83
}

// RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest 
// Aliased for: RosettaBlockTransactionRequest, RosettaMempoolTransactionRequest
type RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest struct {
  BlockIdentifier *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse `json:"block_identifier"` // s:59e40a90a2, f:74ae65f6ff2cb969557e
  _block_identifier_ValidationError error

  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:feb8e6100c73e89f61bd
  _network_identifier_ValidationError error

  TransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"transaction_identifier"` // s:0ba815ac72, f:e8259da47e1d2099618d
  _transaction_identifier_ValidationError error

}

// RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse 
// Aliased for: RosettaBlockTransactionResponse, RosettaMempoolTransactionResponse
type RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse struct {
  Metadata *Metadata_7cedba8711 `json:"metadata,omitempty"` // s:7cedba8711, f:a0c28d99bdf3dae2fbf2
  Transaction *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction `json:"transaction"` // s:e2799d9c28, f:480fd7bd3c0a3b97b6e6
  _transaction_ValidationError error

}

// RosettaCoin If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.
type RosettaCoin struct {
  Amount *RosettaAmount_RosettaMaxFeeAmount `json:"amount"` // s:05b08240f2, f:532b669ef53f6331ddb8
  _amount_ValidationError error


  // CoinIdentifier uniquely identifies a Coin.
  CoinIdentifier *CoinIdentifier `json:"coin_identifier"` // s:3723ac0baf, f:e6968d58bfba0f0d1c27
  _coin_identifier_ValidationError error

}

// RosettaCoinChange CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
type RosettaCoinChange struct {

  // CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
  CoinAction string `json:"coin_action"` // s:a8df93d1e0, f:d41c262f5e04627f1a2a
  _coin_action_ValidationError error


  // CoinIdentifier uniquely identifies a Coin.
  CoinIdentifier *CoinIdentifier `json:"coin_identifier"` // s:3723ac0baf, f:7c02e345109f0f6a336e
  _coin_identifier_ValidationError error

}

// RosettaConstructionCombineRequest RosettaConstructionCombineRequest is the input to the /construction/combine endpoint. It contains the unsigned transaction blob returned by /construction/payloads and all required signatures to create a network transaction.
type RosettaConstructionCombineRequest struct {
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:bbf3ce073df0a23a1808
  _network_identifier_ValidationError error

  Signatures []*RosettaSignature `json:"signatures"` // s:5d3b0e033c, f:ab701c8baeeddb6cf3bd
  _signatures_ValidationError error

  UnsignedTransaction string `json:"unsigned_transaction"` // s:37711abca0, f:a2646f04b4684d7c63e1
  _unsigned_transaction_ValidationError error

}

// RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest 
// Aliased for: RosettaConstructionCombineResponse, RosettaConstructionHashRequest, RosettaConstructionSubmitRequest
type RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest struct {
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:f548f23ffa64cc7a8e60
  _network_identifier_ValidationError error


  // Signed transaction
  // Signed transaction bytes in hex
  SignedTransaction string `json:"signed_transaction"` // s:97bc66f6b1, f:fb2f7177f947ba167dbd
  _signed_transaction_ValidationError error

}

// RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest 
// Aliased for: RosettaConstructionDeriveRequest, RosettaOptionsRequest, RosettaStatusRequest
type RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest struct {
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:84e8c2528a374584ac99
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:b38fd0b0a4f9bf91db5d
  _network_identifier_ValidationError error

  PublicKey *RosettaPublicKey `json:"public_key"` // s:bccf13ff85, f:049b9a3ae3aa1169822e
  _public_key_ValidationError error

}

// RosettaConstructionDeriveResponse ConstructionDeriveResponse is returned by the /construction/derive endpoint.
type RosettaConstructionDeriveResponse struct {
  AccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount `json:"account_identifier,omitempty"` // s:4c49b0597a, f:a77c4823829bad1bb6bc

  // [DEPRECATED by account_identifier in v1.4.4] Address in network-specific format.
  Address string `json:"address,omitempty"` // s:c7600bce0f, f:5601e591eada48f7287e
  Metadata *Metadata_31438643c8 `json:"metadata,omitempty"` // s:31438643c8, f:b6e605f8585d8913bfbd
}

// RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction 
// Aliased for: RosettaConstructionHashResponse, RosettaConstructionSubmitResponse, RosettaTransaction
type RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction struct {

  // 
  // Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
  Metadata *Metadata_31438643c8 `json:"metadata,omitempty"` // s:31438643c8, f:408d917a541fce1d7562

  // List of operations
  Operations []*RosettaOperation `json:"operations"` // s:bfe28a60cb, f:c3cefaa2c525b4a0e755
  _operations_ValidationError error

  TransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"transaction_identifier"` // s:0ba815ac72, f:364e8e7c35a920b27f43
  _transaction_identifier_ValidationError error

}

// RosettaConstructionMetadataRequest A ConstructionMetadataRequest is utilized to get information required to construct a transaction. The Options object used to specify which metadata to return is left purposely unstructured to allow flexibility for implementers. Optionally, the request can also include an array of PublicKeys associated with the AccountIdentifiers returned in ConstructionPreprocessResponse.
type RosettaConstructionMetadataRequest struct {
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:0e58486899ed4b0e4008
  _network_identifier_ValidationError error

  Options *RosettaOptions `json:"options"` // s:f1196f4928, f:421e20a5050d789809ed
  _options_ValidationError error

  PublicKeys []*RosettaPublicKey `json:"public_keys,omitempty"` // s:142e4c86d1, f:cfc1e175d49b43bc7011
}

// RosettaConstructionMetadataResponse The ConstructionMetadataResponse returns network-specific metadata used for transaction construction. Optionally, the implementer can return the suggested fee associated with the transaction being constructed. The caller may use this info to adjust the intent of the transaction or to create a transaction with a different account that can pay the suggested fee. Suggested fee is an array in case fee payment must occur in multiple currencies.
type RosettaConstructionMetadataResponse struct {
  Metadata *Metadata_19e9556a06 `json:"metadata"` // s:19e9556a06, f:a3df1d8f6739a5772149
  _metadata_ValidationError error

  SuggestedFee []*RosettaAmount `json:"suggested_fee,omitempty"` // s:219bf423dc, f:4935a568550dc58522a9
}

// RosettaConstructionParseResponse RosettaConstructionParseResponse contains an array of operations that occur in a transaction blob. This should match the array of operations provided to /construction/preprocess and /construction/payloads.
type RosettaConstructionParseResponse struct {
  AccountIdentifierSigners []*RosettaAccountIdentifier `json:"account_identifier_signers,omitempty"` // s:3411a1c6a2, f:93ff3d720a2d22092cca
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:9146f436053f49a589a6
  Operations []*RosettaOperation `json:"operations"` // s:16ef996736, f:5e9ad84984f707a441c8
  _operations_ValidationError error


  // [DEPRECATED by account_identifier_signers in v1.4.4] All signers (addresses) of a particular transaction. If the transaction is unsigned, it should be empty.
  Signers []interface{} `json:"signers,omitempty"` // s:bfb6c65dbb, f:9276f24aa70e63135cfb
}

// RosettaConstructionPayloadResponse RosettaConstructionPayloadResponse is returned by /construction/payloads. It contains an unsigned transaction blob (that is usually needed to construct the a network transaction from a collection of signatures) and an array of payloads that must be signed by the caller.
type RosettaConstructionPayloadResponse struct {

  // An array of payloads that must be signed by the caller
  Payloads []*SigningPayload `json:"payloads"` // s:ed9748e233, f:94db71f80c79982b357d
  _payloads_ValidationError error


  // This is an unsigned transaction blob (that is usually needed to construct the a network transaction from a collection of signatures)
  UnsignedTransaction string `json:"unsigned_transaction"` // s:1dd81d6ea5, f:2fe53002bc58b951759c
  _unsigned_transaction_ValidationError error

}

// RosettaConstructionPayloadsRequest_RosettaMempoolRequest 
// Aliased for: RosettaConstructionPayloadsRequest, RosettaMempoolRequest
type RosettaConstructionPayloadsRequest_RosettaMempoolRequest struct {
  Metadata *Metadata_19e9556a06 `json:"metadata,omitempty"` // s:19e9556a06, f:cff32c7d5f831f2b804e
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:f0fb048da5cb39ab62ce
  _network_identifier_ValidationError error

  Operations []*RosettaOperation `json:"operations"` // s:c8c9e5e396, f:3a68aa2e79dd0e2d13b7
  _operations_ValidationError error

  PublicKeys []*RosettaPublicKey `json:"public_keys,omitempty"` // s:5859ac407d, f:20c34720069b3e0b4b10
}

// RosettaConstructionPreprocessRequest ConstructionPreprocessRequest is passed to the /construction/preprocess endpoint so that a Rosetta implementation can determine which metadata it needs to request for construction
type RosettaConstructionPreprocessRequest struct {
  MaxFee []*RosettaMaxFeeAmount `json:"max_fee,omitempty"` // s:338c726a8b, f:47f7321a2a0be7847a75
  Metadata *Metadata_31438643c8 `json:"metadata,omitempty"` // s:31438643c8, f:8cd0feeb1af247dfd1e5
  NetworkIdentifier *NetworkIdentifier `json:"network_identifier"` // s:a81b90a900, f:4a08ec0553712a35925e
  _network_identifier_ValidationError error

  Operations []*RosettaOperation `json:"operations"` // s:6ca8607603, f:7fcdb9d4cff7e939b8ab
  _operations_ValidationError error


  //  The caller can also provide a suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency. It is assumed that providing a very low multiplier (like 0.0001) will never lead to a transaction being created with a fee less than the minimum network fee (if applicable). In the case that the caller provides both a max fee and a suggested fee multiplier, the max fee will set an upper bound on the suggested fee (regardless of the multiplier provided).
  SuggestedFeeMultiplier int `json:"suggested_fee_multiplier,omitempty"` // s:37eb45976e, f:15c06bd813298be86855
}

// RosettaConstructionPreprocessResponse RosettaConstructionPreprocessResponse contains options that will be sent unmodified to /construction/metadata. If it is not necessary to make a request to /construction/metadata, options should be omitted. Some blockchains require the PublicKey of particular AccountIdentifiers to construct a valid transaction. To fetch these PublicKeys, populate required_public_keys with the AccountIdentifiers associated with the desired PublicKeys. If it is not necessary to retrieve any PublicKeys for construction, required_public_keys should be omitted.
type RosettaConstructionPreprocessResponse struct {
  Options *RosettaOptions `json:"options,omitempty"` // s:f1196f4928, f:6e2ca705f7a2c9a11d25
  RequiredPublicKeys []*RosettaAccount `json:"required_public_keys,omitempty"` // s:71de5a7103, f:e06531dbb340ce7c10c3
}

// RosettaCurrency Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
type RosettaCurrency struct {

  // Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
  Decimals int `json:"decimals"` // s:a7b8d9c1bd, f:6221a63b7fb965b71f7c
  _decimals_ValidationError error


  // Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:3ca7e2725c3de6a05a4b

  // Canonical symbol associated with a currency.
  Symbol string `json:"symbol"` // s:1ef7a7da84, f:234c7e5ef0914c09f4ec
  _symbol_ValidationError error

}

// RosettaError_RosettaErrorNoDetails 
// Aliased for: RosettaError, RosettaErrorNoDetails
type RosettaError_RosettaErrorNoDetails struct {

  // Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
  Code int `json:"code"` // s:def2fa677c, f:57cddb52c3237cfccd42
  _code_ValidationError error


  // Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
  Details *Details `json:"details,omitempty"` // s:ba22a6c2d3, f:c12288875e0818a59d75

  // Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
  Message string `json:"message"` // s:453d604fd2, f:8889759d0f8b1ea7c93e
  _message_ValidationError error


  // An error is retriable if the same request may succeed if submitted again.
  Retriable bool `json:"retriable"` // s:22828b1fb5, f:e37c7ee90167b344e371
  _retriable_ValidationError error

}

// RosettaMempoolResponse A MempoolResponse contains all transaction identifiers in the mempool for a particular network_identifier.
type RosettaMempoolResponse struct {
  Metadata *Metadata_19e9556a06 `json:"metadata,omitempty"` // s:19e9556a06, f:442e9d76654dbbdcadc2
  TransactionIdentifiers []*TransactionIdentifier `json:"transaction_identifiers"` // s:4035c350bf, f:a42a567d695fb01793d6
  _transaction_identifiers_ValidationError error

}

// RosettaNetworkListResponse A NetworkListResponse contains all NetworkIdentifiers that the node can serve information for.
type RosettaNetworkListResponse struct {

  // The network_identifier specifies which network a particular object is associated with.
  NetworkIdentifiers []*NetworkIdentifier `json:"network_identifiers"` // s:8a1483e00d, f:57ed0bbbc2ce32742c24
  _network_identifiers_ValidationError error

}

// RosettaNetworkOptionsResponse NetworkOptionsResponse contains information about the versioning of the node and the allowed operation statuses, operation types, and errors.
type RosettaNetworkOptionsResponse struct {

  // Allow specifies supported Operation status, Operation types, and all possible error statuses. This Allow object is used by clients to validate the correctness of a Rosetta Server implementation. It is expected that these clients will error if they receive some response that contains any of the above information that is not specified here.
  Allow *Allow `json:"allow"` // s:736bff7fd5, f:cf1ed3b1bf1a334bfb3a
  _allow_ValidationError error


  // The Version object is utilized to inform the client of the versions of different components of the Rosetta implementation.
  Version *Version `json:"version"` // s:2bc2e51445, f:6766fe2650de3788078f
  _version_ValidationError error

}

// RosettaNetworkStatusResponse NetworkStatusResponse contains basic information about the node's view of a blockchain network. It is assumed that any BlockIdentifier.Index less than or equal to CurrentBlockIdentifier.Index can be queried. If a Rosetta implementation prunes historical state, it should populate the optional oldest_block_identifier field with the oldest block available to query. If this is not populated, it is assumed that the genesis_block_identifier is the oldest queryable block. If a Rosetta implementation performs some pre-sync before it is possible to query blocks, sync_status should be populated so that clients can still monitor healthiness. Without this field, it may appear that the implementation is stuck syncing and needs to be terminated.
type RosettaNetworkStatusResponse struct {
  CurrentBlockIdentifier interface{} `json:"current_block_identifier"` // s:ee6a80d098, f:316932409379630aa5d7
  _current_block_identifier_ValidationError error


  // The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
  CurrentBlockTimestamp int `json:"current_block_timestamp"` // s:8323d6ae98, f:d73d58ca6d86a5f8e327
  _current_block_timestamp_ValidationError error

  GenesisBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier `json:"genesis_block_identifier"` // s:61e19e0771, f:73714b6b69428ae02ec1
  _genesis_block_identifier_ValidationError error

  OldestBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier `json:"oldest_block_identifier,omitempty"` // s:61e19e0771, f:2fce79a7ead21c52b9a3

  // Peers information
  Peers []*RosettaPeers `json:"peers"` // s:7360fd7609, f:c079da5e8807f1dc7fc4
  _peers_ValidationError error

  SyncStatus *RosettaSyncStatus `json:"sync_status,omitempty"` // s:9a094712d2, f:64206462ccb2c6df6e96
}

// RosettaOperation Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction.
type RosettaOperation struct {
  Account *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount `json:"account,omitempty"` // s:4c49b0597a, f:27c8efc6f88f534872d1
  Amount *RosettaAmount_RosettaMaxFeeAmount `json:"amount,omitempty"` // s:05b08240f2, f:4c8d02c9e4eb5137d1db
  CoinChange *RosettaCoinChange `json:"coin_change,omitempty"` // s:1ed7d662ad, f:0e580cc71a40d9080854

  // Operations Meta Data
  Metadata *Metadata_31438643c8 `json:"metadata,omitempty"` // s:31438643c8, f:edf8d3b3ac6e1e552108
  OperationIdentifier *RosettaOperationIdentifier_RosettaRelatedOperation `json:"operation_identifier"` // s:676a999f12, f:0063fca65a0264692166
  _operation_identifier_ValidationError error


  // Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
  RelatedOperations []*RosettaRelatedOperation `json:"related_operations,omitempty"` // s:53fabf0b28, f:a0b08ffea5313c55698a

  // The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
  Status string `json:"status,omitempty"` // s:6b88e2f039, f:4260bdbd7ef58ef5ebc8

  // The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
  Type string `json:"type"` // s:e3a25dc2ea, f:25bc5a61013ce1128c16
  _type_ValidationError error

}

// RosettaOperationIdentifier_RosettaRelatedOperation 
// Aliased for: RosettaOperationIdentifier, RosettaRelatedOperation
type RosettaOperationIdentifier_RosettaRelatedOperation struct {

  // The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
  // Describes the index of related operation.
  Index int `json:"index"` // s:7266f70185, f:b0d0efd92155bd15f3a2
  _index_ValidationError error


  // Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
  // Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
  NetworkIndex int `json:"network_index,omitempty"` // s:aefb0250ef, f:71a9cf360e8a89776c04
}

// RosettaOperationStatus OperationStatus is utilized to indicate which Operation status are considered successful.
type RosettaOperationStatus struct {

  // The status is the network-specific status of the operation.
  Status string `json:"status"` // s:486c9ba86b, f:c3056aa0eb04a197e684
  _status_ValidationError error


  // An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.
  Successful bool `json:"successful"` // s:67bd501aeb, f:20aa398a6ce25e4b0731
  _successful_ValidationError error

}

// RosettaOptions The options that will be sent directly to /construction/metadata by the caller.
type RosettaOptions struct {

  // Amount to be transfered.
  Amount string `json:"amount,omitempty"` // s:12df9c8c58, f:a54effa74d316f1fb0b4

  // Set the burnchain (BTC) block for stacking lock to start.
  BurnBlockHeight int `json:"burn_block_height,omitempty"` // s:c34ed0b5ac, f:a14cd5bcc7161ce95aae

  // Address of the contract to call.
  ContractAddress string `json:"contract_address,omitempty"` // s:24ddb993b6, f:3ec5046a72816a0a967b

  // Name of the contract to call.
  ContractName string `json:"contract_name,omitempty"` // s:0ef602cc37, f:1e52a6ab755d6feee091

  // Number of decimal places
  Decimals int `json:"decimals,omitempty"` // s:4dfc809017, f:790665348d4b0f4d54c0

  // Delegator address for when calling `delegate-stacking`.
  DelegateTo string `json:"delegate_to,omitempty"` // s:5ec9829a4b, f:116faaf497b29c519c50

  // Fee for this transaction
  Fee string `json:"fee,omitempty"` // s:671731c697, f:b509774f2e071fa794d2

  // Maximum price a user is willing to pay.
  GasLimit float64 `json:"gas_limit,omitempty"` // s:c2f25ccadf, f:3b7a99d709796ad4da4f

  // Cost necessary to perform a transaction on the network
  GasPrice float64 `json:"gas_price,omitempty"` // s:7e311531d2, f:637e45080609b11db301

  // Maximum fee user is willing to pay
  MaxFee string `json:"max_fee,omitempty"` // s:82c1dafff0, f:c566984a083c5e5f4366

  // STX token transfer memo.
  Memo string `json:"memo,omitempty"` // s:e126f05939, f:3d879d3913a6b365be52

  // Number of cycles when stacking.
  NumberOfCycles int `json:"number_of_cycles,omitempty"` // s:9c723ac64c, f:de2b9666a51f4e02b0a3

  // The reward address for stacking transaction. It should be a valid Bitcoin address
  PoxAddr string `json:"pox_addr,omitempty"` // s:5ecc7829d5, f:7fc1be4542340eb4007a

  // sender's address 
  SenderAddress string `json:"sender_address,omitempty"` // s:9d859dec3d, f:c3c735cc3bd0b03786ef

  // Transaction approximative size (used to calculate total fee).
  Size int `json:"size,omitempty"` // s:ef44a0407f, f:b5c463ef9ebe20df1530

  // This value indicates the state of the operations
  Status string `json:"status,omitempty"` // s:af3ca6c8d4, f:b462515e88a15a2e93d9

  //  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
  SuggestedFeeMultiplier float64 `json:"suggested_fee_multiplier,omitempty"` // s:7f97d85838, f:8e91667baf7686f190a0

  // Currency symbol e.g STX
  Symbol string `json:"symbol,omitempty"` // s:1e8d8d4c0f, f:696a4fdcb9b0bdbd7c79

  // Recipient's address
  TokenTransferRecipientAddress string `json:"token_transfer_recipient_address,omitempty"` // s:8ea7666baf, f:134962851a11c921462a

  // Type of operation e.g transfer
  Type string `json:"type,omitempty"` // s:e85c6a822f, f:ececcbcca058aa32b676
}

// RosettaPeers A Peer is a representation of a node's peer.
type RosettaPeers struct {

  // meta data
  Metadata *Metadata_19e9556a06 `json:"metadata,omitempty"` // s:19e9556a06, f:f693a4001056d5613043

  // peer id
  PeerId string `json:"peer_id"` // s:d0abf3068f, f:e3b81aa66cf524222b0a
  _peer_id_ValidationError error

}

// RosettaPublicKey PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
type RosettaPublicKey struct {

  // CurveType is the type of cryptographic curve associated with a PublicKey.
  CurveType string `json:"curve_type"` // s:e6622fe3e7, f:cf926fec9e62934af472
  _curve_type_ValidationError error


  // Hex-encoded public key bytes in the format specified by the CurveType.
  HexBytes string `json:"hex_bytes"` // s:c766f8f7bd, f:0f9e675fa83ca36f5836
  _hex_bytes_ValidationError error

}

// RosettaSignature Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.
type RosettaSignature struct {
  HexBytes string `json:"hex_bytes"` // s:206e0be99b, f:cc5f7152ec3ca5af1c99
  _hex_bytes_ValidationError error

  PublicKey *RosettaPublicKey `json:"public_key"` // s:bccf13ff85, f:7281e42b51bedd8afbea
  _public_key_ValidationError error

  SignatureType string `json:"signature_type"` // s:550b0f3b4d, f:1a46e3172763ee6cdc04
  _signature_type_ValidationError error

  SigningPayload *SigningPayload `json:"signing_payload"` // s:a532137f20, f:8139425a6775f8128ac3
  _signing_payload_ValidationError error

}

// RosettaSyncStatus SyncStatus is used to provide additional context about an implementation's sync status. It is often used to indicate that an implementation is healthy when it cannot be queried until some sync phase occurs. If an implementation is immediately queryable, this model is often not populated.
type RosettaSyncStatus struct {

  // CurrentIndex is the index of the last synced block in the current stage.
  CurrentIndex int `json:"current_index"` // s:363aa32ed6, f:3f87207eff54d144999b
  _current_index_ValidationError error


  // Stage is the phase of the sync process.
  Stage string `json:"stage,omitempty"` // s:b36408e7e5, f:ed5664206d3bdcbbc4b5

  // Synced indicates if an implementation has synced up to the most recent block.
  Synced bool `json:"synced,omitempty"` // s:3fe84dbf20, f:de17ba63e8694287d5a6

  // TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.
  TargetIndex int `json:"target_index,omitempty"` // s:21d610bd36, f:ab60a449ebc51cf0f65f
}

// RpcAddressBalanceNotificationParams 
type RpcAddressBalanceNotificationParams struct {
  Address string `json:"address"` // s:35126f8621, f:de1f3d492be99f8b58f0
  _address_ValidationError error

  Balance string `json:"balance"` // s:d038cd179a, f:da8eb2b32bf05b9551fa
  _balance_ValidationError error

}

// RpcAddressBalanceNotificationResponse 
type RpcAddressBalanceNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:7e405db012, f:115f7ae07741e0b88048
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:57e8ef16f4, f:a0be3391c288e2671afd
  _method_ValidationError error

  Params *RpcAddressBalanceNotificationParams `json:"params"` // s:e15616d021, f:80a5cb2481f37597f420
  _params_ValidationError error

}

// RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams 
// Aliased for: RpcAddressBalanceSubscriptionParams, RpcAddressTxSubscriptionParams
type RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams struct {
  Address string `json:"address"` // s:0d45308f90, f:afa4dba9e47947aaf5b4
  _address_ValidationError error

  Event string `json:"event"` // s:23aab099f1, f:c5e95bceb0fc288bdf4f
  _event_ValidationError error

}

// RpcAddressBalanceSubscriptionRequest 
type RpcAddressBalanceSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:2227665e55, f:39422deb6c1edb6a48a7
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:b2ac5979b2, f:01c0f6ca09f5323986b0
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:455e35dad2, f:54a3c74a40cd810ad5a3
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams `json:"params"` // s:d8ee414d87, f:2acd11555b5f411b2dd0
  _params_ValidationError error

}

// RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams 
// Aliased for: RpcAddressTxNotificationParams, RpcTxUpdateNotificationParams
type RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams struct {
  Address string `json:"address"` // s:1b136b5dbf, f:b69c4c5a87c8a029e035
  _address_ValidationError error

  TxId string `json:"tx_id"` // s:ce9053152f, f:7be275d2927ca7f10d6a
  _tx_id_ValidationError error

  TxStatus interface{} `json:"tx_status"` // s:e94807fa95, f:04bd10a33842f02e76a9
  _tx_status_ValidationError error

  TxType string `json:"tx_type"` // s:ff0310de5c, f:914c671e9db08d1f887c
  _tx_type_ValidationError error

}

// RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse 
// Aliased for: RpcAddressTxNotificationResponse, RpcTxUpdateNotificationResponse
type RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:8747ff2795, f:3b253e8ce032273ba489
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:22e7aa5226, f:72aea0d32062f6501639
  _method_ValidationError error

  Params *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams `json:"params"` // s:f5e05caeaa, f:fae9c360881f4603ead3
  _params_ValidationError error

}

// RpcAddressTxSubscriptionRequest 
type RpcAddressTxSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:5fbc195e35, f:ce49eef86d20743b3eb3
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:8794805200, f:472ddfd162c28a072c1d
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:a74758c913, f:21ea61e620e72794169c
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams `json:"params"` // s:d8ee414d87, f:8a75b78fb5aad6af9725
  _params_ValidationError error

}

// RpcBlockNotificationResponse 
type RpcBlockNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:827ce44927, f:995e52177b0dd13e03bf
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:c7479cee60, f:34d322ebf3fb01f4adc0
  _method_ValidationError error

  Params *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"params"` // s:0ba815ac72, f:b91101472cafeea4e0e6
  _params_ValidationError error

}

// RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams 
// Aliased for: RpcBlockSubscriptionParams, RpcMempoolSubscriptionParams, RpcMicroblockSubscriptionParams, RpcTxUpdateSubscriptionParams
type RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams struct {
  Event string `json:"event"` // s:3e49f156f6, f:e3f36399034adea88ce6
  _event_ValidationError error

  TxId string `json:"tx_id"` // s:4f0c919515, f:2c1ef11645c0f43ba58c
  _tx_id_ValidationError error

}

// RpcBlockSubscriptionRequest 
type RpcBlockSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:076eefabe9, f:5708ae025d715f1e3fcd
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:b08bdd1e37, f:b2fb9f479c37480d2c9c
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:a95c71e914, f:71d3e8a09517aed0ef6f
  _method_ValidationError error

  Params *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams `json:"params"` // s:8d3616756a, f:7aa9767bcceba8d77490
  _params_ValidationError error

}

// RpcMempoolNotificationResponse 
type RpcMempoolNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:c51022a047, f:91f88d4082f9a714c705
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:6b54669e8c, f:fa38a49a050607e3bf3a
  _method_ValidationError error

  Params *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata `json:"params"` // s:2914f791da, f:e30c2f36299adb4618a5
  _params_ValidationError error

}

// RpcMempoolSubscriptionRequest 
type RpcMempoolSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:2703b25322, f:5384ba0ea9248860be80
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:6b1729fdb7, f:0949ad604a0d4e8e55ba
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:9b8969c8de, f:d400b2264359d7b34252
  _method_ValidationError error

  Params *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams `json:"params"` // s:8d3616756a, f:13defddf9a1e67f722f2
  _params_ValidationError error

}

// RpcMicroblockNotificationResponse 
type RpcMicroblockNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:47e4adc380, f:b88fd67ecaff2af7a5b3
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:7ddceca727, f:3a1674ae5600335ee355
  _method_ValidationError error

  Params *Microblock `json:"params"` // s:260b31da15, f:6984936dd3208b2e5ae6
  _params_ValidationError error

}

// RpcMicroblockSubscriptionRequest 
type RpcMicroblockSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:05b0899bd0, f:63c0d997b269bd8e8629
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:6b1020e311, f:97bf19bbcb59370257a3
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:5a0012843b, f:3b4297e5e05f59a7b8e2
  _method_ValidationError error

  Params *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams `json:"params"` // s:8d3616756a, f:d789edab6c66fd4753c9
  _params_ValidationError error

}

// RpcTxUpdateSubscriptionRequest 
type RpcTxUpdateSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:a230f3d6ef, f:a3907fabe31b129edba9
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:44013f5b4d, f:9c0e34f9aaf2f0d024e2
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:c8b86ac8a7, f:fc904f7bc963c968f4fd
  _method_ValidationError error

  Params *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams `json:"params"` // s:8d3616756a, f:efb79ffa73246992c817
  _params_ValidationError error

}

// RunFaucetResponse POST request that initiates a transfer of tokens to a specified testnet address
type RunFaucetResponse struct {

  // Indicates if the faucet call was successful
  Success bool `json:"success"` // s:ac1bfd0a1d, f:5880018b11de4a845524
  _success_ValidationError error


  // The transaction ID for the faucet call
  TxId string `json:"txId,omitempty"` // s:de903ef3a7, f:ab65309c7a1a65ebf58a

  // Raw transaction in hex string representation
  TxRaw string `json:"txRaw,omitempty"` // s:8a1263bc79, f:660d762c399fba5b1eaa
}

// ServerStatusResponse GET blockchain API status
type ServerStatusResponse struct {
  ChainTip *ChainTip `json:"chain_tip,omitempty"` // s:34708e0a46, f:804ac5058dce9f3741ad

  // the server version that is currently running
  ServerVersion string `json:"server_version,omitempty"` // s:30bafdb8d4, f:228ad38c28f0ed920fd1

  // the current server status
  Status string `json:"status"` // s:14c7ddbf5d, f:64e55d1368496f3afd13
  _status_ValidationError error

}

// SigningPayload SigningPayload is signed by the client with the keypair associated with an address using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
type SigningPayload struct {
  AccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount `json:"account_identifier,omitempty"` // s:4c49b0597a, f:5cbc458944ce452798ab

  // [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
  Address string `json:"address,omitempty"` // s:90367814e2, f:31380323dccd56805d94
  HexBytes string `json:"hex_bytes"` // s:325c027664, f:15b09b353b1a69b8ae94
  _hex_bytes_ValidationError error


  // SignatureType is the type of a cryptographic signature.
  SignatureType string `json:"signature_type,omitempty"` // s:f3bfc11557, f:376fb6e4e315a510f05e
}

// SmartContract A Smart Contract Detail
type SmartContract struct {
  Abi string `json:"abi"` // s:40e8a24470, f:1d7a0a96592a545f8972
  _abi_ValidationError error

  BlockHeight int `json:"block_height"` // s:c5e1547862, f:912ba6f48cacf3822138
  _block_height_ValidationError error

  Canonical bool `json:"canonical"` // s:8d4a9c4449, f:02fc35539369d04ec7c7
  _canonical_ValidationError error

  SourceCode string `json:"source_code"` // s:7447ce083f, f:d381ebc621e712b1e121
  _source_code_ValidationError error

  TxId string `json:"tx_id"` // s:6ca13c0e36, f:629b693a2ccd4a517b3c
  _tx_id_ValidationError error

}

// SmartContractTransactionMetadata Metadata associated with a contract-deploy type transaction. https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#type-1-instantiating-a-smart-contract
type SmartContractTransactionMetadata struct {
  SmartContract *SmartContract_b2c173c5bf `json:"smart_contract"` // s:b2c173c5bf, f:fdc227f13cb005edf0c6
  _smart_contract_ValidationError error

  TxType string `json:"tx_type"` // s:00bcbda2ef, f:07e86fe8881061bc7f9d
  _tx_type_ValidationError error

}

// SmartContract_b2c173c5bf 
type SmartContract_b2c173c5bf struct {

  // Contract identifier formatted as `<principaladdress>.<contract_name>`
  ContractId string `json:"contract_id"` // s:50ae639ee0, f:986448a85ffba10954bd
  _contract_id_ValidationError error


  // Clarity code of the smart contract being deployed
  SourceCode string `json:"source_code"` // s:a2f142c745, f:7a32c7ecd7177298c436
  _source_code_ValidationError error

}

// StxTransfersItems 
type StxTransfersItems struct {

  // Amount transferred in micro-STX as an integer string.
  Amount string `json:"amount"` // s:aecc441184, f:d2c53a4a0971a31c14f5
  _amount_ValidationError error


  // Principal that received STX. This is unspecified if the STX were burned.
  Recipient string `json:"recipient,omitempty"` // s:ad623e7ef3, f:81beec6fc46b04caac65

  // Principal that sent STX. This is unspecified if the STX were minted.
  Sender string `json:"sender,omitempty"` // s:9e06ec9529, f:edf8a1e914dbf6c48e5b
}

// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
type SubNetworkIdentifier struct {

  // Meta data from subnetwork identifier
  Metadata *Metadata_7cedba8711 `json:"metadata,omitempty"` // s:7cedba8711, f:d6ef88bbf1a32377351d

  // Network name
  Network string `json:"network"` // s:b8153d0076, f:cfa0a0cdb8a2070a25e4
  _network_ValidationError error

}

// TargetBlockTime 
type TargetBlockTime struct {
  TargetBlockTime int `json:"target_block_time"` // s:1c63dc56a9, f:29747a717518a94f0934
  _target_block_time_ValidationError error

}

// TokenTransfer 
type TokenTransfer struct {

  // Transfer amount as Integer string (64-bit unsigned integer)
  Amount string `json:"amount"` // s:c66b667ace, f:08181c6be170b6a558f7
  _amount_ValidationError error


  // Hex encoded arbitrary message, up to 34 bytes length (should try decoding to an ASCII string)
  Memo string `json:"memo"` // s:84cfda0bfd, f:3b6e13cb64ad9f57c4ee
  _memo_ValidationError error

  RecipientAddress string `json:"recipient_address"` // s:66c5fa8880, f:6ab035bd169c12896fb6
  _recipient_address_ValidationError error

}

// TokenTransferTransactionMetadata Metadata associated with token-transfer type transactions
type TokenTransferTransactionMetadata struct {
  TokenTransfer *TokenTransfer `json:"token_transfer"` // s:200ee3cdc3, f:efba7e985cd3a7b46e25
  _token_transfer_ValidationError error

  TxType string `json:"tx_type"` // s:c67f971616, f:575937d0a4df8bcd93bf
  _tx_type_ValidationError error

}

// TransactionEventAsset 
type TransactionEventAsset struct {
  Amount string `json:"amount,omitempty"` // s:0718f0119d, f:9bcb4517f749e0baf96c
  AssetEventType string `json:"asset_event_type,omitempty"` // s:05668527eb, f:f8bcb3016287e78191fe
  AssetId string `json:"asset_id,omitempty"` // s:cac978ec83, f:2ffe52795bf70eafb77b
  Recipient string `json:"recipient,omitempty"` // s:df6d7d3814, f:28397c8df5440966800a
  Sender string `json:"sender,omitempty"` // s:19ba493f74, f:054324032d48621bc5db
  Value string `json:"value,omitempty"` // s:947b6840f1, f:d564c8f47ea125d569f2
}

// TransactionFeeEstimateRequest POST request for estimated fee
type TransactionFeeEstimateRequest struct {
  EstimatedLen int `json:"estimated_len,omitempty"` // s:f32702f401, f:8aa092f3ad1c938fe186
  TransactionPayload string `json:"transaction_payload"` // s:bb3532c431, f:9e180fa141c84362eef1
  _transaction_payload_ValidationError error

}

// TransactionFeeEstimateResponse POST response for estimated fee
type TransactionFeeEstimateResponse struct {
  CostScalarChangeByByte float64 `json:"cost_scalar_change_by_byte,omitempty"` // s:63c98bd5ed, f:41582b753c8e2a3e5d8f
  EstimatedCost *EstimatedCost `json:"estimated_cost"` // s:651da6d4de, f:c34bca394dec33ff92ee
  _estimated_cost_ValidationError error

  EstimatedCostScalar int `json:"estimated_cost_scalar"` // s:90a25131e8, f:f053fb722e527111d80a
  _estimated_cost_scalar_ValidationError error

  Estimations []*EstimationsItems `json:"estimations,omitempty"` // s:1b70c92db9, f:0398c861f9d87a230996
}

// TransactionFound This object returns transaction for found true
type TransactionFound struct {
  Found bool `json:"found"` // s:08ba549fec, f:73cade097ad2e2b42938
  _found_ValidationError error

  Result interface{} `json:"result"` // s:2af6faddda, f:11b5e9cbcc2ad0bac132
  _result_ValidationError error

}

// TxData Returns basic search result information about the requested id
type TxData struct {

  // Refers to the hash of the block for searched transaction
  BlockHash string `json:"block_hash,omitempty"` // s:721a2b27d6, f:07c881c05b637196882f
  BlockHeight int `json:"block_height,omitempty"` // s:a83afb9ecc, f:0f4f60816e1411f9f3f8
  BurnBlockTime int `json:"burn_block_time,omitempty"` // s:c5ce320dc4, f:82b408c704bd5529f6f6

  // If the transaction lies within the canonical chain
  Canonical bool `json:"canonical,omitempty"` // s:07562e79de, f:31df1546daa981a316d1

  // Corresponding tx_id for smart_contract
  TxId string `json:"tx_id,omitempty"` // s:5375786c31, f:a707cce5afca02744735
  TxType string `json:"tx_type,omitempty"` // s:b458cc1c72, f:94a03e92453c02c25ee6
}

// Value Non-Fungible Token value
type Value struct {

  // Hex string representing the identifier of the Non-Fungible Token
  // Hex string representing the identifier of the NFT
  // 
  Hex string `json:"hex"` // s:97b19e19b9, f:a6c8790818d1b92fd587
  _hex_ValidationError error


  // Readable string of the Non-Fungible Token identifier
  // Readable string of the NFT identifier
  // 
  Repr string `json:"repr"` // s:250a567849, f:8f3e09a5d1f91f8016f9
  _repr_ValidationError error

}

// VariablesItems 
type VariablesItems struct {
}

// Version The Version object is utilized to inform the client of the versions of different components of the Rosetta implementation.
type Version struct {

  // Any other information that may be useful about versioning of dependent services should be returned here.
  Metadata *Metadata `json:"metadata,omitempty"` // s:93151d1a5f, f:4b9186b50c47850c25ab

  // When a middleware server is used to adhere to the Rosetta interface, it should return its version here. This can help clients manage deployments.
  MiddlewareVersion string `json:"middleware_version,omitempty"` // s:cfb97ba973, f:6ee65f5e9f46fa3e1966

  // The node_version is the canonical version of the node runtime. This can help clients manage deployments.
  NodeVersion string `json:"node_version"` // s:8fcf887291, f:d74fadb1fa8c67afe35a
  _node_version_ValidationError error


  // The rosetta_version is the version of the Rosetta interface the implementation adheres to. This can be useful for clients looking to reliably parse responses.
  RosettaVersion string `json:"rosetta_version"` // s:0ec3e200da, f:c9f1a37a22dd6d6dd899
  _rosetta_version_ValidationError error

}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetEventType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata) UnmarshalJSON(b []byte) error {
    asset_event_typeReceived := false
    event_indexReceived := false
    txReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
            asset_event_typeReceived = true
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_event_type (a required property) was received
    if !asset_event_typeReceived {
		strct._asset_event_type_ValidationError = fmt.Errorf("\"AssetEventType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_AddressStxBalanceResponse_CoinbaseTransaction_MempoolCoinbaseTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHistoryEventWithTxMetadata_NonFungibleTokenHolding_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_SearchResult_SearchSuccessResult_SmartContractTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._asset_event_type_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_event_type_ValidationError)
	}
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AccountDataResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Balance" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance\": ")
	if tmp, err := json.Marshal(strct.Balance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BalanceProof" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance_proof" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance_proof\": ")
	if tmp, err := json.Marshal(strct.BalanceProof); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Locked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"locked\": ")
	if tmp, err := json.Marshal(strct.Locked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Nonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nonce\": ")
	if tmp, err := json.Marshal(strct.Nonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NonceProof" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nonce_proof" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nonce_proof\": ")
	if tmp, err := json.Marshal(strct.NonceProof); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlock_height\": ")
	if tmp, err := json.Marshal(strct.UnlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccountDataResponse) UnmarshalJSON(b []byte) error {
    balanceReceived := false
    balance_proofReceived := false
    lockedReceived := false
    nonceReceived := false
    nonce_proofReceived := false
    unlock_heightReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "balance":
            if err := json.Unmarshal([]byte(v), &strct.Balance); err != nil {
				return err
            }
            balanceReceived = true
        case "balance_proof":
            if err := json.Unmarshal([]byte(v), &strct.BalanceProof); err != nil {
				return err
            }
            balance_proofReceived = true
        case "locked":
            if err := json.Unmarshal([]byte(v), &strct.Locked); err != nil {
				return err
            }
            lockedReceived = true
        case "nonce":
            if err := json.Unmarshal([]byte(v), &strct.Nonce); err != nil {
				return err
            }
            nonceReceived = true
        case "nonce_proof":
            if err := json.Unmarshal([]byte(v), &strct.NonceProof); err != nil {
				return err
            }
            nonce_proofReceived = true
        case "unlock_height":
            if err := json.Unmarshal([]byte(v), &strct.UnlockHeight); err != nil {
				return err
            }
            unlock_heightReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if balance (a required property) was received
    if !balanceReceived {
		strct._balance_ValidationError = fmt.Errorf("\"Balance\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if balance_proof (a required property) was received
    if !balance_proofReceived {
		strct._balance_proof_ValidationError = fmt.Errorf("\"BalanceProof\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if locked (a required property) was received
    if !lockedReceived {
		strct._locked_ValidationError = fmt.Errorf("\"Locked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if nonce (a required property) was received
    if !nonceReceived {
		strct._nonce_ValidationError = fmt.Errorf("\"Nonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if nonce_proof (a required property) was received
    if !nonce_proofReceived {
		strct._nonce_proof_ValidationError = fmt.Errorf("\"NonceProof\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlock_height (a required property) was received
    if !unlock_heightReceived {
		strct._unlock_height_ValidationError = fmt.Errorf("\"UnlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AccountDataResponse) Validate() []error {
    var allErrors []error
    if strct._balance_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_ValidationError)
	}
    if strct._balance_proof_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_proof_ValidationError)
	}
    if strct._locked_ValidationError != nil {
		allErrors = append(allErrors, strct._locked_ValidationError)
	}
    if strct._nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._nonce_ValidationError)
	}
    if strct._nonce_proof_ValidationError != nil {
		allErrors = append(allErrors, strct._nonce_proof_ValidationError)
	}
    if strct._unlock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._unlock_height_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Limit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "limit" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Offset" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "offset" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"offset\": ")
	if tmp, err := json.Marshal(strct.Offset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Results" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "results" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"results\": ")
	if tmp, err := json.Marshal(strct.Results); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Total" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total\": ")
	if tmp, err := json.Marshal(strct.Total); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse) UnmarshalJSON(b []byte) error {
    limitReceived := false
    offsetReceived := false
    resultsReceived := false
    totalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
				return err
            }
            limitReceived = true
        case "offset":
            if err := json.Unmarshal([]byte(v), &strct.Offset); err != nil {
				return err
            }
            offsetReceived = true
        case "results":
            if err := json.Unmarshal([]byte(v), &strct.Results); err != nil {
				return err
            }
            resultsReceived = true
        case "total":
            if err := json.Unmarshal([]byte(v), &strct.Total); err != nil {
				return err
            }
            totalReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if limit (a required property) was received
    if !limitReceived {
		strct._limit_ValidationError = fmt.Errorf("\"Limit\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if offset (a required property) was received
    if !offsetReceived {
		strct._offset_ValidationError = fmt.Errorf("\"Offset\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if results (a required property) was received
    if !resultsReceived {
		strct._results_ValidationError = fmt.Errorf("\"Results\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total (a required property) was received
    if !totalReceived {
		strct._total_ValidationError = fmt.Errorf("\"Total\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressAssetsListResponse_AddressStxInboundListResponse_AddressTransactionsListResponse_AddressTransactionsWithTransfersListResponse_BlockListResponse_BurnchainRewardListResponse_BurnchainRewardSlotHolderListResponse_ContractCallTransaction_ContractListResponse_FungibleTokensMetadataList_MempoolTransactionListResponse_MicroblockListResponse_NonFungibleTokenHistoryEventList_NonFungibleTokenHoldingsList_NonFungibleTokenMint_NonFungibleTokenMintList_NonFungibleTokensMetadataList_PoisonMicroblockTransaction_RosettaPartialBlockIdentifier_TokenTransferTransaction_TransactionEventNonFungibleAsset_TransactionEventStxLock_TransactionEventsResponse_TransactionResults_UnanchoredTransactionListResponse) Validate() []error {
    var allErrors []error
    if strct._limit_ValidationError != nil {
		allErrors = append(allErrors, strct._limit_ValidationError)
	}
    if strct._offset_ValidationError != nil {
		allErrors = append(allErrors, strct._offset_ValidationError)
	}
    if strct._results_ValidationError != nil {
		allErrors = append(allErrors, strct._results_ValidationError)
	}
    if strct._total_ValidationError != nil {
		allErrors = append(allErrors, strct._total_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressBalanceResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FungibleTokens" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "fungible_tokens" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fungible_tokens\": ")
	if tmp, err := json.Marshal(strct.FungibleTokens); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NonFungibleTokens" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "non_fungible_tokens" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"non_fungible_tokens\": ")
	if tmp, err := json.Marshal(strct.NonFungibleTokens); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Stx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx\": ")
	if tmp, err := json.Marshal(strct.Stx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "token_offering_locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_offering_locked\": ")
	if tmp, err := json.Marshal(strct.TokenOfferingLocked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressBalanceResponse) UnmarshalJSON(b []byte) error {
    fungible_tokensReceived := false
    non_fungible_tokensReceived := false
    stxReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "fungible_tokens":
            if err := json.Unmarshal([]byte(v), &strct.FungibleTokens); err != nil {
				return err
            }
            fungible_tokensReceived = true
        case "non_fungible_tokens":
            if err := json.Unmarshal([]byte(v), &strct.NonFungibleTokens); err != nil {
				return err
            }
            non_fungible_tokensReceived = true
        case "stx":
            if err := json.Unmarshal([]byte(v), &strct.Stx); err != nil {
				return err
            }
            stxReceived = true
        case "token_offering_locked":
            if err := json.Unmarshal([]byte(v), &strct.TokenOfferingLocked); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if fungible_tokens (a required property) was received
    if !fungible_tokensReceived {
		strct._fungible_tokens_ValidationError = fmt.Errorf("\"FungibleTokens\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if non_fungible_tokens (a required property) was received
    if !non_fungible_tokensReceived {
		strct._non_fungible_tokens_ValidationError = fmt.Errorf("\"NonFungibleTokens\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stx (a required property) was received
    if !stxReceived {
		strct._stx_ValidationError = fmt.Errorf("\"Stx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressBalanceResponse) Validate() []error {
    var allErrors []error
    if strct._fungible_tokens_ValidationError != nil {
		allErrors = append(allErrors, strct._fungible_tokens_ValidationError)
	}
    if strct._non_fungible_tokens_ValidationError != nil {
		allErrors = append(allErrors, strct._non_fungible_tokens_ValidationError)
	}
    if strct._stx_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressNftListResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Limit" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "limit" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"limit\": ")
	if tmp, err := json.Marshal(strct.Limit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NftEvents" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nft_events" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nft_events\": ")
	if tmp, err := json.Marshal(strct.NftEvents); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Offset" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "offset" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"offset\": ")
	if tmp, err := json.Marshal(strct.Offset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Total" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total\": ")
	if tmp, err := json.Marshal(strct.Total); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressNftListResponse) UnmarshalJSON(b []byte) error {
    limitReceived := false
    nft_eventsReceived := false
    offsetReceived := false
    totalReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "limit":
            if err := json.Unmarshal([]byte(v), &strct.Limit); err != nil {
				return err
            }
            limitReceived = true
        case "nft_events":
            if err := json.Unmarshal([]byte(v), &strct.NftEvents); err != nil {
				return err
            }
            nft_eventsReceived = true
        case "offset":
            if err := json.Unmarshal([]byte(v), &strct.Offset); err != nil {
				return err
            }
            offsetReceived = true
        case "total":
            if err := json.Unmarshal([]byte(v), &strct.Total); err != nil {
				return err
            }
            totalReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if limit (a required property) was received
    if !limitReceived {
		strct._limit_ValidationError = fmt.Errorf("\"Limit\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if nft_events (a required property) was received
    if !nft_eventsReceived {
		strct._nft_events_ValidationError = fmt.Errorf("\"NftEvents\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if offset (a required property) was received
    if !offsetReceived {
		strct._offset_ValidationError = fmt.Errorf("\"Offset\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total (a required property) was received
    if !totalReceived {
		strct._total_ValidationError = fmt.Errorf("\"Total\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressNftListResponse) Validate() []error {
    var allErrors []error
    if strct._limit_ValidationError != nil {
		allErrors = append(allErrors, strct._limit_ValidationError)
	}
    if strct._nft_events_ValidationError != nil {
		allErrors = append(allErrors, strct._nft_events_ValidationError)
	}
    if strct._offset_ValidationError != nil {
		allErrors = append(allErrors, strct._offset_ValidationError)
	}
    if strct._total_ValidationError != nil {
		allErrors = append(allErrors, strct._total_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressNonces) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DetectedMissingNonces" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "detected_missing_nonces" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"detected_missing_nonces\": ")
	if tmp, err := json.Marshal(strct.DetectedMissingNonces); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LastExecutedTxNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "last_executed_tx_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"last_executed_tx_nonce\": ")
	if tmp, err := json.Marshal(strct.LastExecutedTxNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LastMempoolTxNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "last_mempool_tx_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"last_mempool_tx_nonce\": ")
	if tmp, err := json.Marshal(strct.LastMempoolTxNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PossibleNextNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "possible_next_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"possible_next_nonce\": ")
	if tmp, err := json.Marshal(strct.PossibleNextNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressNonces) UnmarshalJSON(b []byte) error {
    detected_missing_noncesReceived := false
    last_executed_tx_nonceReceived := false
    last_mempool_tx_nonceReceived := false
    possible_next_nonceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "detected_missing_nonces":
            if err := json.Unmarshal([]byte(v), &strct.DetectedMissingNonces); err != nil {
				return err
            }
            detected_missing_noncesReceived = true
        case "last_executed_tx_nonce":
            if err := json.Unmarshal([]byte(v), &strct.LastExecutedTxNonce); err != nil {
				return err
            }
            last_executed_tx_nonceReceived = true
        case "last_mempool_tx_nonce":
            if err := json.Unmarshal([]byte(v), &strct.LastMempoolTxNonce); err != nil {
				return err
            }
            last_mempool_tx_nonceReceived = true
        case "possible_next_nonce":
            if err := json.Unmarshal([]byte(v), &strct.PossibleNextNonce); err != nil {
				return err
            }
            possible_next_nonceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if detected_missing_nonces (a required property) was received
    if !detected_missing_noncesReceived {
		strct._detected_missing_nonces_ValidationError = fmt.Errorf("\"DetectedMissingNonces\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if last_executed_tx_nonce (a required property) was received
    if !last_executed_tx_nonceReceived {
		strct._last_executed_tx_nonce_ValidationError = fmt.Errorf("\"LastExecutedTxNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if last_mempool_tx_nonce (a required property) was received
    if !last_mempool_tx_nonceReceived {
		strct._last_mempool_tx_nonce_ValidationError = fmt.Errorf("\"LastMempoolTxNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if possible_next_nonce (a required property) was received
    if !possible_next_nonceReceived {
		strct._possible_next_nonce_ValidationError = fmt.Errorf("\"PossibleNextNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressNonces) Validate() []error {
    var allErrors []error
    if strct._detected_missing_nonces_ValidationError != nil {
		allErrors = append(allErrors, strct._detected_missing_nonces_ValidationError)
	}
    if strct._last_executed_tx_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._last_executed_tx_nonce_ValidationError)
	}
    if strct._last_mempool_tx_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._last_mempool_tx_nonce_ValidationError)
	}
    if strct._possible_next_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._possible_next_nonce_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Error" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "error" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"error\": ")
	if tmp, err := json.Marshal(strct.Error); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Found" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "found" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"found\": ")
	if tmp, err := json.Marshal(strct.Found); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult) UnmarshalJSON(b []byte) error {
    errorReceived := false
    foundReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "error":
            if err := json.Unmarshal([]byte(v), &strct.Error); err != nil {
				return err
            }
            errorReceived = true
        case "found":
            if err := json.Unmarshal([]byte(v), &strct.Found); err != nil {
				return err
            }
            foundReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
				return err
            }
            resultReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if error (a required property) was received
    if !errorReceived {
		strct._error_ValidationError = fmt.Errorf("\"Error\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if found (a required property) was received
    if !foundReceived {
		strct._found_ValidationError = fmt.Errorf("\"Found\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if result (a required property) was received
    if !resultReceived {
		strct._result_ValidationError = fmt.Errorf("\"Result\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressSearchResult_BlockSearchResult_BnsError_ContractSearchResult_MempoolTxSearchResult_SearchErrorResult_TransactionNotFound_TxSearchResult) Validate() []error {
    var allErrors []error
    if strct._error_ValidationError != nil {
		allErrors = append(allErrors, strct._error_ValidationError)
	}
    if strct._found_ValidationError != nil {
		allErrors = append(allErrors, strct._found_ValidationError)
	}
    if strct._result_ValidationError != nil {
		allErrors = append(allErrors, strct._result_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressTokenOfferingLocked) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TotalLocked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_locked\": ")
	if tmp, err := json.Marshal(strct.TotalLocked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalUnlocked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_unlocked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_unlocked\": ")
	if tmp, err := json.Marshal(strct.TotalUnlocked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockSchedule" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlock_schedule" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlock_schedule\": ")
	if tmp, err := json.Marshal(strct.UnlockSchedule); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressTokenOfferingLocked) UnmarshalJSON(b []byte) error {
    total_lockedReceived := false
    total_unlockedReceived := false
    unlock_scheduleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "total_locked":
            if err := json.Unmarshal([]byte(v), &strct.TotalLocked); err != nil {
				return err
            }
            total_lockedReceived = true
        case "total_unlocked":
            if err := json.Unmarshal([]byte(v), &strct.TotalUnlocked); err != nil {
				return err
            }
            total_unlockedReceived = true
        case "unlock_schedule":
            if err := json.Unmarshal([]byte(v), &strct.UnlockSchedule); err != nil {
				return err
            }
            unlock_scheduleReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if total_locked (a required property) was received
    if !total_lockedReceived {
		strct._total_locked_ValidationError = fmt.Errorf("\"TotalLocked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_unlocked (a required property) was received
    if !total_unlockedReceived {
		strct._total_unlocked_ValidationError = fmt.Errorf("\"TotalUnlocked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlock_schedule (a required property) was received
    if !unlock_scheduleReceived {
		strct._unlock_schedule_ValidationError = fmt.Errorf("\"UnlockSchedule\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressTokenOfferingLocked) Validate() []error {
    var allErrors []error
    if strct._total_locked_ValidationError != nil {
		allErrors = append(allErrors, strct._total_locked_ValidationError)
	}
    if strct._total_unlocked_ValidationError != nil {
		allErrors = append(allErrors, strct._total_unlocked_ValidationError)
	}
    if strct._unlock_schedule_ValidationError != nil {
		allErrors = append(allErrors, strct._unlock_schedule_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressTransactionWithTransfers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ft_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"ft_transfers\": ")
	if tmp, err := json.Marshal(strct.FtTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nft_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nft_transfers\": ")
	if tmp, err := json.Marshal(strct.NftTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_received\": ")
	if tmp, err := json.Marshal(strct.StxReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_sent\": ")
	if tmp, err := json.Marshal(strct.StxSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxTransfers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_transfers\": ")
	if tmp, err := json.Marshal(strct.StxTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressTransactionWithTransfers) UnmarshalJSON(b []byte) error {
    stx_receivedReceived := false
    stx_sentReceived := false
    stx_transfersReceived := false
    txReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ft_transfers":
            if err := json.Unmarshal([]byte(v), &strct.FtTransfers); err != nil {
				return err
            }
        case "nft_transfers":
            if err := json.Unmarshal([]byte(v), &strct.NftTransfers); err != nil {
				return err
            }
        case "stx_received":
            if err := json.Unmarshal([]byte(v), &strct.StxReceived); err != nil {
				return err
            }
            stx_receivedReceived = true
        case "stx_sent":
            if err := json.Unmarshal([]byte(v), &strct.StxSent); err != nil {
				return err
            }
            stx_sentReceived = true
        case "stx_transfers":
            if err := json.Unmarshal([]byte(v), &strct.StxTransfers); err != nil {
				return err
            }
            stx_transfersReceived = true
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if stx_received (a required property) was received
    if !stx_receivedReceived {
		strct._stx_received_ValidationError = fmt.Errorf("\"StxReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stx_sent (a required property) was received
    if !stx_sentReceived {
		strct._stx_sent_ValidationError = fmt.Errorf("\"StxSent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stx_transfers (a required property) was received
    if !stx_transfersReceived {
		strct._stx_transfers_ValidationError = fmt.Errorf("\"StxTransfers\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressTransactionWithTransfers) Validate() []error {
    var allErrors []error
    if strct._stx_received_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_received_ValidationError)
	}
    if strct._stx_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_sent_ValidationError)
	}
    if strct._stx_transfers_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_transfers_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Memo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransferType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transfer_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transfer_type\": ")
	if tmp, err := json.Marshal(strct.TransferType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_index\": ")
	if tmp, err := json.Marshal(strct.TxIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) UnmarshalJSON(b []byte) error {
    amountReceived := false
    block_heightReceived := false
    memoReceived := false
    senderReceived := false
    transfer_typeReceived := false
    tx_idReceived := false
    tx_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
            memoReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        case "transfer_type":
            if err := json.Unmarshal([]byte(v), &strct.TransferType); err != nil {
				return err
            }
            transfer_typeReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "tx_index":
            if err := json.Unmarshal([]byte(v), &strct.TxIndex); err != nil {
				return err
            }
            tx_indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if memo (a required property) was received
    if !memoReceived {
		strct._memo_ValidationError = fmt.Errorf("\"Memo\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transfer_type (a required property) was received
    if !transfer_typeReceived {
		strct._transfer_type_ValidationError = fmt.Errorf("\"TransferType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_index (a required property) was received
    if !tx_indexReceived {
		strct._tx_index_ValidationError = fmt.Errorf("\"TxIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._memo_ValidationError != nil {
		allErrors = append(allErrors, strct._memo_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if strct._transfer_type_ValidationError != nil {
		allErrors = append(allErrors, strct._transfer_type_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._tx_index_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Allow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Errors" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "errors" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"errors\": ")
	if tmp, err := json.Marshal(strct.Errors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "HistoricalBalanceLookup" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "historical_balance_lookup" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"historical_balance_lookup\": ")
	if tmp, err := json.Marshal(strct.HistoricalBalanceLookup); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "OperationStatuses" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operation_statuses" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operation_statuses\": ")
	if tmp, err := json.Marshal(strct.OperationStatuses); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "OperationTypes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operation_types" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operation_types\": ")
	if tmp, err := json.Marshal(strct.OperationTypes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Allow) UnmarshalJSON(b []byte) error {
    errorsReceived := false
    historical_balance_lookupReceived := false
    operation_statusesReceived := false
    operation_typesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "errors":
            if err := json.Unmarshal([]byte(v), &strct.Errors); err != nil {
				return err
            }
            errorsReceived = true
        case "historical_balance_lookup":
            if err := json.Unmarshal([]byte(v), &strct.HistoricalBalanceLookup); err != nil {
				return err
            }
            historical_balance_lookupReceived = true
        case "operation_statuses":
            if err := json.Unmarshal([]byte(v), &strct.OperationStatuses); err != nil {
				return err
            }
            operation_statusesReceived = true
        case "operation_types":
            if err := json.Unmarshal([]byte(v), &strct.OperationTypes); err != nil {
				return err
            }
            operation_typesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if errors (a required property) was received
    if !errorsReceived {
		strct._errors_ValidationError = fmt.Errorf("\"Errors\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if historical_balance_lookup (a required property) was received
    if !historical_balance_lookupReceived {
		strct._historical_balance_lookup_ValidationError = fmt.Errorf("\"HistoricalBalanceLookup\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if operation_statuses (a required property) was received
    if !operation_statusesReceived {
		strct._operation_statuses_ValidationError = fmt.Errorf("\"OperationStatuses\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if operation_types (a required property) was received
    if !operation_typesReceived {
		strct._operation_types_ValidationError = fmt.Errorf("\"OperationTypes\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Allow) Validate() []error {
    var allErrors []error
    if strct._errors_ValidationError != nil {
		allErrors = append(allErrors, strct._errors_ValidationError)
	}
    if strct._historical_balance_lookup_ValidationError != nil {
		allErrors = append(allErrors, strct._historical_balance_lookup_ValidationError)
	}
    if strct._operation_statuses_ValidationError != nil {
		allErrors = append(allErrors, strct._operation_statuses_ValidationError)
	}
    if strct._operation_types_ValidationError != nil {
		allErrors = append(allErrors, strct._operation_types_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BaseTransaction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AnchorMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "anchor_mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"anchor_mode\": ")
	if tmp, err := json.Marshal(strct.AnchorMode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FeeRate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "fee_rate" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fee_rate\": ")
	if tmp, err := json.Marshal(strct.FeeRate); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Nonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nonce\": ")
	if tmp, err := json.Marshal(strct.Nonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PostConditionMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "post_condition_mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"post_condition_mode\": ")
	if tmp, err := json.Marshal(strct.PostConditionMode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PostConditions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "post_conditions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"post_conditions\": ")
	if tmp, err := json.Marshal(strct.PostConditions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SenderAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sponsor_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsor_address\": ")
	if tmp, err := json.Marshal(strct.SponsorAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sponsor_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsor_nonce\": ")
	if tmp, err := json.Marshal(strct.SponsorNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sponsored" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sponsored" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsored\": ")
	if tmp, err := json.Marshal(strct.Sponsored); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaseTransaction) UnmarshalJSON(b []byte) error {
    anchor_modeReceived := false
    fee_rateReceived := false
    nonceReceived := false
    post_condition_modeReceived := false
    post_conditionsReceived := false
    sender_addressReceived := false
    sponsoredReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "anchor_mode":
            if err := json.Unmarshal([]byte(v), &strct.AnchorMode); err != nil {
				return err
            }
            anchor_modeReceived = true
        case "fee_rate":
            if err := json.Unmarshal([]byte(v), &strct.FeeRate); err != nil {
				return err
            }
            fee_rateReceived = true
        case "nonce":
            if err := json.Unmarshal([]byte(v), &strct.Nonce); err != nil {
				return err
            }
            nonceReceived = true
        case "post_condition_mode":
            if err := json.Unmarshal([]byte(v), &strct.PostConditionMode); err != nil {
				return err
            }
            post_condition_modeReceived = true
        case "post_conditions":
            if err := json.Unmarshal([]byte(v), &strct.PostConditions); err != nil {
				return err
            }
            post_conditionsReceived = true
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
            sender_addressReceived = true
        case "sponsor_address":
            if err := json.Unmarshal([]byte(v), &strct.SponsorAddress); err != nil {
				return err
            }
        case "sponsor_nonce":
            if err := json.Unmarshal([]byte(v), &strct.SponsorNonce); err != nil {
				return err
            }
        case "sponsored":
            if err := json.Unmarshal([]byte(v), &strct.Sponsored); err != nil {
				return err
            }
            sponsoredReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if anchor_mode (a required property) was received
    if !anchor_modeReceived {
		strct._anchor_mode_ValidationError = fmt.Errorf("\"AnchorMode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if fee_rate (a required property) was received
    if !fee_rateReceived {
		strct._fee_rate_ValidationError = fmt.Errorf("\"FeeRate\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if nonce (a required property) was received
    if !nonceReceived {
		strct._nonce_ValidationError = fmt.Errorf("\"Nonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if post_condition_mode (a required property) was received
    if !post_condition_modeReceived {
		strct._post_condition_mode_ValidationError = fmt.Errorf("\"PostConditionMode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if post_conditions (a required property) was received
    if !post_conditionsReceived {
		strct._post_conditions_ValidationError = fmt.Errorf("\"PostConditions\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender_address (a required property) was received
    if !sender_addressReceived {
		strct._sender_address_ValidationError = fmt.Errorf("\"SenderAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sponsored (a required property) was received
    if !sponsoredReceived {
		strct._sponsored_ValidationError = fmt.Errorf("\"Sponsored\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BaseTransaction) Validate() []error {
    var allErrors []error
    if strct._anchor_mode_ValidationError != nil {
		allErrors = append(allErrors, strct._anchor_mode_ValidationError)
	}
    if strct._fee_rate_ValidationError != nil {
		allErrors = append(allErrors, strct._fee_rate_ValidationError)
	}
    if strct._nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._nonce_ValidationError)
	}
    if strct._post_condition_mode_ValidationError != nil {
		allErrors = append(allErrors, strct._post_condition_mode_ValidationError)
	}
    if strct._post_conditions_ValidationError != nil {
		allErrors = append(allErrors, strct._post_conditions_ValidationError)
	}
    if strct._sender_address_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_address_ValidationError)
	}
    if strct._sponsored_ValidationError != nil {
		allErrors = append(allErrors, strct._sponsored_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BlockData) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Hash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hash\": ")
	if tmp, err := json.Marshal(strct.Hash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Height" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"height\": ")
	if tmp, err := json.Marshal(strct.Height); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BlockData) UnmarshalJSON(b []byte) error {
    burn_block_timeReceived := false
    canonicalReceived := false
    hashReceived := false
    heightReceived := false
    parent_block_hashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTime); err != nil {
				return err
            }
            burn_block_timeReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "hash":
            if err := json.Unmarshal([]byte(v), &strct.Hash); err != nil {
				return err
            }
            hashReceived = true
        case "height":
            if err := json.Unmarshal([]byte(v), &strct.Height); err != nil {
				return err
            }
            heightReceived = true
        case "parent_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHash); err != nil {
				return err
            }
            parent_block_hashReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_block_time (a required property) was received
    if !burn_block_timeReceived {
		strct._burn_block_time_ValidationError = fmt.Errorf("\"BurnBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if hash (a required property) was received
    if !hashReceived {
		strct._hash_ValidationError = fmt.Errorf("\"Hash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if height (a required property) was received
    if !heightReceived {
		strct._height_ValidationError = fmt.Errorf("\"Height\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_hash (a required property) was received
    if !parent_block_hashReceived {
		strct._parent_block_hash_ValidationError = fmt.Errorf("\"ParentBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BlockData) Validate() []error {
    var allErrors []error
    if strct._burn_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_time_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._hash_ValidationError != nil {
		allErrors = append(allErrors, strct._hash_ValidationError)
	}
    if strct._height_ValidationError != nil {
		allErrors = append(allErrors, strct._height_ValidationError)
	}
    if strct._parent_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_hash_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockTimeIso" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_time_iso" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time_iso\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTimeIso); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostReadCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_read_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_read_count\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostReadCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostReadLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_read_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_read_length\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostReadLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostRuntime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_runtime" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_runtime\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostRuntime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostWriteCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_write_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_write_count\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostWriteCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostWriteLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_write_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_write_length\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostWriteLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Hash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hash\": ")
	if tmp, err := json.Marshal(strct.Hash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Height" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"height\": ")
	if tmp, err := json.Marshal(strct.Height); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblocksAccepted" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblocks_accepted" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblocks_accepted\": ")
	if tmp, err := json.Marshal(strct.MicroblocksAccepted); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblocksStreamed" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblocks_streamed" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblocks_streamed\": ")
	if tmp, err := json.Marshal(strct.MicroblocksStreamed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MinerTxid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "miner_txid" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"miner_txid\": ")
	if tmp, err := json.Marshal(strct.MinerTxid); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentMicroblockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_microblock_hash\": ")
	if tmp, err := json.Marshal(strct.ParentMicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentMicroblockSequence" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.ParentMicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Txs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "txs" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txs\": ")
	if tmp, err := json.Marshal(strct.Txs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) UnmarshalJSON(b []byte) error {
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    burn_block_timeReceived := false
    burn_block_time_isoReceived := false
    canonicalReceived := false
    execution_cost_read_countReceived := false
    execution_cost_read_lengthReceived := false
    execution_cost_runtimeReceived := false
    execution_cost_write_countReceived := false
    execution_cost_write_lengthReceived := false
    hashReceived := false
    heightReceived := false
    microblocks_acceptedReceived := false
    microblocks_streamedReceived := false
    miner_txidReceived := false
    parent_block_hashReceived := false
    parent_microblock_hashReceived := false
    parent_microblock_sequenceReceived := false
    txsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTime); err != nil {
				return err
            }
            burn_block_timeReceived = true
        case "burn_block_time_iso":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTimeIso); err != nil {
				return err
            }
            burn_block_time_isoReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "execution_cost_read_count":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostReadCount); err != nil {
				return err
            }
            execution_cost_read_countReceived = true
        case "execution_cost_read_length":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostReadLength); err != nil {
				return err
            }
            execution_cost_read_lengthReceived = true
        case "execution_cost_runtime":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostRuntime); err != nil {
				return err
            }
            execution_cost_runtimeReceived = true
        case "execution_cost_write_count":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostWriteCount); err != nil {
				return err
            }
            execution_cost_write_countReceived = true
        case "execution_cost_write_length":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostWriteLength); err != nil {
				return err
            }
            execution_cost_write_lengthReceived = true
        case "hash":
            if err := json.Unmarshal([]byte(v), &strct.Hash); err != nil {
				return err
            }
            hashReceived = true
        case "height":
            if err := json.Unmarshal([]byte(v), &strct.Height); err != nil {
				return err
            }
            heightReceived = true
        case "microblocks_accepted":
            if err := json.Unmarshal([]byte(v), &strct.MicroblocksAccepted); err != nil {
				return err
            }
            microblocks_acceptedReceived = true
        case "microblocks_streamed":
            if err := json.Unmarshal([]byte(v), &strct.MicroblocksStreamed); err != nil {
				return err
            }
            microblocks_streamedReceived = true
        case "miner_txid":
            if err := json.Unmarshal([]byte(v), &strct.MinerTxid); err != nil {
				return err
            }
            miner_txidReceived = true
        case "parent_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHash); err != nil {
				return err
            }
            parent_block_hashReceived = true
        case "parent_microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentMicroblockHash); err != nil {
				return err
            }
            parent_microblock_hashReceived = true
        case "parent_microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.ParentMicroblockSequence); err != nil {
				return err
            }
            parent_microblock_sequenceReceived = true
        case "txs":
            if err := json.Unmarshal([]byte(v), &strct.Txs); err != nil {
				return err
            }
            txsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_time (a required property) was received
    if !burn_block_timeReceived {
		strct._burn_block_time_ValidationError = fmt.Errorf("\"BurnBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_time_iso (a required property) was received
    if !burn_block_time_isoReceived {
		strct._burn_block_time_iso_ValidationError = fmt.Errorf("\"BurnBlockTimeIso\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_read_count (a required property) was received
    if !execution_cost_read_countReceived {
		strct._execution_cost_read_count_ValidationError = fmt.Errorf("\"ExecutionCostReadCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_read_length (a required property) was received
    if !execution_cost_read_lengthReceived {
		strct._execution_cost_read_length_ValidationError = fmt.Errorf("\"ExecutionCostReadLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_runtime (a required property) was received
    if !execution_cost_runtimeReceived {
		strct._execution_cost_runtime_ValidationError = fmt.Errorf("\"ExecutionCostRuntime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_write_count (a required property) was received
    if !execution_cost_write_countReceived {
		strct._execution_cost_write_count_ValidationError = fmt.Errorf("\"ExecutionCostWriteCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_write_length (a required property) was received
    if !execution_cost_write_lengthReceived {
		strct._execution_cost_write_length_ValidationError = fmt.Errorf("\"ExecutionCostWriteLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if hash (a required property) was received
    if !hashReceived {
		strct._hash_ValidationError = fmt.Errorf("\"Hash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if height (a required property) was received
    if !heightReceived {
		strct._height_ValidationError = fmt.Errorf("\"Height\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblocks_accepted (a required property) was received
    if !microblocks_acceptedReceived {
		strct._microblocks_accepted_ValidationError = fmt.Errorf("\"MicroblocksAccepted\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblocks_streamed (a required property) was received
    if !microblocks_streamedReceived {
		strct._microblocks_streamed_ValidationError = fmt.Errorf("\"MicroblocksStreamed\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if miner_txid (a required property) was received
    if !miner_txidReceived {
		strct._miner_txid_ValidationError = fmt.Errorf("\"MinerTxid\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_hash (a required property) was received
    if !parent_block_hashReceived {
		strct._parent_block_hash_ValidationError = fmt.Errorf("\"ParentBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_microblock_hash (a required property) was received
    if !parent_microblock_hashReceived {
		strct._parent_microblock_hash_ValidationError = fmt.Errorf("\"ParentMicroblockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_microblock_sequence (a required property) was received
    if !parent_microblock_sequenceReceived {
		strct._parent_microblock_sequence_ValidationError = fmt.Errorf("\"ParentMicroblockSequence\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if txs (a required property) was received
    if !txsReceived {
		strct._txs_ValidationError = fmt.Errorf("\"Txs\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) Validate() []error {
    var allErrors []error
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._burn_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_time_ValidationError)
	}
    if strct._burn_block_time_iso_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_time_iso_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._execution_cost_read_count_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_read_count_ValidationError)
	}
    if strct._execution_cost_read_length_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_read_length_ValidationError)
	}
    if strct._execution_cost_runtime_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_runtime_ValidationError)
	}
    if strct._execution_cost_write_count_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_write_count_ValidationError)
	}
    if strct._execution_cost_write_length_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_write_length_ValidationError)
	}
    if strct._hash_ValidationError != nil {
		allErrors = append(allErrors, strct._hash_ValidationError)
	}
    if strct._height_ValidationError != nil {
		allErrors = append(allErrors, strct._height_ValidationError)
	}
    if strct._microblocks_accepted_ValidationError != nil {
		allErrors = append(allErrors, strct._microblocks_accepted_ValidationError)
	}
    if strct._microblocks_streamed_ValidationError != nil {
		allErrors = append(allErrors, strct._microblocks_streamed_ValidationError)
	}
    if strct._miner_txid_ValidationError != nil {
		allErrors = append(allErrors, strct._miner_txid_ValidationError)
	}
    if strct._parent_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_hash_ValidationError)
	}
    if strct._parent_microblock_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_microblock_hash_ValidationError)
	}
    if strct._parent_microblock_sequence_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_microblock_sequence_ValidationError)
	}
    if strct._txs_ValidationError != nil {
		allErrors = append(allErrors, strct._txs_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BnsGetAllNamespacesResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Namespaces" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "namespaces" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"namespaces\": ")
	if tmp, err := json.Marshal(strct.Namespaces); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BnsGetAllNamespacesResponse) UnmarshalJSON(b []byte) error {
    namespacesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "namespaces":
            if err := json.Unmarshal([]byte(v), &strct.Namespaces); err != nil {
				return err
            }
            namespacesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if namespaces (a required property) was received
    if !namespacesReceived {
		strct._namespaces_ValidationError = fmt.Errorf("\"Namespaces\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BnsGetAllNamespacesResponse) Validate() []error {
    var allErrors []error
    if strct._namespaces_ValidationError != nil {
		allErrors = append(allErrors, strct._namespaces_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BnsGetNameInfoResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Blockchain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blockchain" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"blockchain\": ")
	if tmp, err := json.Marshal(strct.Blockchain); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "expire_block" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"expire_block\": ")
	if tmp, err := json.Marshal(strct.ExpireBlock); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "grace_period" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"grace_period\": ")
	if tmp, err := json.Marshal(strct.GracePeriod); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LastTxid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "last_txid" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"last_txid\": ")
	if tmp, err := json.Marshal(strct.LastTxid); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "resolver" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"resolver\": ")
	if tmp, err := json.Marshal(strct.Resolver); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Zonefile" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "zonefile" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"zonefile\": ")
	if tmp, err := json.Marshal(strct.Zonefile); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ZonefileHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "zonefile_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"zonefile_hash\": ")
	if tmp, err := json.Marshal(strct.ZonefileHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BnsGetNameInfoResponse) UnmarshalJSON(b []byte) error {
    addressReceived := false
    blockchainReceived := false
    last_txidReceived := false
    statusReceived := false
    zonefileReceived := false
    zonefile_hashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "blockchain":
            if err := json.Unmarshal([]byte(v), &strct.Blockchain); err != nil {
				return err
            }
            blockchainReceived = true
        case "expire_block":
            if err := json.Unmarshal([]byte(v), &strct.ExpireBlock); err != nil {
				return err
            }
        case "grace_period":
            if err := json.Unmarshal([]byte(v), &strct.GracePeriod); err != nil {
				return err
            }
        case "last_txid":
            if err := json.Unmarshal([]byte(v), &strct.LastTxid); err != nil {
				return err
            }
            last_txidReceived = true
        case "resolver":
            if err := json.Unmarshal([]byte(v), &strct.Resolver); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
            statusReceived = true
        case "zonefile":
            if err := json.Unmarshal([]byte(v), &strct.Zonefile); err != nil {
				return err
            }
            zonefileReceived = true
        case "zonefile_hash":
            if err := json.Unmarshal([]byte(v), &strct.ZonefileHash); err != nil {
				return err
            }
            zonefile_hashReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if blockchain (a required property) was received
    if !blockchainReceived {
		strct._blockchain_ValidationError = fmt.Errorf("\"Blockchain\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if last_txid (a required property) was received
    if !last_txidReceived {
		strct._last_txid_ValidationError = fmt.Errorf("\"LastTxid\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if status (a required property) was received
    if !statusReceived {
		strct._status_ValidationError = fmt.Errorf("\"Status\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if zonefile (a required property) was received
    if !zonefileReceived {
		strct._zonefile_ValidationError = fmt.Errorf("\"Zonefile\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if zonefile_hash (a required property) was received
    if !zonefile_hashReceived {
		strct._zonefile_hash_ValidationError = fmt.Errorf("\"ZonefileHash\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BnsGetNameInfoResponse) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._blockchain_ValidationError != nil {
		allErrors = append(allErrors, strct._blockchain_ValidationError)
	}
    if strct._last_txid_ValidationError != nil {
		allErrors = append(allErrors, strct._last_txid_ValidationError)
	}
    if strct._status_ValidationError != nil {
		allErrors = append(allErrors, strct._status_ValidationError)
	}
    if strct._zonefile_ValidationError != nil {
		allErrors = append(allErrors, strct._zonefile_ValidationError)
	}
    if strct._zonefile_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._zonefile_hash_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BnsGetNamePriceResponse_BnsGetNamespacePriceResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Units" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "units" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"units\": ")
	if tmp, err := json.Marshal(strct.Units); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BnsGetNamePriceResponse_BnsGetNamespacePriceResponse) UnmarshalJSON(b []byte) error {
    amountReceived := false
    unitsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "units":
            if err := json.Unmarshal([]byte(v), &strct.Units); err != nil {
				return err
            }
            unitsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if units (a required property) was received
    if !unitsReceived {
		strct._units_ValidationError = fmt.Errorf("\"Units\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BnsGetNamePriceResponse_BnsGetNamespacePriceResponse) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._units_ValidationError != nil {
		allErrors = append(allErrors, strct._units_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BnsGetSubdomainAtTxItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "accepted" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"accepted\": ")
	if tmp, err := json.Marshal(strct.Accepted); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "domain" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"domain\": ")
	if tmp, err := json.Marshal(strct.Domain); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "fully_qualified_subdomain" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fully_qualified_subdomain\": ")
	if tmp, err := json.Marshal(strct.FullyQualifiedSubdomain); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "missing" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"missing\": ")
	if tmp, err := json.Marshal(strct.Missing); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "owner" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"owner\": ")
	if tmp, err := json.Marshal(strct.Owner); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parent_zonefile_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_zonefile_hash\": ")
	if tmp, err := json.Marshal(strct.ParentZonefileHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parent_zonefile_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_zonefile_index\": ")
	if tmp, err := json.Marshal(strct.ParentZonefileIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "resolver" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"resolver\": ")
	if tmp, err := json.Marshal(strct.Resolver); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sequence\": ")
	if tmp, err := json.Marshal(strct.Sequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "signature" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signature\": ")
	if tmp, err := json.Marshal(strct.Signature); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "txid" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txid\": ")
	if tmp, err := json.Marshal(strct.Txid); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "zonefile_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"zonefile_hash\": ")
	if tmp, err := json.Marshal(strct.ZonefileHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "zonefile_offset" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"zonefile_offset\": ")
	if tmp, err := json.Marshal(strct.ZonefileOffset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BnsGetSubdomainAtTxItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "accepted":
            if err := json.Unmarshal([]byte(v), &strct.Accepted); err != nil {
				return err
            }
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
        case "domain":
            if err := json.Unmarshal([]byte(v), &strct.Domain); err != nil {
				return err
            }
        case "fully_qualified_subdomain":
            if err := json.Unmarshal([]byte(v), &strct.FullyQualifiedSubdomain); err != nil {
				return err
            }
        case "missing":
            if err := json.Unmarshal([]byte(v), &strct.Missing); err != nil {
				return err
            }
        case "owner":
            if err := json.Unmarshal([]byte(v), &strct.Owner); err != nil {
				return err
            }
        case "parent_zonefile_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentZonefileHash); err != nil {
				return err
            }
        case "parent_zonefile_index":
            if err := json.Unmarshal([]byte(v), &strct.ParentZonefileIndex); err != nil {
				return err
            }
        case "resolver":
            if err := json.Unmarshal([]byte(v), &strct.Resolver); err != nil {
				return err
            }
        case "sequence":
            if err := json.Unmarshal([]byte(v), &strct.Sequence); err != nil {
				return err
            }
        case "signature":
            if err := json.Unmarshal([]byte(v), &strct.Signature); err != nil {
				return err
            }
        case "txid":
            if err := json.Unmarshal([]byte(v), &strct.Txid); err != nil {
				return err
            }
        case "zonefile_hash":
            if err := json.Unmarshal([]byte(v), &strct.ZonefileHash); err != nil {
				return err
            }
        case "zonefile_offset":
            if err := json.Unmarshal([]byte(v), &strct.ZonefileOffset); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *BnsGetSubdomainAtTxItems) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BnsNamesOwnByAddressResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Names" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "names" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"names\": ")
	if tmp, err := json.Marshal(strct.Names); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BnsNamesOwnByAddressResponse) UnmarshalJSON(b []byte) error {
    namesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "names":
            if err := json.Unmarshal([]byte(v), &strct.Names); err != nil {
				return err
            }
            namesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if names (a required property) was received
    if !namesReceived {
		strct._names_ValidationError = fmt.Errorf("\"Names\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BnsNamesOwnByAddressResponse) Validate() []error {
    var allErrors []error
    if strct._names_ValidationError != nil {
		allErrors = append(allErrors, strct._names_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BurnchainRewardSlotHolder) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SlotIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "slot_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"slot_index\": ")
	if tmp, err := json.Marshal(strct.SlotIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BurnchainRewardSlotHolder) UnmarshalJSON(b []byte) error {
    addressReceived := false
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    canonicalReceived := false
    slot_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "slot_index":
            if err := json.Unmarshal([]byte(v), &strct.SlotIndex); err != nil {
				return err
            }
            slot_indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if slot_index (a required property) was received
    if !slot_indexReceived {
		strct._slot_index_ValidationError = fmt.Errorf("\"SlotIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BurnchainRewardSlotHolder) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._slot_index_ValidationError != nil {
		allErrors = append(allErrors, strct._slot_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnAmount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_amount\": ")
	if tmp, err := json.Marshal(strct.BurnAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardAmount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_amount\": ")
	if tmp, err := json.Marshal(strct.RewardAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_index\": ")
	if tmp, err := json.Marshal(strct.RewardIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardRecipient" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_recipient\": ")
	if tmp, err := json.Marshal(strct.RewardRecipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) UnmarshalJSON(b []byte) error {
    burn_amountReceived := false
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    canonicalReceived := false
    reward_amountReceived := false
    reward_indexReceived := false
    reward_recipientReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_amount":
            if err := json.Unmarshal([]byte(v), &strct.BurnAmount); err != nil {
				return err
            }
            burn_amountReceived = true
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "reward_amount":
            if err := json.Unmarshal([]byte(v), &strct.RewardAmount); err != nil {
				return err
            }
            reward_amountReceived = true
        case "reward_index":
            if err := json.Unmarshal([]byte(v), &strct.RewardIndex); err != nil {
				return err
            }
            reward_indexReceived = true
        case "reward_recipient":
            if err := json.Unmarshal([]byte(v), &strct.RewardRecipient); err != nil {
				return err
            }
            reward_recipientReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_amount (a required property) was received
    if !burn_amountReceived {
		strct._burn_amount_ValidationError = fmt.Errorf("\"BurnAmount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_amount (a required property) was received
    if !reward_amountReceived {
		strct._reward_amount_ValidationError = fmt.Errorf("\"RewardAmount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_index (a required property) was received
    if !reward_indexReceived {
		strct._reward_index_ValidationError = fmt.Errorf("\"RewardIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_recipient (a required property) was received
    if !reward_recipientReceived {
		strct._reward_recipient_ValidationError = fmt.Errorf("\"RewardRecipient\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) Validate() []error {
    var allErrors []error
    if strct._burn_amount_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_amount_ValidationError)
	}
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._reward_amount_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_amount_ValidationError)
	}
    if strct._reward_index_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_index_ValidationError)
	}
    if strct._reward_recipient_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_recipient_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ChainTip) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_hash\": ")
	if tmp, err := json.Marshal(strct.BlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "IndexBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index_block_hash\": ")
	if tmp, err := json.Marshal(strct.IndexBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.MicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChainTip) UnmarshalJSON(b []byte) error {
    block_hashReceived := false
    block_heightReceived := false
    index_block_hashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BlockHash); err != nil {
				return err
            }
            block_hashReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "index_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.IndexBlockHash); err != nil {
				return err
            }
            index_block_hashReceived = true
        case "microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHash); err != nil {
				return err
            }
        case "microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockSequence); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_hash (a required property) was received
    if !block_hashReceived {
		strct._block_hash_ValidationError = fmt.Errorf("\"BlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if index_block_hash (a required property) was received
    if !index_block_hashReceived {
		strct._index_block_hash_ValidationError = fmt.Errorf("\"IndexBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ChainTip) Validate() []error {
    var allErrors []error
    if strct._block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._block_hash_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._index_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._index_block_hash_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Identifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinIdentifier) UnmarshalJSON(b []byte) error {
    identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
				return err
            }
            identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if identifier (a required property) was received
    if !identifierReceived {
		strct._identifier_ValidationError = fmt.Errorf("\"Identifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinIdentifier) Validate() []error {
    var allErrors []error
    if strct._identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinbasePayload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Data" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinbasePayload) UnmarshalJSON(b []byte) error {
    dataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
				return err
            }
            dataReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if data (a required property) was received
    if !dataReceived {
		strct._data_ValidationError = fmt.Errorf("\"Data\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinbasePayload) Validate() []error {
    var allErrors []error
    if strct._data_ValidationError != nil {
		allErrors = append(allErrors, strct._data_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinbaseTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CoinbasePayload" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coinbase_payload" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coinbase_payload\": ")
	if tmp, err := json.Marshal(strct.CoinbasePayload); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinbaseTransactionMetadata) UnmarshalJSON(b []byte) error {
    coinbase_payloadReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "coinbase_payload":
            if err := json.Unmarshal([]byte(v), &strct.CoinbasePayload); err != nil {
				return err
            }
            coinbase_payloadReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if coinbase_payload (a required property) was received
    if !coinbase_payloadReceived {
		strct._coinbase_payload_ValidationError = fmt.Errorf("\"CoinbasePayload\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinbaseTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._coinbase_payload_ValidationError != nil {
		allErrors = append(allErrors, strct._coinbase_payload_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractCall) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_id\": ")
	if tmp, err := json.Marshal(strct.ContractId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "function_args" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_args\": ")
	if tmp, err := json.Marshal(strct.FunctionArgs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FunctionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "function_name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_name\": ")
	if tmp, err := json.Marshal(strct.FunctionName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FunctionSignature" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "function_signature" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_signature\": ")
	if tmp, err := json.Marshal(strct.FunctionSignature); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractCall) UnmarshalJSON(b []byte) error {
    contract_idReceived := false
    function_nameReceived := false
    function_signatureReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_id":
            if err := json.Unmarshal([]byte(v), &strct.ContractId); err != nil {
				return err
            }
            contract_idReceived = true
        case "function_args":
            if err := json.Unmarshal([]byte(v), &strct.FunctionArgs); err != nil {
				return err
            }
        case "function_name":
            if err := json.Unmarshal([]byte(v), &strct.FunctionName); err != nil {
				return err
            }
            function_nameReceived = true
        case "function_signature":
            if err := json.Unmarshal([]byte(v), &strct.FunctionSignature); err != nil {
				return err
            }
            function_signatureReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_id (a required property) was received
    if !contract_idReceived {
		strct._contract_id_ValidationError = fmt.Errorf("\"ContractId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if function_name (a required property) was received
    if !function_nameReceived {
		strct._function_name_ValidationError = fmt.Errorf("\"FunctionName\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if function_signature (a required property) was received
    if !function_signatureReceived {
		strct._function_signature_ValidationError = fmt.Errorf("\"FunctionSignature\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractCall) Validate() []error {
    var allErrors []error
    if strct._contract_id_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_id_ValidationError)
	}
    if strct._function_name_ValidationError != nil {
		allErrors = append(allErrors, strct._function_name_ValidationError)
	}
    if strct._function_signature_ValidationError != nil {
		allErrors = append(allErrors, strct._function_signature_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractCallTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractCall" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_call" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_call\": ")
	if tmp, err := json.Marshal(strct.ContractCall); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractCallTransactionMetadata) UnmarshalJSON(b []byte) error {
    contract_callReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_call":
            if err := json.Unmarshal([]byte(v), &strct.ContractCall); err != nil {
				return err
            }
            contract_callReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_call (a required property) was received
    if !contract_callReceived {
		strct._contract_call_ValidationError = fmt.Errorf("\"ContractCall\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractCallTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._contract_call_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_call_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractInterfaceResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Functions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "functions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"functions\": ")
	if tmp, err := json.Marshal(strct.Functions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FungibleTokens" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "fungible_tokens" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fungible_tokens\": ")
	if tmp, err := json.Marshal(strct.FungibleTokens); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Maps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "maps" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"maps\": ")
	if tmp, err := json.Marshal(strct.Maps); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NonFungibleTokens" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "non_fungible_tokens" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"non_fungible_tokens\": ")
	if tmp, err := json.Marshal(strct.NonFungibleTokens); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Variables" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "variables" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractInterfaceResponse) UnmarshalJSON(b []byte) error {
    functionsReceived := false
    fungible_tokensReceived := false
    mapsReceived := false
    non_fungible_tokensReceived := false
    variablesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "functions":
            if err := json.Unmarshal([]byte(v), &strct.Functions); err != nil {
				return err
            }
            functionsReceived = true
        case "fungible_tokens":
            if err := json.Unmarshal([]byte(v), &strct.FungibleTokens); err != nil {
				return err
            }
            fungible_tokensReceived = true
        case "maps":
            if err := json.Unmarshal([]byte(v), &strct.Maps); err != nil {
				return err
            }
            mapsReceived = true
        case "non_fungible_tokens":
            if err := json.Unmarshal([]byte(v), &strct.NonFungibleTokens); err != nil {
				return err
            }
            non_fungible_tokensReceived = true
        case "variables":
            if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
				return err
            }
            variablesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if functions (a required property) was received
    if !functionsReceived {
		strct._functions_ValidationError = fmt.Errorf("\"Functions\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if fungible_tokens (a required property) was received
    if !fungible_tokensReceived {
		strct._fungible_tokens_ValidationError = fmt.Errorf("\"FungibleTokens\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if maps (a required property) was received
    if !mapsReceived {
		strct._maps_ValidationError = fmt.Errorf("\"Maps\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if non_fungible_tokens (a required property) was received
    if !non_fungible_tokensReceived {
		strct._non_fungible_tokens_ValidationError = fmt.Errorf("\"NonFungibleTokens\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if variables (a required property) was received
    if !variablesReceived {
		strct._variables_ValidationError = fmt.Errorf("\"Variables\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractInterfaceResponse) Validate() []error {
    var allErrors []error
    if strct._functions_ValidationError != nil {
		allErrors = append(allErrors, strct._functions_ValidationError)
	}
    if strct._fungible_tokens_ValidationError != nil {
		allErrors = append(allErrors, strct._fungible_tokens_ValidationError)
	}
    if strct._maps_ValidationError != nil {
		allErrors = append(allErrors, strct._maps_ValidationError)
	}
    if strct._non_fungible_tokens_ValidationError != nil {
		allErrors = append(allErrors, strct._non_fungible_tokens_ValidationError)
	}
    if strct._variables_ValidationError != nil {
		allErrors = append(allErrors, strct._variables_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractSourceResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Proof" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "proof" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"proof\": ")
	if tmp, err := json.Marshal(strct.Proof); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PublishHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "publish_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"publish_height\": ")
	if tmp, err := json.Marshal(strct.PublishHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Source" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "source" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"source\": ")
	if tmp, err := json.Marshal(strct.Source); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractSourceResponse) UnmarshalJSON(b []byte) error {
    proofReceived := false
    publish_heightReceived := false
    sourceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "proof":
            if err := json.Unmarshal([]byte(v), &strct.Proof); err != nil {
				return err
            }
            proofReceived = true
        case "publish_height":
            if err := json.Unmarshal([]byte(v), &strct.PublishHeight); err != nil {
				return err
            }
            publish_heightReceived = true
        case "source":
            if err := json.Unmarshal([]byte(v), &strct.Source); err != nil {
				return err
            }
            sourceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if proof (a required property) was received
    if !proofReceived {
		strct._proof_ValidationError = fmt.Errorf("\"Proof\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if publish_height (a required property) was received
    if !publish_heightReceived {
		strct._publish_height_ValidationError = fmt.Errorf("\"PublishHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if source (a required property) was received
    if !sourceReceived {
		strct._source_ValidationError = fmt.Errorf("\"Source\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractSourceResponse) Validate() []error {
    var allErrors []error
    if strct._proof_ValidationError != nil {
		allErrors = append(allErrors, strct._proof_ValidationError)
	}
    if strct._publish_height_ValidationError != nil {
		allErrors = append(allErrors, strct._publish_height_ValidationError)
	}
    if strct._source_ValidationError != nil {
		allErrors = append(allErrors, strct._source_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoreNodeInfoResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExitAtBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "exit_at_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"exit_at_block_height\": ")
	if tmp, err := json.Marshal(strct.ExitAtBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_id\": ")
	if tmp, err := json.Marshal(strct.NetworkId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentNetworkId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_network_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_network_id\": ")
	if tmp, err := json.Marshal(strct.ParentNetworkId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PeerVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "peer_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"peer_version\": ")
	if tmp, err := json.Marshal(strct.PeerVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PoxConsensus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "pox_consensus" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"pox_consensus\": ")
	if tmp, err := json.Marshal(strct.PoxConsensus); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ServerVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "server_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"server_version\": ")
	if tmp, err := json.Marshal(strct.ServerVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StableBurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stable_burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stable_burn_block_height\": ")
	if tmp, err := json.Marshal(strct.StableBurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StablePoxConsensus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stable_pox_consensus" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stable_pox_consensus\": ")
	if tmp, err := json.Marshal(strct.StablePoxConsensus); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StacksTip" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stacks_tip" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stacks_tip\": ")
	if tmp, err := json.Marshal(strct.StacksTip); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StacksTipConsensusHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stacks_tip_consensus_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stacks_tip_consensus_hash\": ")
	if tmp, err := json.Marshal(strct.StacksTipConsensusHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StacksTipHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stacks_tip_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stacks_tip_height\": ")
	if tmp, err := json.Marshal(strct.StacksTipHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnanchoredTip" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unanchored_tip" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unanchored_tip\": ")
	if tmp, err := json.Marshal(strct.UnanchoredTip); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoreNodeInfoResponse) UnmarshalJSON(b []byte) error {
    burn_block_heightReceived := false
    exit_at_block_heightReceived := false
    network_idReceived := false
    parent_network_idReceived := false
    peer_versionReceived := false
    pox_consensusReceived := false
    server_versionReceived := false
    stable_burn_block_heightReceived := false
    stable_pox_consensusReceived := false
    stacks_tipReceived := false
    stacks_tip_consensus_hashReceived := false
    stacks_tip_heightReceived := false
    unanchored_tipReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "exit_at_block_height":
            if err := json.Unmarshal([]byte(v), &strct.ExitAtBlockHeight); err != nil {
				return err
            }
            exit_at_block_heightReceived = true
        case "network_id":
            if err := json.Unmarshal([]byte(v), &strct.NetworkId); err != nil {
				return err
            }
            network_idReceived = true
        case "parent_network_id":
            if err := json.Unmarshal([]byte(v), &strct.ParentNetworkId); err != nil {
				return err
            }
            parent_network_idReceived = true
        case "peer_version":
            if err := json.Unmarshal([]byte(v), &strct.PeerVersion); err != nil {
				return err
            }
            peer_versionReceived = true
        case "pox_consensus":
            if err := json.Unmarshal([]byte(v), &strct.PoxConsensus); err != nil {
				return err
            }
            pox_consensusReceived = true
        case "server_version":
            if err := json.Unmarshal([]byte(v), &strct.ServerVersion); err != nil {
				return err
            }
            server_versionReceived = true
        case "stable_burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.StableBurnBlockHeight); err != nil {
				return err
            }
            stable_burn_block_heightReceived = true
        case "stable_pox_consensus":
            if err := json.Unmarshal([]byte(v), &strct.StablePoxConsensus); err != nil {
				return err
            }
            stable_pox_consensusReceived = true
        case "stacks_tip":
            if err := json.Unmarshal([]byte(v), &strct.StacksTip); err != nil {
				return err
            }
            stacks_tipReceived = true
        case "stacks_tip_consensus_hash":
            if err := json.Unmarshal([]byte(v), &strct.StacksTipConsensusHash); err != nil {
				return err
            }
            stacks_tip_consensus_hashReceived = true
        case "stacks_tip_height":
            if err := json.Unmarshal([]byte(v), &strct.StacksTipHeight); err != nil {
				return err
            }
            stacks_tip_heightReceived = true
        case "unanchored_tip":
            if err := json.Unmarshal([]byte(v), &strct.UnanchoredTip); err != nil {
				return err
            }
            unanchored_tipReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if exit_at_block_height (a required property) was received
    if !exit_at_block_heightReceived {
		strct._exit_at_block_height_ValidationError = fmt.Errorf("\"ExitAtBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if network_id (a required property) was received
    if !network_idReceived {
		strct._network_id_ValidationError = fmt.Errorf("\"NetworkId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_network_id (a required property) was received
    if !parent_network_idReceived {
		strct._parent_network_id_ValidationError = fmt.Errorf("\"ParentNetworkId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if peer_version (a required property) was received
    if !peer_versionReceived {
		strct._peer_version_ValidationError = fmt.Errorf("\"PeerVersion\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if pox_consensus (a required property) was received
    if !pox_consensusReceived {
		strct._pox_consensus_ValidationError = fmt.Errorf("\"PoxConsensus\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if server_version (a required property) was received
    if !server_versionReceived {
		strct._server_version_ValidationError = fmt.Errorf("\"ServerVersion\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stable_burn_block_height (a required property) was received
    if !stable_burn_block_heightReceived {
		strct._stable_burn_block_height_ValidationError = fmt.Errorf("\"StableBurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stable_pox_consensus (a required property) was received
    if !stable_pox_consensusReceived {
		strct._stable_pox_consensus_ValidationError = fmt.Errorf("\"StablePoxConsensus\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stacks_tip (a required property) was received
    if !stacks_tipReceived {
		strct._stacks_tip_ValidationError = fmt.Errorf("\"StacksTip\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stacks_tip_consensus_hash (a required property) was received
    if !stacks_tip_consensus_hashReceived {
		strct._stacks_tip_consensus_hash_ValidationError = fmt.Errorf("\"StacksTipConsensusHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stacks_tip_height (a required property) was received
    if !stacks_tip_heightReceived {
		strct._stacks_tip_height_ValidationError = fmt.Errorf("\"StacksTipHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unanchored_tip (a required property) was received
    if !unanchored_tipReceived {
		strct._unanchored_tip_ValidationError = fmt.Errorf("\"UnanchoredTip\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoreNodeInfoResponse) Validate() []error {
    var allErrors []error
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._exit_at_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._exit_at_block_height_ValidationError)
	}
    if strct._network_id_ValidationError != nil {
		allErrors = append(allErrors, strct._network_id_ValidationError)
	}
    if strct._parent_network_id_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_network_id_ValidationError)
	}
    if strct._peer_version_ValidationError != nil {
		allErrors = append(allErrors, strct._peer_version_ValidationError)
	}
    if strct._pox_consensus_ValidationError != nil {
		allErrors = append(allErrors, strct._pox_consensus_ValidationError)
	}
    if strct._server_version_ValidationError != nil {
		allErrors = append(allErrors, strct._server_version_ValidationError)
	}
    if strct._stable_burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._stable_burn_block_height_ValidationError)
	}
    if strct._stable_pox_consensus_ValidationError != nil {
		allErrors = append(allErrors, strct._stable_pox_consensus_ValidationError)
	}
    if strct._stacks_tip_ValidationError != nil {
		allErrors = append(allErrors, strct._stacks_tip_ValidationError)
	}
    if strct._stacks_tip_consensus_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._stacks_tip_consensus_hash_ValidationError)
	}
    if strct._stacks_tip_height_ValidationError != nil {
		allErrors = append(allErrors, strct._stacks_tip_height_ValidationError)
	}
    if strct._unanchored_tip_ValidationError != nil {
		allErrors = append(allErrors, strct._unanchored_tip_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoreNodePoxResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_id\": ")
	if tmp, err := json.Marshal(strct.ContractId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FirstBurnchainBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "first_burnchain_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"first_burnchain_block_height\": ")
	if tmp, err := json.Marshal(strct.FirstBurnchainBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MinAmountUstx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "min_amount_ustx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"min_amount_ustx\": ")
	if tmp, err := json.Marshal(strct.MinAmountUstx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RegistrationWindowLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "registration_window_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"registration_window_length\": ")
	if tmp, err := json.Marshal(strct.RegistrationWindowLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RejectionFraction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "rejection_fraction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"rejection_fraction\": ")
	if tmp, err := json.Marshal(strct.RejectionFraction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RejectionVotesLeftRequired" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "rejection_votes_left_required" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"rejection_votes_left_required\": ")
	if tmp, err := json.Marshal(strct.RejectionVotesLeftRequired); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardCycleId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_cycle_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_cycle_id\": ")
	if tmp, err := json.Marshal(strct.RewardCycleId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardCycleLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_cycle_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_cycle_length\": ")
	if tmp, err := json.Marshal(strct.RewardCycleLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalLiquidSupplyUstx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_liquid_supply_ustx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_liquid_supply_ustx\": ")
	if tmp, err := json.Marshal(strct.TotalLiquidSupplyUstx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoreNodePoxResponse) UnmarshalJSON(b []byte) error {
    contract_idReceived := false
    first_burnchain_block_heightReceived := false
    min_amount_ustxReceived := false
    registration_window_lengthReceived := false
    rejection_fractionReceived := false
    rejection_votes_left_requiredReceived := false
    reward_cycle_idReceived := false
    reward_cycle_lengthReceived := false
    total_liquid_supply_ustxReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_id":
            if err := json.Unmarshal([]byte(v), &strct.ContractId); err != nil {
				return err
            }
            contract_idReceived = true
        case "first_burnchain_block_height":
            if err := json.Unmarshal([]byte(v), &strct.FirstBurnchainBlockHeight); err != nil {
				return err
            }
            first_burnchain_block_heightReceived = true
        case "min_amount_ustx":
            if err := json.Unmarshal([]byte(v), &strct.MinAmountUstx); err != nil {
				return err
            }
            min_amount_ustxReceived = true
        case "registration_window_length":
            if err := json.Unmarshal([]byte(v), &strct.RegistrationWindowLength); err != nil {
				return err
            }
            registration_window_lengthReceived = true
        case "rejection_fraction":
            if err := json.Unmarshal([]byte(v), &strct.RejectionFraction); err != nil {
				return err
            }
            rejection_fractionReceived = true
        case "rejection_votes_left_required":
            if err := json.Unmarshal([]byte(v), &strct.RejectionVotesLeftRequired); err != nil {
				return err
            }
            rejection_votes_left_requiredReceived = true
        case "reward_cycle_id":
            if err := json.Unmarshal([]byte(v), &strct.RewardCycleId); err != nil {
				return err
            }
            reward_cycle_idReceived = true
        case "reward_cycle_length":
            if err := json.Unmarshal([]byte(v), &strct.RewardCycleLength); err != nil {
				return err
            }
            reward_cycle_lengthReceived = true
        case "total_liquid_supply_ustx":
            if err := json.Unmarshal([]byte(v), &strct.TotalLiquidSupplyUstx); err != nil {
				return err
            }
            total_liquid_supply_ustxReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_id (a required property) was received
    if !contract_idReceived {
		strct._contract_id_ValidationError = fmt.Errorf("\"ContractId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if first_burnchain_block_height (a required property) was received
    if !first_burnchain_block_heightReceived {
		strct._first_burnchain_block_height_ValidationError = fmt.Errorf("\"FirstBurnchainBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if min_amount_ustx (a required property) was received
    if !min_amount_ustxReceived {
		strct._min_amount_ustx_ValidationError = fmt.Errorf("\"MinAmountUstx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if registration_window_length (a required property) was received
    if !registration_window_lengthReceived {
		strct._registration_window_length_ValidationError = fmt.Errorf("\"RegistrationWindowLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if rejection_fraction (a required property) was received
    if !rejection_fractionReceived {
		strct._rejection_fraction_ValidationError = fmt.Errorf("\"RejectionFraction\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if rejection_votes_left_required (a required property) was received
    if !rejection_votes_left_requiredReceived {
		strct._rejection_votes_left_required_ValidationError = fmt.Errorf("\"RejectionVotesLeftRequired\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_cycle_id (a required property) was received
    if !reward_cycle_idReceived {
		strct._reward_cycle_id_ValidationError = fmt.Errorf("\"RewardCycleId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_cycle_length (a required property) was received
    if !reward_cycle_lengthReceived {
		strct._reward_cycle_length_ValidationError = fmt.Errorf("\"RewardCycleLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_liquid_supply_ustx (a required property) was received
    if !total_liquid_supply_ustxReceived {
		strct._total_liquid_supply_ustx_ValidationError = fmt.Errorf("\"TotalLiquidSupplyUstx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoreNodePoxResponse) Validate() []error {
    var allErrors []error
    if strct._contract_id_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_id_ValidationError)
	}
    if strct._first_burnchain_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._first_burnchain_block_height_ValidationError)
	}
    if strct._min_amount_ustx_ValidationError != nil {
		allErrors = append(allErrors, strct._min_amount_ustx_ValidationError)
	}
    if strct._registration_window_length_ValidationError != nil {
		allErrors = append(allErrors, strct._registration_window_length_ValidationError)
	}
    if strct._rejection_fraction_ValidationError != nil {
		allErrors = append(allErrors, strct._rejection_fraction_ValidationError)
	}
    if strct._rejection_votes_left_required_ValidationError != nil {
		allErrors = append(allErrors, strct._rejection_votes_left_required_ValidationError)
	}
    if strct._reward_cycle_id_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_cycle_id_ValidationError)
	}
    if strct._reward_cycle_length_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_cycle_length_ValidationError)
	}
    if strct._total_liquid_supply_ustx_ValidationError != nil {
		allErrors = append(allErrors, strct._total_liquid_supply_ustx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *EstimatedCost) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ReadCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "read_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"read_count\": ")
	if tmp, err := json.Marshal(strct.ReadCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ReadLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "read_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"read_length\": ")
	if tmp, err := json.Marshal(strct.ReadLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Runtime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "runtime" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"runtime\": ")
	if tmp, err := json.Marshal(strct.Runtime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "WriteCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "write_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"write_count\": ")
	if tmp, err := json.Marshal(strct.WriteCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "WriteLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "write_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"write_length\": ")
	if tmp, err := json.Marshal(strct.WriteLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EstimatedCost) UnmarshalJSON(b []byte) error {
    read_countReceived := false
    read_lengthReceived := false
    runtimeReceived := false
    write_countReceived := false
    write_lengthReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "read_count":
            if err := json.Unmarshal([]byte(v), &strct.ReadCount); err != nil {
				return err
            }
            read_countReceived = true
        case "read_length":
            if err := json.Unmarshal([]byte(v), &strct.ReadLength); err != nil {
				return err
            }
            read_lengthReceived = true
        case "runtime":
            if err := json.Unmarshal([]byte(v), &strct.Runtime); err != nil {
				return err
            }
            runtimeReceived = true
        case "write_count":
            if err := json.Unmarshal([]byte(v), &strct.WriteCount); err != nil {
				return err
            }
            write_countReceived = true
        case "write_length":
            if err := json.Unmarshal([]byte(v), &strct.WriteLength); err != nil {
				return err
            }
            write_lengthReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if read_count (a required property) was received
    if !read_countReceived {
		strct._read_count_ValidationError = fmt.Errorf("\"ReadCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if read_length (a required property) was received
    if !read_lengthReceived {
		strct._read_length_ValidationError = fmt.Errorf("\"ReadLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if runtime (a required property) was received
    if !runtimeReceived {
		strct._runtime_ValidationError = fmt.Errorf("\"Runtime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if write_count (a required property) was received
    if !write_countReceived {
		strct._write_count_ValidationError = fmt.Errorf("\"WriteCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if write_length (a required property) was received
    if !write_lengthReceived {
		strct._write_length_ValidationError = fmt.Errorf("\"WriteLength\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *EstimatedCost) Validate() []error {
    var allErrors []error
    if strct._read_count_ValidationError != nil {
		allErrors = append(allErrors, strct._read_count_ValidationError)
	}
    if strct._read_length_ValidationError != nil {
		allErrors = append(allErrors, strct._read_length_ValidationError)
	}
    if strct._runtime_ValidationError != nil {
		allErrors = append(allErrors, strct._runtime_ValidationError)
	}
    if strct._write_count_ValidationError != nil {
		allErrors = append(allErrors, strct._write_count_ValidationError)
	}
    if strct._write_length_ValidationError != nil {
		allErrors = append(allErrors, strct._write_length_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FeeRate) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "FeeRate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "fee_rate" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fee_rate\": ")
	if tmp, err := json.Marshal(strct.FeeRate); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FeeRate) UnmarshalJSON(b []byte) error {
    fee_rateReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "fee_rate":
            if err := json.Unmarshal([]byte(v), &strct.FeeRate); err != nil {
				return err
            }
            fee_rateReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if fee_rate (a required property) was received
    if !fee_rateReceived {
		strct._fee_rate_ValidationError = fmt.Errorf("\"FeeRate\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FeeRate) Validate() []error {
    var allErrors []error
    if strct._fee_rate_ValidationError != nil {
		allErrors = append(allErrors, strct._fee_rate_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FeeRateRequest_RosettaConstructionParseRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Signed" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signed" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signed\": ")
	if tmp, err := json.Marshal(strct.Signed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Transaction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction\": ")
	if tmp, err := json.Marshal(strct.Transaction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FeeRateRequest_RosettaConstructionParseRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    signedReceived := false
    transactionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "signed":
            if err := json.Unmarshal([]byte(v), &strct.Signed); err != nil {
				return err
            }
            signedReceived = true
        case "transaction":
            if err := json.Unmarshal([]byte(v), &strct.Transaction); err != nil {
				return err
            }
            transactionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signed (a required property) was received
    if !signedReceived {
		strct._signed_ValidationError = fmt.Errorf("\"Signed\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transaction (a required property) was received
    if !transactionReceived {
		strct._transaction_ValidationError = fmt.Errorf("\"Transaction\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FeeRateRequest_RosettaConstructionParseRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._signed_ValidationError != nil {
		allErrors = append(allErrors, strct._signed_ValidationError)
	}
    if strct._transaction_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FtBalance_StxBalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Balance" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance\": ")
	if tmp, err := json.Marshal(strct.Balance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnchainLockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burnchain_lock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burnchain_lock_height\": ")
	if tmp, err := json.Marshal(strct.BurnchainLockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnchainUnlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burnchain_unlock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burnchain_unlock_height\": ")
	if tmp, err := json.Marshal(strct.BurnchainUnlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "lock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"lock_height\": ")
	if tmp, err := json.Marshal(strct.LockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LockTxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "lock_tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"lock_tx_id\": ")
	if tmp, err := json.Marshal(strct.LockTxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Locked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"locked\": ")
	if tmp, err := json.Marshal(strct.Locked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalFeesSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_fees_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_fees_sent\": ")
	if tmp, err := json.Marshal(strct.TotalFeesSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalMinerRewardsReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_miner_rewards_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_miner_rewards_received\": ")
	if tmp, err := json.Marshal(strct.TotalMinerRewardsReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_received\": ")
	if tmp, err := json.Marshal(strct.TotalReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_sent\": ")
	if tmp, err := json.Marshal(strct.TotalSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FtBalance_StxBalance) UnmarshalJSON(b []byte) error {
    balanceReceived := false
    burnchain_lock_heightReceived := false
    burnchain_unlock_heightReceived := false
    lock_heightReceived := false
    lock_tx_idReceived := false
    lockedReceived := false
    total_fees_sentReceived := false
    total_miner_rewards_receivedReceived := false
    total_receivedReceived := false
    total_sentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "balance":
            if err := json.Unmarshal([]byte(v), &strct.Balance); err != nil {
				return err
            }
            balanceReceived = true
        case "burnchain_lock_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnchainLockHeight); err != nil {
				return err
            }
            burnchain_lock_heightReceived = true
        case "burnchain_unlock_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnchainUnlockHeight); err != nil {
				return err
            }
            burnchain_unlock_heightReceived = true
        case "lock_height":
            if err := json.Unmarshal([]byte(v), &strct.LockHeight); err != nil {
				return err
            }
            lock_heightReceived = true
        case "lock_tx_id":
            if err := json.Unmarshal([]byte(v), &strct.LockTxId); err != nil {
				return err
            }
            lock_tx_idReceived = true
        case "locked":
            if err := json.Unmarshal([]byte(v), &strct.Locked); err != nil {
				return err
            }
            lockedReceived = true
        case "total_fees_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalFeesSent); err != nil {
				return err
            }
            total_fees_sentReceived = true
        case "total_miner_rewards_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalMinerRewardsReceived); err != nil {
				return err
            }
            total_miner_rewards_receivedReceived = true
        case "total_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalReceived); err != nil {
				return err
            }
            total_receivedReceived = true
        case "total_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalSent); err != nil {
				return err
            }
            total_sentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if balance (a required property) was received
    if !balanceReceived {
		strct._balance_ValidationError = fmt.Errorf("\"Balance\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burnchain_lock_height (a required property) was received
    if !burnchain_lock_heightReceived {
		strct._burnchain_lock_height_ValidationError = fmt.Errorf("\"BurnchainLockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burnchain_unlock_height (a required property) was received
    if !burnchain_unlock_heightReceived {
		strct._burnchain_unlock_height_ValidationError = fmt.Errorf("\"BurnchainUnlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if lock_height (a required property) was received
    if !lock_heightReceived {
		strct._lock_height_ValidationError = fmt.Errorf("\"LockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if lock_tx_id (a required property) was received
    if !lock_tx_idReceived {
		strct._lock_tx_id_ValidationError = fmt.Errorf("\"LockTxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if locked (a required property) was received
    if !lockedReceived {
		strct._locked_ValidationError = fmt.Errorf("\"Locked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_fees_sent (a required property) was received
    if !total_fees_sentReceived {
		strct._total_fees_sent_ValidationError = fmt.Errorf("\"TotalFeesSent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_miner_rewards_received (a required property) was received
    if !total_miner_rewards_receivedReceived {
		strct._total_miner_rewards_received_ValidationError = fmt.Errorf("\"TotalMinerRewardsReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_received (a required property) was received
    if !total_receivedReceived {
		strct._total_received_ValidationError = fmt.Errorf("\"TotalReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_sent (a required property) was received
    if !total_sentReceived {
		strct._total_sent_ValidationError = fmt.Errorf("\"TotalSent\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FtBalance_StxBalance) Validate() []error {
    var allErrors []error
    if strct._balance_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_ValidationError)
	}
    if strct._burnchain_lock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burnchain_lock_height_ValidationError)
	}
    if strct._burnchain_unlock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burnchain_unlock_height_ValidationError)
	}
    if strct._lock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._lock_height_ValidationError)
	}
    if strct._lock_tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._lock_tx_id_ValidationError)
	}
    if strct._locked_ValidationError != nil {
		allErrors = append(allErrors, strct._locked_ValidationError)
	}
    if strct._total_fees_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_fees_sent_ValidationError)
	}
    if strct._total_miner_rewards_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_miner_rewards_received_ValidationError)
	}
    if strct._total_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_received_ValidationError)
	}
    if strct._total_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_sent_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FtTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FtTransfersItems) UnmarshalJSON(b []byte) error {
    amountReceived := false
    asset_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FtTransfersItems) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FunctionArgsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex\": ")
	if tmp, err := json.Marshal(strct.Hex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Repr" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "repr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"repr\": ")
	if tmp, err := json.Marshal(strct.Repr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FunctionArgsItems) UnmarshalJSON(b []byte) error {
    hexReceived := false
    nameReceived := false
    reprReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex":
            if err := json.Unmarshal([]byte(v), &strct.Hex); err != nil {
				return err
            }
            hexReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
            }
            nameReceived = true
        case "repr":
            if err := json.Unmarshal([]byte(v), &strct.Repr); err != nil {
				return err
            }
            reprReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex (a required property) was received
    if !hexReceived {
		strct._hex_ValidationError = fmt.Errorf("\"Hex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if name (a required property) was received
    if !nameReceived {
		strct._name_ValidationError = fmt.Errorf("\"Name\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if repr (a required property) was received
    if !reprReceived {
		strct._repr_ValidationError = fmt.Errorf("\"Repr\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if type (a required property) was received
    if !typeReceived {
		strct._type_ValidationError = fmt.Errorf("\"Type\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FunctionArgsItems) Validate() []error {
    var allErrors []error
    if strct._hex_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_ValidationError)
	}
    if strct._name_ValidationError != nil {
		allErrors = append(allErrors, strct._name_ValidationError)
	}
    if strct._repr_ValidationError != nil {
		allErrors = append(allErrors, strct._repr_ValidationError)
	}
    if strct._type_ValidationError != nil {
		allErrors = append(allErrors, strct._type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Decimals" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ImageCanonicalUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "image_canonical_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"image_canonical_uri\": ")
	if tmp, err := json.Marshal(strct.ImageCanonicalUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ImageUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "image_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"image_uri\": ")
	if tmp, err := json.Marshal(strct.ImageUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SenderAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Symbol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TokenUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "token_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_uri\": ")
	if tmp, err := json.Marshal(strct.TokenUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) UnmarshalJSON(b []byte) error {
    decimalsReceived := false
    descriptionReceived := false
    image_canonical_uriReceived := false
    image_uriReceived := false
    nameReceived := false
    sender_addressReceived := false
    symbolReceived := false
    token_uriReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
            decimalsReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
            }
            descriptionReceived = true
        case "image_canonical_uri":
            if err := json.Unmarshal([]byte(v), &strct.ImageCanonicalUri); err != nil {
				return err
            }
            image_canonical_uriReceived = true
        case "image_uri":
            if err := json.Unmarshal([]byte(v), &strct.ImageUri); err != nil {
				return err
            }
            image_uriReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
            }
            nameReceived = true
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
            sender_addressReceived = true
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
            symbolReceived = true
        case "token_uri":
            if err := json.Unmarshal([]byte(v), &strct.TokenUri); err != nil {
				return err
            }
            token_uriReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if decimals (a required property) was received
    if !decimalsReceived {
		strct._decimals_ValidationError = fmt.Errorf("\"Decimals\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if description (a required property) was received
    if !descriptionReceived {
		strct._description_ValidationError = fmt.Errorf("\"Description\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if image_canonical_uri (a required property) was received
    if !image_canonical_uriReceived {
		strct._image_canonical_uri_ValidationError = fmt.Errorf("\"ImageCanonicalUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if image_uri (a required property) was received
    if !image_uriReceived {
		strct._image_uri_ValidationError = fmt.Errorf("\"ImageUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if name (a required property) was received
    if !nameReceived {
		strct._name_ValidationError = fmt.Errorf("\"Name\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender_address (a required property) was received
    if !sender_addressReceived {
		strct._sender_address_ValidationError = fmt.Errorf("\"SenderAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if symbol (a required property) was received
    if !symbolReceived {
		strct._symbol_ValidationError = fmt.Errorf("\"Symbol\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if token_uri (a required property) was received
    if !token_uriReceived {
		strct._token_uri_ValidationError = fmt.Errorf("\"TokenUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) Validate() []error {
    var allErrors []error
    if strct._decimals_ValidationError != nil {
		allErrors = append(allErrors, strct._decimals_ValidationError)
	}
    if strct._description_ValidationError != nil {
		allErrors = append(allErrors, strct._description_ValidationError)
	}
    if strct._image_canonical_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._image_canonical_uri_ValidationError)
	}
    if strct._image_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._image_uri_ValidationError)
	}
    if strct._name_ValidationError != nil {
		allErrors = append(allErrors, strct._name_ValidationError)
	}
    if strct._sender_address_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_address_ValidationError)
	}
    if strct._symbol_ValidationError != nil {
		allErrors = append(allErrors, strct._symbol_ValidationError)
	}
    if strct._token_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._token_uri_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *GetRawTransactionResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "RawTx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "raw_tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"raw_tx\": ")
	if tmp, err := json.Marshal(strct.RawTx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetRawTransactionResult) UnmarshalJSON(b []byte) error {
    raw_txReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "raw_tx":
            if err := json.Unmarshal([]byte(v), &strct.RawTx); err != nil {
				return err
            }
            raw_txReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if raw_tx (a required property) was received
    if !raw_txReceived {
		strct._raw_tx_ValidationError = fmt.Errorf("\"RawTx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *GetRawTransactionResult) Validate() []error {
    var allErrors []error
    if strct._raw_tx_ValidationError != nil {
		allErrors = append(allErrors, strct._raw_tx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *GetStxSupplyLegacyFormatResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blockHeight" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"blockHeight\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalStacks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "totalStacks" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"totalStacks\": ")
	if tmp, err := json.Marshal(strct.TotalStacks); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalStacksFormatted" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "totalStacksFormatted" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"totalStacksFormatted\": ")
	if tmp, err := json.Marshal(strct.TotalStacksFormatted); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockedPercent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlockedPercent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlockedPercent\": ")
	if tmp, err := json.Marshal(strct.UnlockedPercent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockedSupply" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlockedSupply" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlockedSupply\": ")
	if tmp, err := json.Marshal(strct.UnlockedSupply); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockedSupplyFormatted" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlockedSupplyFormatted" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlockedSupplyFormatted\": ")
	if tmp, err := json.Marshal(strct.UnlockedSupplyFormatted); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetStxSupplyLegacyFormatResponse) UnmarshalJSON(b []byte) error {
    blockHeightReceived := false
    totalStacksReceived := false
    totalStacksFormattedReceived := false
    unlockedPercentReceived := false
    unlockedSupplyReceived := false
    unlockedSupplyFormattedReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "blockHeight":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            blockHeightReceived = true
        case "totalStacks":
            if err := json.Unmarshal([]byte(v), &strct.TotalStacks); err != nil {
				return err
            }
            totalStacksReceived = true
        case "totalStacksFormatted":
            if err := json.Unmarshal([]byte(v), &strct.TotalStacksFormatted); err != nil {
				return err
            }
            totalStacksFormattedReceived = true
        case "unlockedPercent":
            if err := json.Unmarshal([]byte(v), &strct.UnlockedPercent); err != nil {
				return err
            }
            unlockedPercentReceived = true
        case "unlockedSupply":
            if err := json.Unmarshal([]byte(v), &strct.UnlockedSupply); err != nil {
				return err
            }
            unlockedSupplyReceived = true
        case "unlockedSupplyFormatted":
            if err := json.Unmarshal([]byte(v), &strct.UnlockedSupplyFormatted); err != nil {
				return err
            }
            unlockedSupplyFormattedReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if blockHeight (a required property) was received
    if !blockHeightReceived {
		strct._blockHeight_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if totalStacks (a required property) was received
    if !totalStacksReceived {
		strct._totalStacks_ValidationError = fmt.Errorf("\"TotalStacks\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if totalStacksFormatted (a required property) was received
    if !totalStacksFormattedReceived {
		strct._totalStacksFormatted_ValidationError = fmt.Errorf("\"TotalStacksFormatted\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlockedPercent (a required property) was received
    if !unlockedPercentReceived {
		strct._unlockedPercent_ValidationError = fmt.Errorf("\"UnlockedPercent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlockedSupply (a required property) was received
    if !unlockedSupplyReceived {
		strct._unlockedSupply_ValidationError = fmt.Errorf("\"UnlockedSupply\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlockedSupplyFormatted (a required property) was received
    if !unlockedSupplyFormattedReceived {
		strct._unlockedSupplyFormatted_ValidationError = fmt.Errorf("\"UnlockedSupplyFormatted\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *GetStxSupplyLegacyFormatResponse) Validate() []error {
    var allErrors []error
    if strct._blockHeight_ValidationError != nil {
		allErrors = append(allErrors, strct._blockHeight_ValidationError)
	}
    if strct._totalStacks_ValidationError != nil {
		allErrors = append(allErrors, strct._totalStacks_ValidationError)
	}
    if strct._totalStacksFormatted_ValidationError != nil {
		allErrors = append(allErrors, strct._totalStacksFormatted_ValidationError)
	}
    if strct._unlockedPercent_ValidationError != nil {
		allErrors = append(allErrors, strct._unlockedPercent_ValidationError)
	}
    if strct._unlockedSupply_ValidationError != nil {
		allErrors = append(allErrors, strct._unlockedSupply_ValidationError)
	}
    if strct._unlockedSupplyFormatted_ValidationError != nil {
		allErrors = append(allErrors, strct._unlockedSupplyFormatted_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *GetStxSupplyResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalStx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_stx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_stx\": ")
	if tmp, err := json.Marshal(strct.TotalStx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockedPercent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlocked_percent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlocked_percent\": ")
	if tmp, err := json.Marshal(strct.UnlockedPercent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockedStx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlocked_stx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlocked_stx\": ")
	if tmp, err := json.Marshal(strct.UnlockedStx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GetStxSupplyResponse) UnmarshalJSON(b []byte) error {
    block_heightReceived := false
    total_stxReceived := false
    unlocked_percentReceived := false
    unlocked_stxReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "total_stx":
            if err := json.Unmarshal([]byte(v), &strct.TotalStx); err != nil {
				return err
            }
            total_stxReceived = true
        case "unlocked_percent":
            if err := json.Unmarshal([]byte(v), &strct.UnlockedPercent); err != nil {
				return err
            }
            unlocked_percentReceived = true
        case "unlocked_stx":
            if err := json.Unmarshal([]byte(v), &strct.UnlockedStx); err != nil {
				return err
            }
            unlocked_stxReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_stx (a required property) was received
    if !total_stxReceived {
		strct._total_stx_ValidationError = fmt.Errorf("\"TotalStx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlocked_percent (a required property) was received
    if !unlocked_percentReceived {
		strct._unlocked_percent_ValidationError = fmt.Errorf("\"UnlockedPercent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlocked_stx (a required property) was received
    if !unlocked_stxReceived {
		strct._unlocked_stx_ValidationError = fmt.Errorf("\"UnlockedStx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *GetStxSupplyResponse) Validate() []error {
    var allErrors []error
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._total_stx_ValidationError != nil {
		allErrors = append(allErrors, strct._total_stx_ValidationError)
	}
    if strct._unlocked_percent_ValidationError != nil {
		allErrors = append(allErrors, strct._unlocked_percent_ValidationError)
	}
    if strct._unlocked_stx_ValidationError != nil {
		allErrors = append(allErrors, strct._unlocked_stx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *MapEntryResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Data" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "proof" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"proof\": ")
	if tmp, err := json.Marshal(strct.Proof); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MapEntryResponse) UnmarshalJSON(b []byte) error {
    dataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
				return err
            }
            dataReceived = true
        case "proof":
            if err := json.Unmarshal([]byte(v), &strct.Proof); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if data (a required property) was received
    if !dataReceived {
		strct._data_ValidationError = fmt.Errorf("\"Data\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *MapEntryResponse) Validate() []error {
    var allErrors []error
    if strct._data_ValidationError != nil {
		allErrors = append(allErrors, strct._data_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SequenceNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sequence_number" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sequence_number\": ")
	if tmp, err := json.Marshal(strct.SequenceNumber); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    sequence_numberReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "sequence_number":
            if err := json.Unmarshal([]byte(v), &strct.SequenceNumber); err != nil {
				return err
            }
            sequence_numberReceived = true
        }
    }
    // check if sequence_number (a required property) was received
    if !sequence_numberReceived {
		strct._sequence_number_ValidationError = fmt.Errorf("\"SequenceNumber\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Metadata) Validate() []error {
    var allErrors []error
    if strct._sequence_number_ValidationError != nil {
		allErrors = append(allErrors, strct._sequence_number_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Metadata_7cedba8711) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Producer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "producer" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"producer\": ")
	if tmp, err := json.Marshal(strct.Producer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata_7cedba8711) UnmarshalJSON(b []byte) error {
    producerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "producer":
            if err := json.Unmarshal([]byte(v), &strct.Producer); err != nil {
				return err
            }
            producerReceived = true
        }
    }
    // check if producer (a required property) was received
    if !producerReceived {
		strct._producer_ValidationError = fmt.Errorf("\"Producer\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Metadata_7cedba8711) Validate() []error {
    var allErrors []error
    if strct._producer_ValidationError != nil {
		allErrors = append(allErrors, strct._producer_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Metadata_8cb828c26a) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Difficulty" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "difficulty" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"difficulty\": ")
	if tmp, err := json.Marshal(strct.Difficulty); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionsRoot" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transactions_root" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transactions_root\": ")
	if tmp, err := json.Marshal(strct.TransactionsRoot); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata_8cb828c26a) UnmarshalJSON(b []byte) error {
    difficultyReceived := false
    transactions_rootReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "difficulty":
            if err := json.Unmarshal([]byte(v), &strct.Difficulty); err != nil {
				return err
            }
            difficultyReceived = true
        case "transactions_root":
            if err := json.Unmarshal([]byte(v), &strct.TransactionsRoot); err != nil {
				return err
            }
            transactions_rootReceived = true
        }
    }
    // check if difficulty (a required property) was received
    if !difficultyReceived {
		strct._difficulty_ValidationError = fmt.Errorf("\"Difficulty\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transactions_root (a required property) was received
    if !transactions_rootReceived {
		strct._transactions_root_ValidationError = fmt.Errorf("\"TransactionsRoot\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Metadata_8cb828c26a) Validate() []error {
    var allErrors []error
    if strct._difficulty_ValidationError != nil {
		allErrors = append(allErrors, strct._difficulty_ValidationError)
	}
    if strct._transactions_root_ValidationError != nil {
		allErrors = append(allErrors, strct._transactions_root_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Microblock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_hash\": ")
	if tmp, err := json.Marshal(strct.BlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockCanonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_canonical\": ")
	if tmp, err := json.Marshal(strct.MicroblockCanonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockParentHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_parent_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_parent_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockParentHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockSequence" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.MicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_height\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_height\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_time\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockTimeIso" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_time_iso" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_time_iso\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockTimeIso); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Txs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "txs" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txs\": ")
	if tmp, err := json.Marshal(strct.Txs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Microblock) UnmarshalJSON(b []byte) error {
    block_hashReceived := false
    block_heightReceived := false
    canonicalReceived := false
    microblock_canonicalReceived := false
    microblock_hashReceived := false
    microblock_parent_hashReceived := false
    microblock_sequenceReceived := false
    parent_block_hashReceived := false
    parent_block_heightReceived := false
    parent_burn_block_hashReceived := false
    parent_burn_block_heightReceived := false
    parent_burn_block_timeReceived := false
    parent_burn_block_time_isoReceived := false
    txsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BlockHash); err != nil {
				return err
            }
            block_hashReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "microblock_canonical":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockCanonical); err != nil {
				return err
            }
            microblock_canonicalReceived = true
        case "microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHash); err != nil {
				return err
            }
            microblock_hashReceived = true
        case "microblock_parent_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockParentHash); err != nil {
				return err
            }
            microblock_parent_hashReceived = true
        case "microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockSequence); err != nil {
				return err
            }
            microblock_sequenceReceived = true
        case "parent_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHash); err != nil {
				return err
            }
            parent_block_hashReceived = true
        case "parent_block_height":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHeight); err != nil {
				return err
            }
            parent_block_heightReceived = true
        case "parent_burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockHash); err != nil {
				return err
            }
            parent_burn_block_hashReceived = true
        case "parent_burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockHeight); err != nil {
				return err
            }
            parent_burn_block_heightReceived = true
        case "parent_burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockTime); err != nil {
				return err
            }
            parent_burn_block_timeReceived = true
        case "parent_burn_block_time_iso":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockTimeIso); err != nil {
				return err
            }
            parent_burn_block_time_isoReceived = true
        case "txs":
            if err := json.Unmarshal([]byte(v), &strct.Txs); err != nil {
				return err
            }
            txsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_hash (a required property) was received
    if !block_hashReceived {
		strct._block_hash_ValidationError = fmt.Errorf("\"BlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_canonical (a required property) was received
    if !microblock_canonicalReceived {
		strct._microblock_canonical_ValidationError = fmt.Errorf("\"MicroblockCanonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_hash (a required property) was received
    if !microblock_hashReceived {
		strct._microblock_hash_ValidationError = fmt.Errorf("\"MicroblockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_parent_hash (a required property) was received
    if !microblock_parent_hashReceived {
		strct._microblock_parent_hash_ValidationError = fmt.Errorf("\"MicroblockParentHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_sequence (a required property) was received
    if !microblock_sequenceReceived {
		strct._microblock_sequence_ValidationError = fmt.Errorf("\"MicroblockSequence\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_hash (a required property) was received
    if !parent_block_hashReceived {
		strct._parent_block_hash_ValidationError = fmt.Errorf("\"ParentBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_height (a required property) was received
    if !parent_block_heightReceived {
		strct._parent_block_height_ValidationError = fmt.Errorf("\"ParentBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_hash (a required property) was received
    if !parent_burn_block_hashReceived {
		strct._parent_burn_block_hash_ValidationError = fmt.Errorf("\"ParentBurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_height (a required property) was received
    if !parent_burn_block_heightReceived {
		strct._parent_burn_block_height_ValidationError = fmt.Errorf("\"ParentBurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_time (a required property) was received
    if !parent_burn_block_timeReceived {
		strct._parent_burn_block_time_ValidationError = fmt.Errorf("\"ParentBurnBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_time_iso (a required property) was received
    if !parent_burn_block_time_isoReceived {
		strct._parent_burn_block_time_iso_ValidationError = fmt.Errorf("\"ParentBurnBlockTimeIso\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if txs (a required property) was received
    if !txsReceived {
		strct._txs_ValidationError = fmt.Errorf("\"Txs\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Microblock) Validate() []error {
    var allErrors []error
    if strct._block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._block_hash_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._microblock_canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_canonical_ValidationError)
	}
    if strct._microblock_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_hash_ValidationError)
	}
    if strct._microblock_parent_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_parent_hash_ValidationError)
	}
    if strct._microblock_sequence_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_sequence_ValidationError)
	}
    if strct._parent_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_hash_ValidationError)
	}
    if strct._parent_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_height_ValidationError)
	}
    if strct._parent_burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_hash_ValidationError)
	}
    if strct._parent_burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_height_ValidationError)
	}
    if strct._parent_burn_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_time_ValidationError)
	}
    if strct._parent_burn_block_time_iso_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_time_iso_ValidationError)
	}
    if strct._txs_ValidationError != nil {
		allErrors = append(allErrors, strct._txs_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NetworkBlockTimesResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Mainnet" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "mainnet" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"mainnet\": ")
	if tmp, err := json.Marshal(strct.Mainnet); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Testnet" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "testnet" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"testnet\": ")
	if tmp, err := json.Marshal(strct.Testnet); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkBlockTimesResponse) UnmarshalJSON(b []byte) error {
    mainnetReceived := false
    testnetReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "mainnet":
            if err := json.Unmarshal([]byte(v), &strct.Mainnet); err != nil {
				return err
            }
            mainnetReceived = true
        case "testnet":
            if err := json.Unmarshal([]byte(v), &strct.Testnet); err != nil {
				return err
            }
            testnetReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if mainnet (a required property) was received
    if !mainnetReceived {
		strct._mainnet_ValidationError = fmt.Errorf("\"Mainnet\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if testnet (a required property) was received
    if !testnetReceived {
		strct._testnet_ValidationError = fmt.Errorf("\"Testnet\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NetworkBlockTimesResponse) Validate() []error {
    var allErrors []error
    if strct._mainnet_ValidationError != nil {
		allErrors = append(allErrors, strct._mainnet_ValidationError)
	}
    if strct._testnet_ValidationError != nil {
		allErrors = append(allErrors, strct._testnet_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NetworkIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Blockchain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blockchain" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"blockchain\": ")
	if tmp, err := json.Marshal(strct.Blockchain); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Network" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network\": ")
	if tmp, err := json.Marshal(strct.Network); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sub_network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sub_network_identifier\": ")
	if tmp, err := json.Marshal(strct.SubNetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkIdentifier) UnmarshalJSON(b []byte) error {
    blockchainReceived := false
    networkReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "blockchain":
            if err := json.Unmarshal([]byte(v), &strct.Blockchain); err != nil {
				return err
            }
            blockchainReceived = true
        case "network":
            if err := json.Unmarshal([]byte(v), &strct.Network); err != nil {
				return err
            }
            networkReceived = true
        case "sub_network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.SubNetworkIdentifier); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if blockchain (a required property) was received
    if !blockchainReceived {
		strct._blockchain_ValidationError = fmt.Errorf("\"Blockchain\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if network (a required property) was received
    if !networkReceived {
		strct._network_ValidationError = fmt.Errorf("\"Network\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NetworkIdentifier) Validate() []error {
    var allErrors []error
    if strct._blockchain_ValidationError != nil {
		allErrors = append(allErrors, strct._blockchain_ValidationError)
	}
    if strct._network_ValidationError != nil {
		allErrors = append(allErrors, strct._network_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftBalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Count" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_received\": ")
	if tmp, err := json.Marshal(strct.TotalReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_sent\": ")
	if tmp, err := json.Marshal(strct.TotalSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftBalance) UnmarshalJSON(b []byte) error {
    countReceived := false
    total_receivedReceived := false
    total_sentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
				return err
            }
            countReceived = true
        case "total_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalReceived); err != nil {
				return err
            }
            total_receivedReceived = true
        case "total_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalSent); err != nil {
				return err
            }
            total_sentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if count (a required property) was received
    if !countReceived {
		strct._count_ValidationError = fmt.Errorf("\"Count\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_received (a required property) was received
    if !total_receivedReceived {
		strct._total_received_ValidationError = fmt.Errorf("\"TotalReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_sent (a required property) was received
    if !total_sentReceived {
		strct._total_sent_ValidationError = fmt.Errorf("\"TotalSent\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftBalance) Validate() []error {
    var allErrors []error
    if strct._count_ValidationError != nil {
		allErrors = append(allErrors, strct._count_ValidationError)
	}
    if strct._total_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_received_ValidationError)
	}
    if strct._total_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_sent_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Recipient" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    block_heightReceived := false
    recipientReceived := false
    senderReceived := false
    tx_idReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
            recipientReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if recipient (a required property) was received
    if !recipientReceived {
		strct._recipient_ValidationError = fmt.Errorf("\"Recipient\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._recipient_ValidationError != nil {
		allErrors = append(allErrors, strct._recipient_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftTransfersItems) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftTransfersItems) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetEventType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) UnmarshalJSON(b []byte) error {
    asset_event_typeReceived := false
    event_indexReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
            asset_event_typeReceived = true
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_event_type (a required property) was received
    if !asset_event_typeReceived {
		strct._asset_event_type_ValidationError = fmt.Errorf("\"AssetEventType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) Validate() []error {
    var allErrors []error
    if strct._asset_event_type_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_event_type_ValidationError)
	}
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    block_heightReceived := false
    txReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenMintWithTxId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenMintWithTxId) UnmarshalJSON(b []byte) error {
    event_indexReceived := false
    tx_idReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenMintWithTxId) Validate() []error {
    var allErrors []error
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) UnmarshalJSON(b []byte) error {
    event_indexReceived := false
    txReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) Validate() []error {
    var allErrors []error
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *PoisonMicroblock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MicroblockHeader1" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_header_1" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_header_1\": ")
	if tmp, err := json.Marshal(strct.MicroblockHeader1); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockHeader2" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_header_2" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_header_2\": ")
	if tmp, err := json.Marshal(strct.MicroblockHeader2); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PoisonMicroblock) UnmarshalJSON(b []byte) error {
    microblock_header_1Received := false
    microblock_header_2Received := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "microblock_header_1":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHeader1); err != nil {
				return err
            }
            microblock_header_1Received = true
        case "microblock_header_2":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHeader2); err != nil {
				return err
            }
            microblock_header_2Received = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if microblock_header_1 (a required property) was received
    if !microblock_header_1Received {
		strct._microblock_header_1_ValidationError = fmt.Errorf("\"MicroblockHeader1\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_header_2 (a required property) was received
    if !microblock_header_2Received {
		strct._microblock_header_2_ValidationError = fmt.Errorf("\"MicroblockHeader2\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *PoisonMicroblock) Validate() []error {
    var allErrors []error
    if strct._microblock_header_1_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_header_1_ValidationError)
	}
    if strct._microblock_header_2_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_header_2_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *PoisonMicroblockTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PoisonMicroblock" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "poison_microblock" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"poison_microblock\": ")
	if tmp, err := json.Marshal(strct.PoisonMicroblock); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PoisonMicroblockTransactionMetadata) UnmarshalJSON(b []byte) error {
    poison_microblockReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "poison_microblock":
            if err := json.Unmarshal([]byte(v), &strct.PoisonMicroblock); err != nil {
				return err
            }
            poison_microblockReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if poison_microblock (a required property) was received
    if !poison_microblockReceived {
		strct._poison_microblock_ValidationError = fmt.Errorf("\"PoisonMicroblock\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *PoisonMicroblockTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._poison_microblock_ValidationError != nil {
		allErrors = append(allErrors, strct._poison_microblock_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *PostCoreNodeTransactionsError) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Error" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "error" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"error\": ")
	if tmp, err := json.Marshal(strct.Error); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Reason" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reason" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reason\": ")
	if tmp, err := json.Marshal(strct.Reason); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ReasonData" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reason_data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reason_data\": ")
	if tmp, err := json.Marshal(strct.ReasonData); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Txid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "txid" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txid\": ")
	if tmp, err := json.Marshal(strct.Txid); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PostCoreNodeTransactionsError) UnmarshalJSON(b []byte) error {
    errorReceived := false
    reasonReceived := false
    reason_dataReceived := false
    txidReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "error":
            if err := json.Unmarshal([]byte(v), &strct.Error); err != nil {
				return err
            }
            errorReceived = true
        case "reason":
            if err := json.Unmarshal([]byte(v), &strct.Reason); err != nil {
				return err
            }
            reasonReceived = true
        case "reason_data":
            if err := json.Unmarshal([]byte(v), &strct.ReasonData); err != nil {
				return err
            }
            reason_dataReceived = true
        case "txid":
            if err := json.Unmarshal([]byte(v), &strct.Txid); err != nil {
				return err
            }
            txidReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if error (a required property) was received
    if !errorReceived {
		strct._error_ValidationError = fmt.Errorf("\"Error\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reason (a required property) was received
    if !reasonReceived {
		strct._reason_ValidationError = fmt.Errorf("\"Reason\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reason_data (a required property) was received
    if !reason_dataReceived {
		strct._reason_data_ValidationError = fmt.Errorf("\"ReasonData\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if txid (a required property) was received
    if !txidReceived {
		strct._txid_ValidationError = fmt.Errorf("\"Txid\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *PostCoreNodeTransactionsError) Validate() []error {
    var allErrors []error
    if strct._error_ValidationError != nil {
		allErrors = append(allErrors, strct._error_ValidationError)
	}
    if strct._reason_ValidationError != nil {
		allErrors = append(allErrors, strct._reason_ValidationError)
	}
    if strct._reason_data_ValidationError != nil {
		allErrors = append(allErrors, strct._reason_data_ValidationError)
	}
    if strct._txid_ValidationError != nil {
		allErrors = append(allErrors, strct._txid_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ReadOnlyFunctionArgs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arguments" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "arguments" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"arguments\": ")
	if tmp, err := json.Marshal(strct.Arguments); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadOnlyFunctionArgs) UnmarshalJSON(b []byte) error {
    argumentsReceived := false
    senderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "arguments":
            if err := json.Unmarshal([]byte(v), &strct.Arguments); err != nil {
				return err
            }
            argumentsReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if arguments (a required property) was received
    if !argumentsReceived {
		strct._arguments_ValidationError = fmt.Errorf("\"Arguments\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ReadOnlyFunctionArgs) Validate() []error {
    var allErrors []error
    if strct._arguments_ValidationError != nil {
		allErrors = append(allErrors, strct._arguments_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ReadOnlyFunctionSuccessResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "cause" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"cause\": ")
	if tmp, err := json.Marshal(strct.Cause); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Okay" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "okay" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"okay\": ")
	if tmp, err := json.Marshal(strct.Okay); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadOnlyFunctionSuccessResponse) UnmarshalJSON(b []byte) error {
    okayReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cause":
            if err := json.Unmarshal([]byte(v), &strct.Cause); err != nil {
				return err
            }
        case "okay":
            if err := json.Unmarshal([]byte(v), &strct.Okay); err != nil {
				return err
            }
            okayReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if okay (a required property) was received
    if !okayReceived {
		strct._okay_ValidationError = fmt.Errorf("\"Okay\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ReadOnlyFunctionSuccessResponse) Validate() []error {
    var allErrors []error
    if strct._okay_ValidationError != nil {
		allErrors = append(allErrors, strct._okay_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EntityId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_id\": ")
	if tmp, err := json.Marshal(strct.EntityId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EntityType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_type\": ")
	if tmp, err := json.Marshal(strct.EntityType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tx_data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_data\": ")
	if tmp, err := json.Marshal(strct.TxData); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result) UnmarshalJSON(b []byte) error {
    entity_idReceived := false
    entity_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "entity_id":
            if err := json.Unmarshal([]byte(v), &strct.EntityId); err != nil {
				return err
            }
            entity_idReceived = true
        case "entity_type":
            if err := json.Unmarshal([]byte(v), &strct.EntityType); err != nil {
				return err
            }
            entity_typeReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "tx_data":
            if err := json.Unmarshal([]byte(v), &strct.TxData); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if entity_id (a required property) was received
    if !entity_idReceived {
		strct._entity_id_ValidationError = fmt.Errorf("\"EntityId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if entity_type (a required property) was received
    if !entity_typeReceived {
		strct._entity_type_ValidationError = fmt.Errorf("\"EntityType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result) Validate() []error {
    var allErrors []error
    if strct._entity_id_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_id_ValidationError)
	}
    if strct._entity_type_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result_0034ed0505) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EntityId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_id\": ")
	if tmp, err := json.Marshal(strct.EntityId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EntityType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_type\": ")
	if tmp, err := json.Marshal(strct.EntityType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxData" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_data\": ")
	if tmp, err := json.Marshal(strct.TxData); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result_0034ed0505) UnmarshalJSON(b []byte) error {
    entity_idReceived := false
    entity_typeReceived := false
    tx_dataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "entity_id":
            if err := json.Unmarshal([]byte(v), &strct.EntityId); err != nil {
				return err
            }
            entity_idReceived = true
        case "entity_type":
            if err := json.Unmarshal([]byte(v), &strct.EntityType); err != nil {
				return err
            }
            entity_typeReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "tx_data":
            if err := json.Unmarshal([]byte(v), &strct.TxData); err != nil {
				return err
            }
            tx_dataReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if entity_id (a required property) was received
    if !entity_idReceived {
		strct._entity_id_ValidationError = fmt.Errorf("\"EntityId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if entity_type (a required property) was received
    if !entity_typeReceived {
		strct._entity_type_ValidationError = fmt.Errorf("\"EntityType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_data (a required property) was received
    if !tx_dataReceived {
		strct._tx_data_ValidationError = fmt.Errorf("\"TxData\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result_0034ed0505) Validate() []error {
    var allErrors []error
    if strct._entity_id_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_id_ValidationError)
	}
    if strct._entity_type_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_type_ValidationError)
	}
    if strct._tx_data_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_data_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result_0f2d7b8436) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockData" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_data\": ")
	if tmp, err := json.Marshal(strct.BlockData); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EntityId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_id\": ")
	if tmp, err := json.Marshal(strct.EntityId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EntityType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_type\": ")
	if tmp, err := json.Marshal(strct.EntityType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result_0f2d7b8436) UnmarshalJSON(b []byte) error {
    block_dataReceived := false
    entity_idReceived := false
    entity_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_data":
            if err := json.Unmarshal([]byte(v), &strct.BlockData); err != nil {
				return err
            }
            block_dataReceived = true
        case "entity_id":
            if err := json.Unmarshal([]byte(v), &strct.EntityId); err != nil {
				return err
            }
            entity_idReceived = true
        case "entity_type":
            if err := json.Unmarshal([]byte(v), &strct.EntityType); err != nil {
				return err
            }
            entity_typeReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_data (a required property) was received
    if !block_dataReceived {
		strct._block_data_ValidationError = fmt.Errorf("\"BlockData\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if entity_id (a required property) was received
    if !entity_idReceived {
		strct._entity_id_ValidationError = fmt.Errorf("\"EntityId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if entity_type (a required property) was received
    if !entity_typeReceived {
		strct._entity_type_ValidationError = fmt.Errorf("\"EntityType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result_0f2d7b8436) Validate() []error {
    var allErrors []error
    if strct._block_data_ValidationError != nil {
		allErrors = append(allErrors, strct._block_data_ValidationError)
	}
    if strct._entity_id_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_id_ValidationError)
	}
    if strct._entity_type_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result_6453106f3a) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result_6453106f3a) UnmarshalJSON(b []byte) error {
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result_6453106f3a) Validate() []error {
    var allErrors []error
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result_fe531e859f) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EntityId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_id\": ")
	if tmp, err := json.Marshal(strct.EntityId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EntityType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "entity_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"entity_type\": ")
	if tmp, err := json.Marshal(strct.EntityType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxData" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_data\": ")
	if tmp, err := json.Marshal(strct.TxData); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result_fe531e859f) UnmarshalJSON(b []byte) error {
    entity_idReceived := false
    entity_typeReceived := false
    tx_dataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "entity_id":
            if err := json.Unmarshal([]byte(v), &strct.EntityId); err != nil {
				return err
            }
            entity_idReceived = true
        case "entity_type":
            if err := json.Unmarshal([]byte(v), &strct.EntityType); err != nil {
				return err
            }
            entity_typeReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "tx_data":
            if err := json.Unmarshal([]byte(v), &strct.TxData); err != nil {
				return err
            }
            tx_dataReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if entity_id (a required property) was received
    if !entity_idReceived {
		strct._entity_id_ValidationError = fmt.Errorf("\"EntityId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if entity_type (a required property) was received
    if !entity_typeReceived {
		strct._entity_type_ValidationError = fmt.Errorf("\"EntityType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_data (a required property) was received
    if !tx_dataReceived {
		strct._tx_data_ValidationError = fmt.Errorf("\"TxData\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result_fe531e859f) Validate() []error {
    var allErrors []error
    if strct._entity_id_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_id_ValidationError)
	}
    if strct._entity_type_ValidationError != nil {
		allErrors = append(allErrors, strct._entity_type_ValidationError)
	}
    if strct._tx_data_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_data_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAccountBalanceRequest_RosettaBlockRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AccountIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "account_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account_identifier\": ")
	if tmp, err := json.Marshal(strct.AccountIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_identifier\": ")
	if tmp, err := json.Marshal(strct.BlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAccountBalanceRequest_RosettaBlockRequest) UnmarshalJSON(b []byte) error {
    account_identifierReceived := false
    network_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AccountIdentifier); err != nil {
				return err
            }
            account_identifierReceived = true
        case "block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.BlockIdentifier); err != nil {
				return err
            }
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if account_identifier (a required property) was received
    if !account_identifierReceived {
		strct._account_identifier_ValidationError = fmt.Errorf("\"AccountIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAccountBalanceRequest_RosettaBlockRequest) Validate() []error {
    var allErrors []error
    if strct._account_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._account_identifier_ValidationError)
	}
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAccountBalanceResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Balances" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balances" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balances\": ")
	if tmp, err := json.Marshal(strct.Balances); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_identifier\": ")
	if tmp, err := json.Marshal(strct.BlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "coins" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coins\": ")
	if tmp, err := json.Marshal(strct.Coins); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAccountBalanceResponse) UnmarshalJSON(b []byte) error {
    balancesReceived := false
    block_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "balances":
            if err := json.Unmarshal([]byte(v), &strct.Balances); err != nil {
				return err
            }
            balancesReceived = true
        case "block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.BlockIdentifier); err != nil {
				return err
            }
            block_identifierReceived = true
        case "coins":
            if err := json.Unmarshal([]byte(v), &strct.Coins); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if balances (a required property) was received
    if !balancesReceived {
		strct._balances_ValidationError = fmt.Errorf("\"Balances\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_identifier (a required property) was received
    if !block_identifierReceived {
		strct._block_identifier_ValidationError = fmt.Errorf("\"BlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAccountBalanceResponse) Validate() []error {
    var allErrors []error
    if strct._balances_ValidationError != nil {
		allErrors = append(allErrors, strct._balances_ValidationError)
	}
    if strct._block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._block_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sub_account" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sub_account\": ")
	if tmp, err := json.Marshal(strct.SubAccount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount) UnmarshalJSON(b []byte) error {
    addressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "sub_account":
            if err := json.Unmarshal([]byte(v), &strct.SubAccount); err != nil {
				return err
            }
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaNetworkListRequest_RosettaSubAccount) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Currency" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "currency" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"currency\": ")
	if tmp, err := json.Marshal(strct.Currency); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) UnmarshalJSON(b []byte) error {
    currencyReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "currency":
            if err := json.Unmarshal([]byte(v), &strct.Currency); err != nil {
				return err
            }
            currencyReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if currency (a required property) was received
    if !currencyReceived {
		strct._currency_ValidationError = fmt.Errorf("\"Currency\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) Validate() []error {
    var allErrors []error
    if strct._currency_ValidationError != nil {
		allErrors = append(allErrors, strct._currency_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_identifier\": ")
	if tmp, err := json.Marshal(strct.BlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_identifier\": ")
	if tmp, err := json.Marshal(strct.ParentBlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Timestamp" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "timestamp" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Transactions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transactions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transactions\": ")
	if tmp, err := json.Marshal(strct.Transactions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlock) UnmarshalJSON(b []byte) error {
    block_identifierReceived := false
    parent_block_identifierReceived := false
    timestampReceived := false
    transactionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.BlockIdentifier); err != nil {
				return err
            }
            block_identifierReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "parent_block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockIdentifier); err != nil {
				return err
            }
            parent_block_identifierReceived = true
        case "timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
				return err
            }
            timestampReceived = true
        case "transactions":
            if err := json.Unmarshal([]byte(v), &strct.Transactions); err != nil {
				return err
            }
            transactionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_identifier (a required property) was received
    if !block_identifierReceived {
		strct._block_identifier_ValidationError = fmt.Errorf("\"BlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_identifier (a required property) was received
    if !parent_block_identifierReceived {
		strct._parent_block_identifier_ValidationError = fmt.Errorf("\"ParentBlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if timestamp (a required property) was received
    if !timestampReceived {
		strct._timestamp_ValidationError = fmt.Errorf("\"Timestamp\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transactions (a required property) was received
    if !transactionsReceived {
		strct._transactions_ValidationError = fmt.Errorf("\"Transactions\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlock) Validate() []error {
    var allErrors []error
    if strct._block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._block_identifier_ValidationError)
	}
    if strct._parent_block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_identifier_ValidationError)
	}
    if strct._timestamp_ValidationError != nil {
		allErrors = append(allErrors, strct._timestamp_ValidationError)
	}
    if strct._transactions_ValidationError != nil {
		allErrors = append(allErrors, strct._transactions_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hash\": ")
	if tmp, err := json.Marshal(strct.Hash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) UnmarshalJSON(b []byte) error {
    hashReceived := false
    indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hash":
            if err := json.Unmarshal([]byte(v), &strct.Hash); err != nil {
				return err
            }
            hashReceived = true
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
				return err
            }
            indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hash (a required property) was received
    if !hashReceived {
		strct._hash_ValidationError = fmt.Errorf("\"Hash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if index (a required property) was received
    if !indexReceived {
		strct._index_ValidationError = fmt.Errorf("\"Index\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) Validate() []error {
    var allErrors []error
    if strct._hash_ValidationError != nil {
		allErrors = append(allErrors, strct._hash_ValidationError)
	}
    if strct._index_ValidationError != nil {
		allErrors = append(allErrors, strct._index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlockResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "block" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block\": ")
	if tmp, err := json.Marshal(strct.Block); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "other_transactions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"other_transactions\": ")
	if tmp, err := json.Marshal(strct.OtherTransactions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlockResponse) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block":
            if err := json.Unmarshal([]byte(v), &strct.Block); err != nil {
				return err
            }
        case "other_transactions":
            if err := json.Unmarshal([]byte(v), &strct.OtherTransactions); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RosettaBlockResponse) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_identifier\": ")
	if tmp, err := json.Marshal(strct.BlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction_identifier\": ")
	if tmp, err := json.Marshal(strct.TransactionIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest) UnmarshalJSON(b []byte) error {
    block_identifierReceived := false
    network_identifierReceived := false
    transaction_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.BlockIdentifier); err != nil {
				return err
            }
            block_identifierReceived = true
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "transaction_identifier":
            if err := json.Unmarshal([]byte(v), &strct.TransactionIdentifier); err != nil {
				return err
            }
            transaction_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_identifier (a required property) was received
    if !block_identifierReceived {
		strct._block_identifier_ValidationError = fmt.Errorf("\"BlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transaction_identifier (a required property) was received
    if !transaction_identifierReceived {
		strct._transaction_identifier_ValidationError = fmt.Errorf("\"TransactionIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlockTransactionRequest_RosettaMempoolTransactionRequest) Validate() []error {
    var allErrors []error
    if strct._block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._block_identifier_ValidationError)
	}
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._transaction_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Transaction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction\": ")
	if tmp, err := json.Marshal(strct.Transaction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse) UnmarshalJSON(b []byte) error {
    transactionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "transaction":
            if err := json.Unmarshal([]byte(v), &strct.Transaction); err != nil {
				return err
            }
            transactionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if transaction (a required property) was received
    if !transactionReceived {
		strct._transaction_ValidationError = fmt.Errorf("\"Transaction\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlockTransactionResponse_RosettaMempoolTransactionResponse) Validate() []error {
    var allErrors []error
    if strct._transaction_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCoin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "CoinIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_identifier\": ")
	if tmp, err := json.Marshal(strct.CoinIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCoin) UnmarshalJSON(b []byte) error {
    amountReceived := false
    coin_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "coin_identifier":
            if err := json.Unmarshal([]byte(v), &strct.CoinIdentifier); err != nil {
				return err
            }
            coin_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if coin_identifier (a required property) was received
    if !coin_identifierReceived {
		strct._coin_identifier_ValidationError = fmt.Errorf("\"CoinIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCoin) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._coin_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCoinChange) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CoinAction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_action" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_action\": ")
	if tmp, err := json.Marshal(strct.CoinAction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "CoinIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_identifier\": ")
	if tmp, err := json.Marshal(strct.CoinIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCoinChange) UnmarshalJSON(b []byte) error {
    coin_actionReceived := false
    coin_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "coin_action":
            if err := json.Unmarshal([]byte(v), &strct.CoinAction); err != nil {
				return err
            }
            coin_actionReceived = true
        case "coin_identifier":
            if err := json.Unmarshal([]byte(v), &strct.CoinIdentifier); err != nil {
				return err
            }
            coin_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if coin_action (a required property) was received
    if !coin_actionReceived {
		strct._coin_action_ValidationError = fmt.Errorf("\"CoinAction\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if coin_identifier (a required property) was received
    if !coin_identifierReceived {
		strct._coin_identifier_ValidationError = fmt.Errorf("\"CoinIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCoinChange) Validate() []error {
    var allErrors []error
    if strct._coin_action_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_action_ValidationError)
	}
    if strct._coin_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionCombineRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Signatures" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signatures" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signatures\": ")
	if tmp, err := json.Marshal(strct.Signatures); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnsignedTransaction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unsigned_transaction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unsigned_transaction\": ")
	if tmp, err := json.Marshal(strct.UnsignedTransaction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionCombineRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    signaturesReceived := false
    unsigned_transactionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "signatures":
            if err := json.Unmarshal([]byte(v), &strct.Signatures); err != nil {
				return err
            }
            signaturesReceived = true
        case "unsigned_transaction":
            if err := json.Unmarshal([]byte(v), &strct.UnsignedTransaction); err != nil {
				return err
            }
            unsigned_transactionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signatures (a required property) was received
    if !signaturesReceived {
		strct._signatures_ValidationError = fmt.Errorf("\"Signatures\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unsigned_transaction (a required property) was received
    if !unsigned_transactionReceived {
		strct._unsigned_transaction_ValidationError = fmt.Errorf("\"UnsignedTransaction\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionCombineRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._signatures_ValidationError != nil {
		allErrors = append(allErrors, strct._signatures_ValidationError)
	}
    if strct._unsigned_transaction_ValidationError != nil {
		allErrors = append(allErrors, strct._unsigned_transaction_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SignedTransaction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signed_transaction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signed_transaction\": ")
	if tmp, err := json.Marshal(strct.SignedTransaction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    signed_transactionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "signed_transaction":
            if err := json.Unmarshal([]byte(v), &strct.SignedTransaction); err != nil {
				return err
            }
            signed_transactionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signed_transaction (a required property) was received
    if !signed_transactionReceived {
		strct._signed_transaction_ValidationError = fmt.Errorf("\"SignedTransaction\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionCombineResponse_RosettaConstructionHashRequest_RosettaConstructionSubmitRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._signed_transaction_ValidationError != nil {
		allErrors = append(allErrors, strct._signed_transaction_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PublicKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "public_key" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"public_key\": ")
	if tmp, err := json.Marshal(strct.PublicKey); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    public_keyReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "public_key":
            if err := json.Unmarshal([]byte(v), &strct.PublicKey); err != nil {
				return err
            }
            public_keyReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if public_key (a required property) was received
    if !public_keyReceived {
		strct._public_key_ValidationError = fmt.Errorf("\"PublicKey\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionDeriveRequest_RosettaOptionsRequest_RosettaStatusRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._public_key_ValidationError != nil {
		allErrors = append(allErrors, strct._public_key_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionDeriveResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account_identifier\": ")
	if tmp, err := json.Marshal(strct.AccountIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionDeriveResponse) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AccountIdentifier); err != nil {
				return err
            }
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RosettaConstructionDeriveResponse) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Operations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction_identifier\": ")
	if tmp, err := json.Marshal(strct.TransactionIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction) UnmarshalJSON(b []byte) error {
    operationsReceived := false
    transaction_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
				return err
            }
            operationsReceived = true
        case "transaction_identifier":
            if err := json.Unmarshal([]byte(v), &strct.TransactionIdentifier); err != nil {
				return err
            }
            transaction_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if operations (a required property) was received
    if !operationsReceived {
		strct._operations_ValidationError = fmt.Errorf("\"Operations\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transaction_identifier (a required property) was received
    if !transaction_identifierReceived {
		strct._transaction_identifier_ValidationError = fmt.Errorf("\"TransactionIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionHashResponse_RosettaConstructionSubmitResponse_RosettaTransaction) Validate() []error {
    var allErrors []error
    if strct._operations_ValidationError != nil {
		allErrors = append(allErrors, strct._operations_ValidationError)
	}
    if strct._transaction_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionMetadataRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Options" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "options" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "public_keys" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"public_keys\": ")
	if tmp, err := json.Marshal(strct.PublicKeys); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionMetadataRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    optionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
				return err
            }
            optionsReceived = true
        case "public_keys":
            if err := json.Unmarshal([]byte(v), &strct.PublicKeys); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if options (a required property) was received
    if !optionsReceived {
		strct._options_ValidationError = fmt.Errorf("\"Options\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionMetadataRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._options_ValidationError != nil {
		allErrors = append(allErrors, strct._options_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionMetadataResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Metadata" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "suggested_fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"suggested_fee\": ")
	if tmp, err := json.Marshal(strct.SuggestedFee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionMetadataResponse) UnmarshalJSON(b []byte) error {
    metadataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
            metadataReceived = true
        case "suggested_fee":
            if err := json.Unmarshal([]byte(v), &strct.SuggestedFee); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if metadata (a required property) was received
    if !metadataReceived {
		strct._metadata_ValidationError = fmt.Errorf("\"Metadata\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionMetadataResponse) Validate() []error {
    var allErrors []error
    if strct._metadata_ValidationError != nil {
		allErrors = append(allErrors, strct._metadata_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionParseResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account_identifier_signers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account_identifier_signers\": ")
	if tmp, err := json.Marshal(strct.AccountIdentifierSigners); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Operations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "signers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signers\": ")
	if tmp, err := json.Marshal(strct.Signers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionParseResponse) UnmarshalJSON(b []byte) error {
    operationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account_identifier_signers":
            if err := json.Unmarshal([]byte(v), &strct.AccountIdentifierSigners); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
				return err
            }
            operationsReceived = true
        case "signers":
            if err := json.Unmarshal([]byte(v), &strct.Signers); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if operations (a required property) was received
    if !operationsReceived {
		strct._operations_ValidationError = fmt.Errorf("\"Operations\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionParseResponse) Validate() []error {
    var allErrors []error
    if strct._operations_ValidationError != nil {
		allErrors = append(allErrors, strct._operations_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionPayloadResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Payloads" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "payloads" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"payloads\": ")
	if tmp, err := json.Marshal(strct.Payloads); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnsignedTransaction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unsigned_transaction" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unsigned_transaction\": ")
	if tmp, err := json.Marshal(strct.UnsignedTransaction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionPayloadResponse) UnmarshalJSON(b []byte) error {
    payloadsReceived := false
    unsigned_transactionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "payloads":
            if err := json.Unmarshal([]byte(v), &strct.Payloads); err != nil {
				return err
            }
            payloadsReceived = true
        case "unsigned_transaction":
            if err := json.Unmarshal([]byte(v), &strct.UnsignedTransaction); err != nil {
				return err
            }
            unsigned_transactionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if payloads (a required property) was received
    if !payloadsReceived {
		strct._payloads_ValidationError = fmt.Errorf("\"Payloads\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unsigned_transaction (a required property) was received
    if !unsigned_transactionReceived {
		strct._unsigned_transaction_ValidationError = fmt.Errorf("\"UnsignedTransaction\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionPayloadResponse) Validate() []error {
    var allErrors []error
    if strct._payloads_ValidationError != nil {
		allErrors = append(allErrors, strct._payloads_ValidationError)
	}
    if strct._unsigned_transaction_ValidationError != nil {
		allErrors = append(allErrors, strct._unsigned_transaction_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionPayloadsRequest_RosettaMempoolRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Operations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "public_keys" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"public_keys\": ")
	if tmp, err := json.Marshal(strct.PublicKeys); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionPayloadsRequest_RosettaMempoolRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    operationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
				return err
            }
            operationsReceived = true
        case "public_keys":
            if err := json.Unmarshal([]byte(v), &strct.PublicKeys); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if operations (a required property) was received
    if !operationsReceived {
		strct._operations_ValidationError = fmt.Errorf("\"Operations\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionPayloadsRequest_RosettaMempoolRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._operations_ValidationError != nil {
		allErrors = append(allErrors, strct._operations_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionPreprocessRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "max_fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_fee\": ")
	if tmp, err := json.Marshal(strct.MaxFee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NetworkIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifier\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Operations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "suggested_fee_multiplier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"suggested_fee_multiplier\": ")
	if tmp, err := json.Marshal(strct.SuggestedFeeMultiplier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionPreprocessRequest) UnmarshalJSON(b []byte) error {
    network_identifierReceived := false
    operationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "max_fee":
            if err := json.Unmarshal([]byte(v), &strct.MaxFee); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifier); err != nil {
				return err
            }
            network_identifierReceived = true
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
				return err
            }
            operationsReceived = true
        case "suggested_fee_multiplier":
            if err := json.Unmarshal([]byte(v), &strct.SuggestedFeeMultiplier); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifier (a required property) was received
    if !network_identifierReceived {
		strct._network_identifier_ValidationError = fmt.Errorf("\"NetworkIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if operations (a required property) was received
    if !operationsReceived {
		strct._operations_ValidationError = fmt.Errorf("\"Operations\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaConstructionPreprocessRequest) Validate() []error {
    var allErrors []error
    if strct._network_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifier_ValidationError)
	}
    if strct._operations_ValidationError != nil {
		allErrors = append(allErrors, strct._operations_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaConstructionPreprocessResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "options" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required_public_keys" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"required_public_keys\": ")
	if tmp, err := json.Marshal(strct.RequiredPublicKeys); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaConstructionPreprocessResponse) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
				return err
            }
        case "required_public_keys":
            if err := json.Unmarshal([]byte(v), &strct.RequiredPublicKeys); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RosettaConstructionPreprocessResponse) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCurrency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Decimals" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Symbol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCurrency) UnmarshalJSON(b []byte) error {
    decimalsReceived := false
    symbolReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
            decimalsReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
            symbolReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if decimals (a required property) was received
    if !decimalsReceived {
		strct._decimals_ValidationError = fmt.Errorf("\"Decimals\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if symbol (a required property) was received
    if !symbolReceived {
		strct._symbol_ValidationError = fmt.Errorf("\"Symbol\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCurrency) Validate() []error {
    var allErrors []error
    if strct._decimals_ValidationError != nil {
		allErrors = append(allErrors, strct._decimals_ValidationError)
	}
    if strct._symbol_ValidationError != nil {
		allErrors = append(allErrors, strct._symbol_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaError_RosettaErrorNoDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Code" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "details" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"details\": ")
	if tmp, err := json.Marshal(strct.Details); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Message" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "message" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Retriable" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "retriable" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"retriable\": ")
	if tmp, err := json.Marshal(strct.Retriable); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaError_RosettaErrorNoDetails) UnmarshalJSON(b []byte) error {
    codeReceived := false
    messageReceived := false
    retriableReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
				return err
            }
            codeReceived = true
        case "details":
            if err := json.Unmarshal([]byte(v), &strct.Details); err != nil {
				return err
            }
        case "message":
            if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
				return err
            }
            messageReceived = true
        case "retriable":
            if err := json.Unmarshal([]byte(v), &strct.Retriable); err != nil {
				return err
            }
            retriableReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if code (a required property) was received
    if !codeReceived {
		strct._code_ValidationError = fmt.Errorf("\"Code\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if message (a required property) was received
    if !messageReceived {
		strct._message_ValidationError = fmt.Errorf("\"Message\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if retriable (a required property) was received
    if !retriableReceived {
		strct._retriable_ValidationError = fmt.Errorf("\"Retriable\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaError_RosettaErrorNoDetails) Validate() []error {
    var allErrors []error
    if strct._code_ValidationError != nil {
		allErrors = append(allErrors, strct._code_ValidationError)
	}
    if strct._message_ValidationError != nil {
		allErrors = append(allErrors, strct._message_ValidationError)
	}
    if strct._retriable_ValidationError != nil {
		allErrors = append(allErrors, strct._retriable_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaMempoolResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionIdentifiers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction_identifiers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction_identifiers\": ")
	if tmp, err := json.Marshal(strct.TransactionIdentifiers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaMempoolResponse) UnmarshalJSON(b []byte) error {
    transaction_identifiersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "transaction_identifiers":
            if err := json.Unmarshal([]byte(v), &strct.TransactionIdentifiers); err != nil {
				return err
            }
            transaction_identifiersReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if transaction_identifiers (a required property) was received
    if !transaction_identifiersReceived {
		strct._transaction_identifiers_ValidationError = fmt.Errorf("\"TransactionIdentifiers\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaMempoolResponse) Validate() []error {
    var allErrors []error
    if strct._transaction_identifiers_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_identifiers_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaNetworkListResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "NetworkIdentifiers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network_identifiers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_identifiers\": ")
	if tmp, err := json.Marshal(strct.NetworkIdentifiers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaNetworkListResponse) UnmarshalJSON(b []byte) error {
    network_identifiersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network_identifiers":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIdentifiers); err != nil {
				return err
            }
            network_identifiersReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network_identifiers (a required property) was received
    if !network_identifiersReceived {
		strct._network_identifiers_ValidationError = fmt.Errorf("\"NetworkIdentifiers\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaNetworkListResponse) Validate() []error {
    var allErrors []error
    if strct._network_identifiers_ValidationError != nil {
		allErrors = append(allErrors, strct._network_identifiers_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaNetworkOptionsResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Allow" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "allow" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"allow\": ")
	if tmp, err := json.Marshal(strct.Allow); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaNetworkOptionsResponse) UnmarshalJSON(b []byte) error {
    allowReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allow":
            if err := json.Unmarshal([]byte(v), &strct.Allow); err != nil {
				return err
            }
            allowReceived = true
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
				return err
            }
            versionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if allow (a required property) was received
    if !allowReceived {
		strct._allow_ValidationError = fmt.Errorf("\"Allow\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if version (a required property) was received
    if !versionReceived {
		strct._version_ValidationError = fmt.Errorf("\"Version\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaNetworkOptionsResponse) Validate() []error {
    var allErrors []error
    if strct._allow_ValidationError != nil {
		allErrors = append(allErrors, strct._allow_ValidationError)
	}
    if strct._version_ValidationError != nil {
		allErrors = append(allErrors, strct._version_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaNetworkStatusResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CurrentBlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "current_block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"current_block_identifier\": ")
	if tmp, err := json.Marshal(strct.CurrentBlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "CurrentBlockTimestamp" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "current_block_timestamp" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"current_block_timestamp\": ")
	if tmp, err := json.Marshal(strct.CurrentBlockTimestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "GenesisBlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "genesis_block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"genesis_block_identifier\": ")
	if tmp, err := json.Marshal(strct.GenesisBlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "oldest_block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"oldest_block_identifier\": ")
	if tmp, err := json.Marshal(strct.OldestBlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Peers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "peers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"peers\": ")
	if tmp, err := json.Marshal(strct.Peers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sync_status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sync_status\": ")
	if tmp, err := json.Marshal(strct.SyncStatus); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaNetworkStatusResponse) UnmarshalJSON(b []byte) error {
    current_block_identifierReceived := false
    current_block_timestampReceived := false
    genesis_block_identifierReceived := false
    peersReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "current_block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.CurrentBlockIdentifier); err != nil {
				return err
            }
            current_block_identifierReceived = true
        case "current_block_timestamp":
            if err := json.Unmarshal([]byte(v), &strct.CurrentBlockTimestamp); err != nil {
				return err
            }
            current_block_timestampReceived = true
        case "genesis_block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.GenesisBlockIdentifier); err != nil {
				return err
            }
            genesis_block_identifierReceived = true
        case "oldest_block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.OldestBlockIdentifier); err != nil {
				return err
            }
        case "peers":
            if err := json.Unmarshal([]byte(v), &strct.Peers); err != nil {
				return err
            }
            peersReceived = true
        case "sync_status":
            if err := json.Unmarshal([]byte(v), &strct.SyncStatus); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if current_block_identifier (a required property) was received
    if !current_block_identifierReceived {
		strct._current_block_identifier_ValidationError = fmt.Errorf("\"CurrentBlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if current_block_timestamp (a required property) was received
    if !current_block_timestampReceived {
		strct._current_block_timestamp_ValidationError = fmt.Errorf("\"CurrentBlockTimestamp\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if genesis_block_identifier (a required property) was received
    if !genesis_block_identifierReceived {
		strct._genesis_block_identifier_ValidationError = fmt.Errorf("\"GenesisBlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if peers (a required property) was received
    if !peersReceived {
		strct._peers_ValidationError = fmt.Errorf("\"Peers\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaNetworkStatusResponse) Validate() []error {
    var allErrors []error
    if strct._current_block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._current_block_identifier_ValidationError)
	}
    if strct._current_block_timestamp_ValidationError != nil {
		allErrors = append(allErrors, strct._current_block_timestamp_ValidationError)
	}
    if strct._genesis_block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._genesis_block_identifier_ValidationError)
	}
    if strct._peers_ValidationError != nil {
		allErrors = append(allErrors, strct._peers_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "coin_change" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_change\": ")
	if tmp, err := json.Marshal(strct.CoinChange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "OperationIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operation_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operation_identifier\": ")
	if tmp, err := json.Marshal(strct.OperationIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "related_operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"related_operations\": ")
	if tmp, err := json.Marshal(strct.RelatedOperations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperation) UnmarshalJSON(b []byte) error {
    operation_identifierReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
				return err
            }
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "coin_change":
            if err := json.Unmarshal([]byte(v), &strct.CoinChange); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "operation_identifier":
            if err := json.Unmarshal([]byte(v), &strct.OperationIdentifier); err != nil {
				return err
            }
            operation_identifierReceived = true
        case "related_operations":
            if err := json.Unmarshal([]byte(v), &strct.RelatedOperations); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if operation_identifier (a required property) was received
    if !operation_identifierReceived {
		strct._operation_identifier_ValidationError = fmt.Errorf("\"OperationIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if type (a required property) was received
    if !typeReceived {
		strct._type_ValidationError = fmt.Errorf("\"Type\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperation) Validate() []error {
    var allErrors []error
    if strct._operation_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._operation_identifier_ValidationError)
	}
    if strct._type_ValidationError != nil {
		allErrors = append(allErrors, strct._type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "network_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_index\": ")
	if tmp, err := json.Marshal(strct.NetworkIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) UnmarshalJSON(b []byte) error {
    indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
				return err
            }
            indexReceived = true
        case "network_index":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIndex); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if index (a required property) was received
    if !indexReceived {
		strct._index_ValidationError = fmt.Errorf("\"Index\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) Validate() []error {
    var allErrors []error
    if strct._index_ValidationError != nil {
		allErrors = append(allErrors, strct._index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperationStatus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Successful" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "successful" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"successful\": ")
	if tmp, err := json.Marshal(strct.Successful); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperationStatus) UnmarshalJSON(b []byte) error {
    statusReceived := false
    successfulReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
            statusReceived = true
        case "successful":
            if err := json.Unmarshal([]byte(v), &strct.Successful); err != nil {
				return err
            }
            successfulReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if status (a required property) was received
    if !statusReceived {
		strct._status_ValidationError = fmt.Errorf("\"Status\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if successful (a required property) was received
    if !successfulReceived {
		strct._successful_ValidationError = fmt.Errorf("\"Successful\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperationStatus) Validate() []error {
    var allErrors []error
    if strct._status_ValidationError != nil {
		allErrors = append(allErrors, strct._status_ValidationError)
	}
    if strct._successful_ValidationError != nil {
		allErrors = append(allErrors, strct._successful_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contract_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_address\": ")
	if tmp, err := json.Marshal(strct.ContractAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contract_name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_name\": ")
	if tmp, err := json.Marshal(strct.ContractName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "delegate_to" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"delegate_to\": ")
	if tmp, err := json.Marshal(strct.DelegateTo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fee\": ")
	if tmp, err := json.Marshal(strct.Fee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "gas_limit" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"gas_limit\": ")
	if tmp, err := json.Marshal(strct.GasLimit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "gas_price" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"gas_price\": ")
	if tmp, err := json.Marshal(strct.GasPrice); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "max_fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_fee\": ")
	if tmp, err := json.Marshal(strct.MaxFee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "number_of_cycles" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"number_of_cycles\": ")
	if tmp, err := json.Marshal(strct.NumberOfCycles); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pox_addr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"pox_addr\": ")
	if tmp, err := json.Marshal(strct.PoxAddr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "suggested_fee_multiplier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"suggested_fee_multiplier\": ")
	if tmp, err := json.Marshal(strct.SuggestedFeeMultiplier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "token_transfer_recipient_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_transfer_recipient_address\": ")
	if tmp, err := json.Marshal(strct.TokenTransferRecipientAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
        case "contract_address":
            if err := json.Unmarshal([]byte(v), &strct.ContractAddress); err != nil {
				return err
            }
        case "contract_name":
            if err := json.Unmarshal([]byte(v), &strct.ContractName); err != nil {
				return err
            }
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
        case "delegate_to":
            if err := json.Unmarshal([]byte(v), &strct.DelegateTo); err != nil {
				return err
            }
        case "fee":
            if err := json.Unmarshal([]byte(v), &strct.Fee); err != nil {
				return err
            }
        case "gas_limit":
            if err := json.Unmarshal([]byte(v), &strct.GasLimit); err != nil {
				return err
            }
        case "gas_price":
            if err := json.Unmarshal([]byte(v), &strct.GasPrice); err != nil {
				return err
            }
        case "max_fee":
            if err := json.Unmarshal([]byte(v), &strct.MaxFee); err != nil {
				return err
            }
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
        case "number_of_cycles":
            if err := json.Unmarshal([]byte(v), &strct.NumberOfCycles); err != nil {
				return err
            }
        case "pox_addr":
            if err := json.Unmarshal([]byte(v), &strct.PoxAddr); err != nil {
				return err
            }
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
        case "suggested_fee_multiplier":
            if err := json.Unmarshal([]byte(v), &strct.SuggestedFeeMultiplier); err != nil {
				return err
            }
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
        case "token_transfer_recipient_address":
            if err := json.Unmarshal([]byte(v), &strct.TokenTransferRecipientAddress); err != nil {
				return err
            }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RosettaOptions) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaPeers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PeerId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "peer_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"peer_id\": ")
	if tmp, err := json.Marshal(strct.PeerId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaPeers) UnmarshalJSON(b []byte) error {
    peer_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "peer_id":
            if err := json.Unmarshal([]byte(v), &strct.PeerId); err != nil {
				return err
            }
            peer_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if peer_id (a required property) was received
    if !peer_idReceived {
		strct._peer_id_ValidationError = fmt.Errorf("\"PeerId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaPeers) Validate() []error {
    var allErrors []error
    if strct._peer_id_ValidationError != nil {
		allErrors = append(allErrors, strct._peer_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaPublicKey) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CurveType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "curve_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"curve_type\": ")
	if tmp, err := json.Marshal(strct.CurveType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaPublicKey) UnmarshalJSON(b []byte) error {
    curve_typeReceived := false
    hex_bytesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "curve_type":
            if err := json.Unmarshal([]byte(v), &strct.CurveType); err != nil {
				return err
            }
            curve_typeReceived = true
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if curve_type (a required property) was received
    if !curve_typeReceived {
		strct._curve_type_ValidationError = fmt.Errorf("\"CurveType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaPublicKey) Validate() []error {
    var allErrors []error
    if strct._curve_type_ValidationError != nil {
		allErrors = append(allErrors, strct._curve_type_ValidationError)
	}
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaSignature) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PublicKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "public_key" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"public_key\": ")
	if tmp, err := json.Marshal(strct.PublicKey); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SignatureType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signature_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signature_type\": ")
	if tmp, err := json.Marshal(strct.SignatureType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SigningPayload" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signing_payload" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signing_payload\": ")
	if tmp, err := json.Marshal(strct.SigningPayload); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaSignature) UnmarshalJSON(b []byte) error {
    hex_bytesReceived := false
    public_keyReceived := false
    signature_typeReceived := false
    signing_payloadReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        case "public_key":
            if err := json.Unmarshal([]byte(v), &strct.PublicKey); err != nil {
				return err
            }
            public_keyReceived = true
        case "signature_type":
            if err := json.Unmarshal([]byte(v), &strct.SignatureType); err != nil {
				return err
            }
            signature_typeReceived = true
        case "signing_payload":
            if err := json.Unmarshal([]byte(v), &strct.SigningPayload); err != nil {
				return err
            }
            signing_payloadReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if public_key (a required property) was received
    if !public_keyReceived {
		strct._public_key_ValidationError = fmt.Errorf("\"PublicKey\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signature_type (a required property) was received
    if !signature_typeReceived {
		strct._signature_type_ValidationError = fmt.Errorf("\"SignatureType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signing_payload (a required property) was received
    if !signing_payloadReceived {
		strct._signing_payload_ValidationError = fmt.Errorf("\"SigningPayload\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaSignature) Validate() []error {
    var allErrors []error
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if strct._public_key_ValidationError != nil {
		allErrors = append(allErrors, strct._public_key_ValidationError)
	}
    if strct._signature_type_ValidationError != nil {
		allErrors = append(allErrors, strct._signature_type_ValidationError)
	}
    if strct._signing_payload_ValidationError != nil {
		allErrors = append(allErrors, strct._signing_payload_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaSyncStatus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CurrentIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "current_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"current_index\": ")
	if tmp, err := json.Marshal(strct.CurrentIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stage" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stage\": ")
	if tmp, err := json.Marshal(strct.Stage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "synced" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"synced\": ")
	if tmp, err := json.Marshal(strct.Synced); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "target_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"target_index\": ")
	if tmp, err := json.Marshal(strct.TargetIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaSyncStatus) UnmarshalJSON(b []byte) error {
    current_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "current_index":
            if err := json.Unmarshal([]byte(v), &strct.CurrentIndex); err != nil {
				return err
            }
            current_indexReceived = true
        case "stage":
            if err := json.Unmarshal([]byte(v), &strct.Stage); err != nil {
				return err
            }
        case "synced":
            if err := json.Unmarshal([]byte(v), &strct.Synced); err != nil {
				return err
            }
        case "target_index":
            if err := json.Unmarshal([]byte(v), &strct.TargetIndex); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if current_index (a required property) was received
    if !current_indexReceived {
		strct._current_index_ValidationError = fmt.Errorf("\"CurrentIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaSyncStatus) Validate() []error {
    var allErrors []error
    if strct._current_index_ValidationError != nil {
		allErrors = append(allErrors, strct._current_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceNotificationParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Balance" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance\": ")
	if tmp, err := json.Marshal(strct.Balance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceNotificationParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    balanceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "balance":
            if err := json.Unmarshal([]byte(v), &strct.Balance); err != nil {
				return err
            }
            balanceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if balance (a required property) was received
    if !balanceReceived {
		strct._balance_ValidationError = fmt.Errorf("\"Balance\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceNotificationParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._balance_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    eventReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
				return err
            }
            eventReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event (a required property) was received
    if !eventReceived {
		strct._event_ValidationError = fmt.Errorf("\"Event\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._event_ValidationError != nil {
		allErrors = append(allErrors, strct._event_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_status\": ")
	if tmp, err := json.Marshal(strct.TxStatus); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    tx_idReceived := false
    tx_statusReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "tx_status":
            if err := json.Unmarshal([]byte(v), &strct.TxStatus); err != nil {
				return err
            }
            tx_statusReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_status (a required property) was received
    if !tx_statusReceived {
		strct._tx_status_ValidationError = fmt.Errorf("\"TxStatus\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._tx_status_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_status_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxNotificationResponse_RpcTxUpdateNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcBlockNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcBlockNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcBlockNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams) UnmarshalJSON(b []byte) error {
    eventReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
				return err
            }
            eventReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event (a required property) was received
    if !eventReceived {
		strct._event_ValidationError = fmt.Errorf("\"Event\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams_RpcTxUpdateSubscriptionParams) Validate() []error {
    var allErrors []error
    if strct._event_ValidationError != nil {
		allErrors = append(allErrors, strct._event_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcBlockSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcBlockSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcBlockSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMempoolNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMempoolNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMempoolNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMempoolSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMempoolSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMempoolSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMicroblockNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMicroblockNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMicroblockNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMicroblockSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMicroblockSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMicroblockSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcTxUpdateSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcTxUpdateSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcTxUpdateSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RunFaucetResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Success" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "success" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"success\": ")
	if tmp, err := json.Marshal(strct.Success); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "txId" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txId\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "txRaw" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txRaw\": ")
	if tmp, err := json.Marshal(strct.TxRaw); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RunFaucetResponse) UnmarshalJSON(b []byte) error {
    successReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "success":
            if err := json.Unmarshal([]byte(v), &strct.Success); err != nil {
				return err
            }
            successReceived = true
        case "txId":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
        case "txRaw":
            if err := json.Unmarshal([]byte(v), &strct.TxRaw); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if success (a required property) was received
    if !successReceived {
		strct._success_ValidationError = fmt.Errorf("\"Success\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RunFaucetResponse) Validate() []error {
    var allErrors []error
    if strct._success_ValidationError != nil {
		allErrors = append(allErrors, strct._success_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ServerStatusResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "chain_tip" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"chain_tip\": ")
	if tmp, err := json.Marshal(strct.ChainTip); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "server_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"server_version\": ")
	if tmp, err := json.Marshal(strct.ServerVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerStatusResponse) UnmarshalJSON(b []byte) error {
    statusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "chain_tip":
            if err := json.Unmarshal([]byte(v), &strct.ChainTip); err != nil {
				return err
            }
        case "server_version":
            if err := json.Unmarshal([]byte(v), &strct.ServerVersion); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
            statusReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if status (a required property) was received
    if !statusReceived {
		strct._status_ValidationError = fmt.Errorf("\"Status\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ServerStatusResponse) Validate() []error {
    var allErrors []error
    if strct._status_ValidationError != nil {
		allErrors = append(allErrors, strct._status_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SigningPayload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account_identifier\": ")
	if tmp, err := json.Marshal(strct.AccountIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "signature_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signature_type\": ")
	if tmp, err := json.Marshal(strct.SignatureType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SigningPayload) UnmarshalJSON(b []byte) error {
    hex_bytesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AccountIdentifier); err != nil {
				return err
            }
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        case "signature_type":
            if err := json.Unmarshal([]byte(v), &strct.SignatureType); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SigningPayload) Validate() []error {
    var allErrors []error
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContract) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Abi" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "abi" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"abi\": ")
	if tmp, err := json.Marshal(strct.Abi); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SourceCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "source_code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"source_code\": ")
	if tmp, err := json.Marshal(strct.SourceCode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContract) UnmarshalJSON(b []byte) error {
    abiReceived := false
    block_heightReceived := false
    canonicalReceived := false
    source_codeReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "abi":
            if err := json.Unmarshal([]byte(v), &strct.Abi); err != nil {
				return err
            }
            abiReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "source_code":
            if err := json.Unmarshal([]byte(v), &strct.SourceCode); err != nil {
				return err
            }
            source_codeReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if abi (a required property) was received
    if !abiReceived {
		strct._abi_ValidationError = fmt.Errorf("\"Abi\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if source_code (a required property) was received
    if !source_codeReceived {
		strct._source_code_ValidationError = fmt.Errorf("\"SourceCode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContract) Validate() []error {
    var allErrors []error
    if strct._abi_ValidationError != nil {
		allErrors = append(allErrors, strct._abi_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._source_code_ValidationError != nil {
		allErrors = append(allErrors, strct._source_code_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContractTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SmartContract" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "smart_contract" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"smart_contract\": ")
	if tmp, err := json.Marshal(strct.SmartContract); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContractTransactionMetadata) UnmarshalJSON(b []byte) error {
    smart_contractReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "smart_contract":
            if err := json.Unmarshal([]byte(v), &strct.SmartContract); err != nil {
				return err
            }
            smart_contractReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if smart_contract (a required property) was received
    if !smart_contractReceived {
		strct._smart_contract_ValidationError = fmt.Errorf("\"SmartContract\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContractTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._smart_contract_ValidationError != nil {
		allErrors = append(allErrors, strct._smart_contract_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContract_b2c173c5bf) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_id\": ")
	if tmp, err := json.Marshal(strct.ContractId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SourceCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "source_code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"source_code\": ")
	if tmp, err := json.Marshal(strct.SourceCode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContract_b2c173c5bf) UnmarshalJSON(b []byte) error {
    contract_idReceived := false
    source_codeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_id":
            if err := json.Unmarshal([]byte(v), &strct.ContractId); err != nil {
				return err
            }
            contract_idReceived = true
        case "source_code":
            if err := json.Unmarshal([]byte(v), &strct.SourceCode); err != nil {
				return err
            }
            source_codeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_id (a required property) was received
    if !contract_idReceived {
		strct._contract_id_ValidationError = fmt.Errorf("\"ContractId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if source_code (a required property) was received
    if !source_codeReceived {
		strct._source_code_ValidationError = fmt.Errorf("\"SourceCode\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContract_b2c173c5bf) Validate() []error {
    var allErrors []error
    if strct._contract_id_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_id_ValidationError)
	}
    if strct._source_code_ValidationError != nil {
		allErrors = append(allErrors, strct._source_code_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *StxTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StxTransfersItems) UnmarshalJSON(b []byte) error {
    amountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *StxTransfersItems) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SubNetworkIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Network" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network\": ")
	if tmp, err := json.Marshal(strct.Network); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SubNetworkIdentifier) UnmarshalJSON(b []byte) error {
    networkReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "network":
            if err := json.Unmarshal([]byte(v), &strct.Network); err != nil {
				return err
            }
            networkReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network (a required property) was received
    if !networkReceived {
		strct._network_ValidationError = fmt.Errorf("\"Network\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SubNetworkIdentifier) Validate() []error {
    var allErrors []error
    if strct._network_ValidationError != nil {
		allErrors = append(allErrors, strct._network_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TargetBlockTime) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TargetBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "target_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"target_block_time\": ")
	if tmp, err := json.Marshal(strct.TargetBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetBlockTime) UnmarshalJSON(b []byte) error {
    target_block_timeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "target_block_time":
            if err := json.Unmarshal([]byte(v), &strct.TargetBlockTime); err != nil {
				return err
            }
            target_block_timeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if target_block_time (a required property) was received
    if !target_block_timeReceived {
		strct._target_block_time_ValidationError = fmt.Errorf("\"TargetBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TargetBlockTime) Validate() []error {
    var allErrors []error
    if strct._target_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._target_block_time_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TokenTransfer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Memo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RecipientAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recipient_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient_address\": ")
	if tmp, err := json.Marshal(strct.RecipientAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TokenTransfer) UnmarshalJSON(b []byte) error {
    amountReceived := false
    memoReceived := false
    recipient_addressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
            memoReceived = true
        case "recipient_address":
            if err := json.Unmarshal([]byte(v), &strct.RecipientAddress); err != nil {
				return err
            }
            recipient_addressReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if memo (a required property) was received
    if !memoReceived {
		strct._memo_ValidationError = fmt.Errorf("\"Memo\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if recipient_address (a required property) was received
    if !recipient_addressReceived {
		strct._recipient_address_ValidationError = fmt.Errorf("\"RecipientAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TokenTransfer) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._memo_ValidationError != nil {
		allErrors = append(allErrors, strct._memo_ValidationError)
	}
    if strct._recipient_address_ValidationError != nil {
		allErrors = append(allErrors, strct._recipient_address_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TokenTransferTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TokenTransfer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "token_transfer" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_transfer\": ")
	if tmp, err := json.Marshal(strct.TokenTransfer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TokenTransferTransactionMetadata) UnmarshalJSON(b []byte) error {
    token_transferReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "token_transfer":
            if err := json.Unmarshal([]byte(v), &strct.TokenTransfer); err != nil {
				return err
            }
            token_transferReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if token_transfer (a required property) was received
    if !token_transferReceived {
		strct._token_transfer_ValidationError = fmt.Errorf("\"TokenTransfer\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TokenTransferTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._token_transfer_ValidationError != nil {
		allErrors = append(allErrors, strct._token_transfer_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionEventAsset) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "asset_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_id\": ")
	if tmp, err := json.Marshal(strct.AssetId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionEventAsset) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
        case "asset_id":
            if err := json.Unmarshal([]byte(v), &strct.AssetId); err != nil {
				return err
            }
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TransactionEventAsset) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionFeeEstimateRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "estimated_len" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"estimated_len\": ")
	if tmp, err := json.Marshal(strct.EstimatedLen); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionPayload" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction_payload" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction_payload\": ")
	if tmp, err := json.Marshal(strct.TransactionPayload); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionFeeEstimateRequest) UnmarshalJSON(b []byte) error {
    transaction_payloadReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "estimated_len":
            if err := json.Unmarshal([]byte(v), &strct.EstimatedLen); err != nil {
				return err
            }
        case "transaction_payload":
            if err := json.Unmarshal([]byte(v), &strct.TransactionPayload); err != nil {
				return err
            }
            transaction_payloadReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if transaction_payload (a required property) was received
    if !transaction_payloadReceived {
		strct._transaction_payload_ValidationError = fmt.Errorf("\"TransactionPayload\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TransactionFeeEstimateRequest) Validate() []error {
    var allErrors []error
    if strct._transaction_payload_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_payload_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionFeeEstimateResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "cost_scalar_change_by_byte" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"cost_scalar_change_by_byte\": ")
	if tmp, err := json.Marshal(strct.CostScalarChangeByByte); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EstimatedCost" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "estimated_cost" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"estimated_cost\": ")
	if tmp, err := json.Marshal(strct.EstimatedCost); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EstimatedCostScalar" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "estimated_cost_scalar" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"estimated_cost_scalar\": ")
	if tmp, err := json.Marshal(strct.EstimatedCostScalar); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "estimations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"estimations\": ")
	if tmp, err := json.Marshal(strct.Estimations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionFeeEstimateResponse) UnmarshalJSON(b []byte) error {
    estimated_costReceived := false
    estimated_cost_scalarReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cost_scalar_change_by_byte":
            if err := json.Unmarshal([]byte(v), &strct.CostScalarChangeByByte); err != nil {
				return err
            }
        case "estimated_cost":
            if err := json.Unmarshal([]byte(v), &strct.EstimatedCost); err != nil {
				return err
            }
            estimated_costReceived = true
        case "estimated_cost_scalar":
            if err := json.Unmarshal([]byte(v), &strct.EstimatedCostScalar); err != nil {
				return err
            }
            estimated_cost_scalarReceived = true
        case "estimations":
            if err := json.Unmarshal([]byte(v), &strct.Estimations); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if estimated_cost (a required property) was received
    if !estimated_costReceived {
		strct._estimated_cost_ValidationError = fmt.Errorf("\"EstimatedCost\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if estimated_cost_scalar (a required property) was received
    if !estimated_cost_scalarReceived {
		strct._estimated_cost_scalar_ValidationError = fmt.Errorf("\"EstimatedCostScalar\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TransactionFeeEstimateResponse) Validate() []error {
    var allErrors []error
    if strct._estimated_cost_ValidationError != nil {
		allErrors = append(allErrors, strct._estimated_cost_ValidationError)
	}
    if strct._estimated_cost_scalar_ValidationError != nil {
		allErrors = append(allErrors, strct._estimated_cost_scalar_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionFound) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Found" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "found" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"found\": ")
	if tmp, err := json.Marshal(strct.Found); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionFound) UnmarshalJSON(b []byte) error {
    foundReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "found":
            if err := json.Unmarshal([]byte(v), &strct.Found); err != nil {
				return err
            }
            foundReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
				return err
            }
            resultReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if found (a required property) was received
    if !foundReceived {
		strct._found_ValidationError = fmt.Errorf("\"Found\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if result (a required property) was received
    if !resultReceived {
		strct._result_ValidationError = fmt.Errorf("\"Result\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TransactionFound) Validate() []error {
    var allErrors []error
    if strct._found_ValidationError != nil {
		allErrors = append(allErrors, strct._found_ValidationError)
	}
    if strct._result_ValidationError != nil {
		allErrors = append(allErrors, strct._result_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TxData) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_hash\": ")
	if tmp, err := json.Marshal(strct.BlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TxData) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BlockHash); err != nil {
				return err
            }
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
        case "burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTime); err != nil {
				return err
            }
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TxData) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Value) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex\": ")
	if tmp, err := json.Marshal(strct.Hex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Repr" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "repr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"repr\": ")
	if tmp, err := json.Marshal(strct.Repr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Value) UnmarshalJSON(b []byte) error {
    hexReceived := false
    reprReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex":
            if err := json.Unmarshal([]byte(v), &strct.Hex); err != nil {
				return err
            }
            hexReceived = true
        case "repr":
            if err := json.Unmarshal([]byte(v), &strct.Repr); err != nil {
				return err
            }
            reprReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex (a required property) was received
    if !hexReceived {
		strct._hex_ValidationError = fmt.Errorf("\"Hex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if repr (a required property) was received
    if !reprReceived {
		strct._repr_ValidationError = fmt.Errorf("\"Repr\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Value) Validate() []error {
    var allErrors []error
    if strct._hex_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_ValidationError)
	}
    if strct._repr_ValidationError != nil {
		allErrors = append(allErrors, strct._repr_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Version) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "middleware_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"middleware_version\": ")
	if tmp, err := json.Marshal(strct.MiddlewareVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "NodeVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "node_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"node_version\": ")
	if tmp, err := json.Marshal(strct.NodeVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RosettaVersion" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "rosetta_version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"rosetta_version\": ")
	if tmp, err := json.Marshal(strct.RosettaVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Version) UnmarshalJSON(b []byte) error {
    node_versionReceived := false
    rosetta_versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "middleware_version":
            if err := json.Unmarshal([]byte(v), &strct.MiddlewareVersion); err != nil {
				return err
            }
        case "node_version":
            if err := json.Unmarshal([]byte(v), &strct.NodeVersion); err != nil {
				return err
            }
            node_versionReceived = true
        case "rosetta_version":
            if err := json.Unmarshal([]byte(v), &strct.RosettaVersion); err != nil {
				return err
            }
            rosetta_versionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if node_version (a required property) was received
    if !node_versionReceived {
		strct._node_version_ValidationError = fmt.Errorf("\"NodeVersion\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if rosetta_version (a required property) was received
    if !rosetta_versionReceived {
		strct._rosetta_version_ValidationError = fmt.Errorf("\"RosettaVersion\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Version) Validate() []error {
    var allErrors []error
    if strct._node_version_ValidationError != nil {
		allErrors = append(allErrors, strct._node_version_ValidationError)
	}
    if strct._rosetta_version_ValidationError != nil {
		allErrors = append(allErrors, strct._rosetta_version_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}
