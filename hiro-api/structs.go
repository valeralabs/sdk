// Code generated by schema-generate. DO NOT EDIT.
// Source paths:  entities/address/address-nonces.schema.json:entities/address/token-offering-locked.schema.json:entities/address/transaction-with-transfers.schema.json:entities/address/unlock-schedule.schema.json:entities/balance/ft-balance.schema.json:entities/balance/nft-balance.schema.json:entities/balance/stx-balance.schema.json:entities/blocks/block.schema.json:entities/burnchain/reward-slot-holder.schema.json:entities/burnchain/reward.schema.json:entities/burnchain/rewards-total.schema.json:entities/contracts/read-only-function-args.schema.json:entities/contracts/smart-contract.schema.json:entities/info/block-time.schema.json:entities/info/chain-tip.schema.json:entities/mempool-transactions/abstract-transaction.schema.json:entities/mempool-transactions/transaction-0-token-transfer.schema.json:entities/mempool-transactions/transaction-1-smart-contract.schema.json:entities/mempool-transactions/transaction-2-contract-call.schema.json:entities/mempool-transactions/transaction-3-poison-microblock.schema.json:entities/mempool-transactions/transaction-4-coinbase.schema.json:entities/mempool-transactions/transaction-status.schema.json:entities/mempool-transactions/transaction.schema.json:entities/microblocks/microblock.schema.json:entities/nft-events/nft-event.schema.json:entities/post-conditions/post-condition-0-stx.schema.json:entities/post-conditions/post-condition-1-fungible.schema.json:entities/post-conditions/post-condition-2-non-fungible.schema.json:entities/post-conditions/post-condition-fungible-condition-code.schema.json:entities/post-conditions/post-condition-mode.schema.json:entities/post-conditions/post-condition-non-fungible-condition-code.schema.json:entities/post-conditions/post-condition-principal-type.schema.json:entities/post-conditions/post-condition-principal.schema.json:entities/post-conditions/post-condition-type.schema.json:entities/post-conditions/post-condition.schema.json:entities/rosetta/rosetta-account-identifier.schema.json:entities/rosetta/rosetta-account.schema.json:entities/rosetta/rosetta-amount-max-fee.schema.json:entities/rosetta/rosetta-amount.schema.json:entities/rosetta/rosetta-block-identifier-hash.schema.json:entities/rosetta/rosetta-block-identifier-height.schema.json:entities/rosetta/rosetta-block-identifier.schema.json:entities/rosetta/rosetta-block.schema.json:entities/rosetta/rosetta-coin-change.schema.json:entities/rosetta/rosetta-coin.schema.json:entities/rosetta/rosetta-construction-options.schema.json:entities/rosetta/rosetta-currency.schema.json:entities/rosetta/rosetta-error-no-details.schema.json:entities/rosetta/rosetta-error.schema.json:entities/rosetta/rosetta-genesis-block-identifier.schema.json:entities/rosetta/rosetta-network-identifier.schema.json:entities/rosetta/rosetta-network-peers.schema.json:entities/rosetta/rosetta-oldest-block-identifier.schema.json:entities/rosetta/rosetta-operation-identifier.schema.json:entities/rosetta/rosetta-operation-statuses.schema.json:entities/rosetta/rosetta-operation.schema.json:entities/rosetta/rosetta-other-transaction-identifier.schema.json:entities/rosetta/rosetta-parent-block-identifier.schema.json:entities/rosetta/rosetta-partial-block-identifier.schema.json:entities/rosetta/rosetta-public-key.schema.json:entities/rosetta/rosetta-related-operation.schema.json:entities/rosetta/rosetta-signature-type.schema.json:entities/rosetta/rosetta-signature.schema.json:entities/rosetta/rosetta-signing-payload.schema.json:entities/rosetta/rosetta-sub-account.schema.json:entities/rosetta/rosetta-sync-status.schema.json:entities/rosetta/rosetta-transaction-identifier.schema.json:entities/rosetta/rosetta-transaction.schema.json:entities/tokens/fungible-token.schema.json:entities/tokens/non-fungible-token-history-event-0-tx-id.example.schema.json:entities/tokens/non-fungible-token-history-event-0-tx-id.schema.json:entities/tokens/non-fungible-token-history-event-1-tx-metadata.example.schema.json:entities/tokens/non-fungible-token-history-event-1-tx-metadata.schema.json:entities/tokens/non-fungible-token-history-event.schema.json:entities/tokens/non-fungible-token-holding-0-tx-id.example.schema.json:entities/tokens/non-fungible-token-holding-0-tx-id.schema.json:entities/tokens/non-fungible-token-holding-1-tx-metadata.example.schema.json:entities/tokens/non-fungible-token-holding-1-tx-metadata.schema.json:entities/tokens/non-fungible-token-holding.schema.json:entities/tokens/non-fungible-token-mint-0-tx-id.example.schema.json:entities/tokens/non-fungible-token-mint-0-tx-id.schema.json:entities/tokens/non-fungible-token-mint-1-tx-metadata.example.schema.json:entities/tokens/non-fungible-token-mint-1-tx-metadata.schema.json:entities/tokens/non-fungible-token-mint.schema.json:entities/tokens/non-fungible-token.schema.json:entities/transaction-events/abstract-transaction-event.schema.json:entities/transaction-events/asset-types/transaction-event-asset-type.schema.json:entities/transaction-events/asset-types/transaction-event-asset.schema.json:entities/transaction-events/transaction-event-fungible-asset.schema.json:entities/transaction-events/transaction-event-non-fungible-asset.schema.json:entities/transaction-events/transaction-event-smart-contract-log.schema.json:entities/transaction-events/transaction-event-stx-asset.schema.json:entities/transaction-events/transaction-event-stx-lock.schema.json:entities/transaction-events/transaction-event-type.schema.json:entities/transaction-events/transaction-event.schema.json:entities/transactions/abstract-transaction.schema.json:entities/transactions/anchor-mode.schema.json:entities/transactions/base-transaction.schema.json:entities/transactions/transaction-0-token-transfer-metadata.schema.json:entities/transactions/transaction-0-token-transfer.schema.json:entities/transactions/transaction-1-smart-contract-metadata.schema.json:entities/transactions/transaction-1-smart-contract.schema.json:entities/transactions/transaction-2-contract-call-metadata.schema.json:entities/transactions/transaction-2-contract-call.schema.json:entities/transactions/transaction-3-poison-microblock-metadata.schema.json:entities/transactions/transaction-3-poison-microblock.schema.json:entities/transactions/transaction-4-coinbase-metadata.schema.json:entities/transactions/transaction-4-coinbase.schema.json:entities/transactions/transaction-found.schema.json:entities/transactions/transaction-list.schema.json:entities/transactions/transaction-metadata.schema.json:entities/transactions/transaction-not-found.schema.json:entities/transactions/transaction-status.schema.json:entities/transactions/transaction-type.schema.json:entities/transactions/transaction.schema.json:entities/transfers/inbound-stx-transfer.schema.json:entities/ws-rpc/rpc-address-balance-notification-params.schema.json:entities/ws-rpc/rpc-address-balance-notification-response.schema.json:entities/ws-rpc/rpc-address-balance-subscription-params.schema.json:entities/ws-rpc/rpc-address-balance-subscription-request.schema.json:entities/ws-rpc/rpc-address-tx-notification-params.schema.json:entities/ws-rpc/rpc-address-tx-notification-response.schema.json:entities/ws-rpc/rpc-address-tx-subscription-params.schema.json:entities/ws-rpc/rpc-address-tx-subscription-request.schema.json:entities/ws-rpc/rpc-block-notification-response.schema.json:entities/ws-rpc/rpc-block-subscription-params.schema.json:entities/ws-rpc/rpc-block-subscription-request.schema.json:entities/ws-rpc/rpc-mempool-notification-response.schema.json:entities/ws-rpc/rpc-mempool-subscription-params.schema.json:entities/ws-rpc/rpc-mempool-subscription-request.schema.json:entities/ws-rpc/rpc-microblock-notification-response.schema.json:entities/ws-rpc/rpc-microblock-subscription-params.schema.json:entities/ws-rpc/rpc-microblock-subscription-request.schema.json:entities/ws-rpc/rpc-subscription-type.schema.json:entities/ws-rpc/rpc-tx-update-notification-params.schema.json:entities/ws-rpc/rpc-tx-update-notification-response.schema.json:entities/ws-rpc/rpc-tx-update-subscription-params.schema.json:entities/ws-rpc/rpc-tx-update-subscription-request.schema.json

package main

import (
    "bytes"
    "encoding/json"
    "errors"
    "fmt"
)

var ErrFieldRequired = errors.New("field required validation failed")

// AbstractMempoolTransaction
type AbstractMempoolTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// AbstractTransaction
type AbstractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// AbstractTransactionEvent
type AbstractTransactionEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// AddressUnlockSchedule
type AddressUnlockSchedule *AddressUnlockSchedule_InboundStxTransfer

// Block
type Block *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// BurnchainReward
type BurnchainReward *BurnchainReward_BurnchainRewardsTotal

// BurnchainRewardsTotal
type BurnchainRewardsTotal *BurnchainReward_BurnchainRewardsTotal

// CoinbaseTransaction
type CoinbaseTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// ContractCallTransaction
type ContractCallTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// FtBalance
type FtBalance *FtBalance_StxBalance

// FungibleTokenMetadata
type FungibleTokenMetadata *FungibleTokenMetadata_NonFungibleTokenMetadata

// InboundStxTransfer
type InboundStxTransfer *AddressUnlockSchedule_InboundStxTransfer

// MempoolCoinbaseTransaction
type MempoolCoinbaseTransaction *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails

// MempoolContractCallTransaction
type MempoolContractCallTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// MempoolPoisonMicroblockTransaction
type MempoolPoisonMicroblockTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// MempoolSmartContractTransaction
type MempoolSmartContractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// MempoolTokenTransferTransaction
type MempoolTokenTransferTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// MempoolTransaction
type MempoolTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// MempoolTransactionStatus
type MempoolTransactionStatus string

// NftEvent
type NftEvent *NftEvent_NonFungibleTokenHoldingWithTxId

// NonFungibleTokenHistoryEvent
type NonFungibleTokenHistoryEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// NonFungibleTokenHolding
type NonFungibleTokenHolding *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// NonFungibleTokenHoldingWithTxId
type NonFungibleTokenHoldingWithTxId *NftEvent_NonFungibleTokenHoldingWithTxId

// NonFungibleTokenMetadata
type NonFungibleTokenMetadata *FungibleTokenMetadata_NonFungibleTokenMetadata

// NonFungibleTokenMint
type NonFungibleTokenMint *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// NonFungibleTokenMintWithTxId
type NonFungibleTokenMintWithTxId *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// OtherTransactionIdentifier
type OtherTransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// PoisonMicroblockTransaction
type PoisonMicroblockTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// PostCondition
type PostCondition interface{}

// PostConditionFungible
type PostConditionFungible *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// PostConditionFungibleConditionCode
type PostConditionFungibleConditionCode string

// PostConditionMode
type PostConditionMode string

// PostConditionNonFungible
type PostConditionNonFungible *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// PostConditionNonFungibleConditionCode
type PostConditionNonFungibleConditionCode string

// PostConditionPrincipal
type PostConditionPrincipal *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// PostConditionPrincipalType
type PostConditionPrincipalType string

// PostConditionStx
type PostConditionStx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// PostConditionType
type PostConditionType string

// Root
type Root interface{}

// RosettaAccount
type RosettaAccount *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount

// RosettaAccountIdentifier
type RosettaAccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount

// RosettaAmount
type RosettaAmount *RosettaAmount_RosettaMaxFeeAmount

// RosettaBlockIdentifier
type RosettaBlockIdentifier interface{}

// RosettaBlockIdentifierHash
type RosettaBlockIdentifierHash *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// RosettaBlockIdentifierHeight
type RosettaBlockIdentifierHeight *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaError
type RosettaError *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails

// RosettaErrorNoDetails
type RosettaErrorNoDetails *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails

// RosettaGenesisBlockIdentifier
type RosettaGenesisBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaMaxFeeAmount
type RosettaMaxFeeAmount *RosettaAmount_RosettaMaxFeeAmount

// RosettaOldestBlockIdentifier
type RosettaOldestBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaOperationIdentifier
type RosettaOperationIdentifier *RosettaOperationIdentifier_RosettaRelatedOperation

// RosettaParentBlockIdentifier
type RosettaParentBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier

// RosettaPartialBlockIdentifier
type RosettaPartialBlockIdentifier *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// RosettaRelatedOperation
type RosettaRelatedOperation *RosettaOperationIdentifier_RosettaRelatedOperation

// RosettaSubAccount
type RosettaSubAccount *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount

// RpcAddressBalanceSubscriptionParams
type RpcAddressBalanceSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams

// RpcAddressTxNotificationParams
type RpcAddressTxNotificationParams *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams

// RpcAddressTxSubscriptionParams
type RpcAddressTxSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams

// RpcBlockSubscriptionParams
type RpcBlockSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams

// RpcMempoolSubscriptionParams
type RpcMempoolSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams

// RpcMicroblockSubscriptionParams
type RpcMicroblockSubscriptionParams *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams

// RpcSubscriptionType
type RpcSubscriptionType string

// RpcTxUpdateNotificationParams
type RpcTxUpdateNotificationParams *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams

// SignatureType
type SignatureType string

// SmartContractTransaction
type SmartContractTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// StxBalance
type StxBalance *FtBalance_StxBalance

// TokenTransferTransaction
type TokenTransferTransaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// Transaction
type Transaction *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionAnchorModeType
type TransactionAnchorModeType string

// TransactionEvent
type TransactionEvent *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventAssetType
type TransactionEventAssetType string

// TransactionEventFungibleAsset
type TransactionEventFungibleAsset *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventNonFungibleAsset
type TransactionEventNonFungibleAsset *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventSmartContractLog
type TransactionEventSmartContractLog *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventStxAsset
type TransactionEventStxAsset *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventStxLock
type TransactionEventStxLock *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionEventType
type TransactionEventType string

// TransactionIdentifier
type TransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier

// TransactionList
type TransactionList map[string]interface{}

// TransactionMetadata
type TransactionMetadata *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata

// TransactionStatus
type TransactionStatus string

// TransactionType
type TransactionType string

// AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata 
// Aliased for: AbstractMempoolTransaction, AbstractTransaction, AbstractTransactionEvent, CoinbaseTransaction, ContractCallTransaction, MempoolContractCallTransaction, MempoolPoisonMicroblockTransaction, MempoolSmartContractTransaction, MempoolTokenTransferTransaction, MempoolTransaction, NonFungibleTokenHistoryEvent, NonFungibleTokenHolding, NonFungibleTokenMint, NonFungibleTokenMintWithTxId, PoisonMicroblockTransaction, PostConditionFungible, PostConditionNonFungible, PostConditionPrincipal, PostConditionStx, RosettaPartialBlockIdentifier, SmartContractTransaction, TokenTransferTransaction, Transaction, TransactionEvent, TransactionEventFungibleAsset, TransactionEventNonFungibleAsset, TransactionEventSmartContractLog, TransactionEventStxAsset, TransactionEventStxLock, TransactionMetadata
type AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata struct {
  EventIndex int `json:"event_index"` // s:1771ed1c34, f:f8f1e5891408ed2bcde1
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:c1239e0ce0, f:e41fdf8ceb9c7e100fce
  TxId string `json:"tx_id"` // s:0b631951be, f:19c844d71a2e65bd43bd
  _tx_id_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:6800aefee0, f:e5c0263436a406b6442c
  _value_ValidationError error

}

// AddressNonces The latest nonce values used by an account by inspecting the mempool, microblock transactions, and anchored transactions
type AddressNonces struct {

  // Nonces that appear to be missing and likely causing a mempool transaction to be stuck.
  DetectedMissingNonces []int `json:"detected_missing_nonces"` // s:aa17117574, f:6df40b6a0990df7cf1ea
  _detected_missing_nonces_ValidationError error


  // The latest nonce found within transactions sent by this address, including unanchored microblock transactions. Will be null if there are no current transactions for this address.
  LastExecutedTxNonce int `json:"last_executed_tx_nonce"` // s:baea4417d2, f:a221f007cffec34d3c82
  _last_executed_tx_nonce_ValidationError error


  // The latest nonce found within mempool transactions sent by this address. Will be null if there are no current mempool transactions for this address.
  LastMempoolTxNonce int `json:"last_mempool_tx_nonce"` // s:eae914b2ef, f:df6300c6aeade51e0115
  _last_mempool_tx_nonce_ValidationError error


  // The likely nonce required for creating the next transaction, based on the last nonces seen by the API. This can be incorrect if the API's mempool or transactions aren't fully synchronized, even by a small amount, or if a previous transaction is still propagating through the Stacks blockchain network when this endpoint is called.
  PossibleNextNonce int `json:"possible_next_nonce"` // s:ba9269fb84, f:5b3647b2ab3aa6d4dc1b
  _possible_next_nonce_ValidationError error

}

// AddressTokenOfferingLocked Token Offering Locked
type AddressTokenOfferingLocked struct {

  // Micro-STX amount still locked at current block height.
  TotalLocked string `json:"total_locked"` // s:d6b1f61b5d, f:6e60dd372524833d1db5
  _total_locked_ValidationError error


  // Micro-STX amount unlocked at current block height.
  TotalUnlocked string `json:"total_unlocked"` // s:d3fdd047df, f:e23b2cb88e9f53d6d3de
  _total_unlocked_ValidationError error

  UnlockSchedule []*AddressUnlockSchedule `json:"unlock_schedule"` // s:3a0bdaa18b, f:98bcecf72dd0318b7c8a
  _unlock_schedule_ValidationError error

}

// AddressTransactionWithTransfers Transaction with STX transfers for a given address
type AddressTransactionWithTransfers struct {
  FtTransfers []*FtTransfersItems `json:"ft_transfers,omitempty"` // s:9a5ab2fe38, f:7b5e60f9baaed301d5b8
  NftTransfers []*NftTransfersItems `json:"nft_transfers,omitempty"` // s:9cb1dee3e3, f:9561b1c3b88c49c2a41e

  // Total received by the given address in micro-STX as an integer string.
  StxReceived string `json:"stx_received"` // s:695bfe0605, f:1a568aa4d88d495b20dc
  _stx_received_ValidationError error


  // Total sent from the given address, including the tx fee, in micro-STX as an integer string.
  StxSent string `json:"stx_sent"` // s:ee977a580b, f:92b731a92e9b68e5124c
  _stx_sent_ValidationError error

  StxTransfers []*StxTransfersItems `json:"stx_transfers"` // s:d323b82ebe, f:13cc757287c40f0925d2
  _stx_transfers_ValidationError error

  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata `json:"tx"` // s:d15bf52174, f:9bfe48130155983ca89f
  _tx_ValidationError error

}

// AddressUnlockSchedule_InboundStxTransfer 
// Aliased for: AddressUnlockSchedule, InboundStxTransfer
type AddressUnlockSchedule_InboundStxTransfer struct {

  // Micro-STX amount locked at this block height.
  // Transfer amount in micro-STX as integer string
  Amount string `json:"amount"` // s:63eb5cdaca, f:6ee38e478ac1ceeb573f
  _amount_ValidationError error


  // Block height at which this transfer occurred
  // 
  BlockHeight float64 `json:"block_height"` // s:9fff17291a, f:157eaf5fc12551b29b40
  _block_height_ValidationError error


  // Hex encoded memo bytes associated with the transfer
  Memo string `json:"memo"` // s:cd06b4c872, f:01ac85a60c0a3045a822
  _memo_ValidationError error


  // Principal that sent this transfer
  Sender string `json:"sender"` // s:3ecb6da072, f:294a5bba2ac87f3670e4
  _sender_ValidationError error


  // Indicates if the transfer is from a stx-transfer transaction or a contract-call transaction
  TransferType string `json:"transfer_type"` // s:361e469cb4, f:5595cba1ab3cc03b47cf
  _transfer_type_ValidationError error


  // The transaction ID in which this transfer occurred
  TxId string `json:"tx_id"` // s:aee380d1cb, f:a9a6e43704139537672f
  _tx_id_ValidationError error


  // Index of the transaction within a block
  TxIndex float64 `json:"tx_index"` // s:b4276cdbad, f:2c8444499d54d4c51265
  _tx_index_ValidationError error

}

// BaseTransaction Transaction properties that are available from a raw serialized transactions. These are available for transactions in the mempool as well as mined transactions.
type BaseTransaction struct {
  AnchorMode string `json:"anchor_mode"` // s:cc54289dcb, f:74360856553677693ff5
  _anchor_mode_ValidationError error


  // Transaction fee as Integer string (64-bit unsigned integer).
  FeeRate string `json:"fee_rate"` // s:b078dca268, f:b8179b4459fb1493785d
  _fee_rate_ValidationError error


  // Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
  Nonce int `json:"nonce"` // s:403f5c67e6, f:6705f42538268fa4196b
  _nonce_ValidationError error

  PostConditionMode string `json:"post_condition_mode"` // s:ac569ecc31, f:524ba0ea33efadddc0d0
  _post_condition_mode_ValidationError error

  PostConditions []interface{} `json:"post_conditions"` // s:8617b58e48, f:5932089dae33460bc7b6
  _post_conditions_ValidationError error


  // Address of the transaction initiator
  SenderAddress string `json:"sender_address"` // s:f2b4c2b1e6, f:c7d4ff614863ae8ff47e
  _sender_address_ValidationError error

  SponsorAddress string `json:"sponsor_address,omitempty"` // s:5035458981, f:d0023833789bedbe11d7
  SponsorNonce int `json:"sponsor_nonce,omitempty"` // s:293b8f8d9d, f:6058549de6be774b626e

  // Denotes whether the originating account is the same as the paying account
  Sponsored bool `json:"sponsored"` // s:f385f44311, f:63ff4ab0f1b89bf70567
  _sponsored_ValidationError error


  // Transaction ID
  TxId string `json:"tx_id"` // s:45bd458d0d, f:9d6c03476ec6d9de2fd9
  _tx_id_ValidationError error

}

// Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier 
// Aliased for: Block, OtherTransactionIdentifier, RosettaBlockIdentifierHash, TransactionIdentifier
type Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier struct {

  // Hash of the anchor chain block
  BurnBlockHash string `json:"burn_block_hash"` // s:0237447715, f:71e116a0ef1717259bc5
  _burn_block_hash_ValidationError error


  // Height of the anchor chain block
  BurnBlockHeight int `json:"burn_block_height"` // s:3f24a785ec, f:634b840a18fc2600ba5f
  _burn_block_height_ValidationError error


  // Unix timestamp (in seconds) indicating when this block was mined.
  BurnBlockTime float64 `json:"burn_block_time"` // s:37ac9985af, f:aa33fd3fcbf330983767
  _burn_block_time_ValidationError error


  // An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
  BurnBlockTimeIso string `json:"burn_block_time_iso"` // s:133cae455e, f:e70faaa5b93db2ad1b25
  _burn_block_time_iso_ValidationError error


  // Set to `true` if block corresponds to the canonical chain tip
  Canonical bool `json:"canonical"` // s:89548f803a, f:3e047dcbd4edf1bfc50a
  _canonical_ValidationError error


  // Execution cost read count.
  ExecutionCostReadCount int `json:"execution_cost_read_count"` // s:6e0e75fa94, f:28203a43a39a0cd13ac4
  _execution_cost_read_count_ValidationError error


  // Execution cost read length.
  ExecutionCostReadLength int `json:"execution_cost_read_length"` // s:c8c1d361b2, f:84147e9874ea251b3651
  _execution_cost_read_length_ValidationError error


  // Execution cost runtime.
  ExecutionCostRuntime int `json:"execution_cost_runtime"` // s:e2aa78b723, f:e60e325247f03d9c57d5
  _execution_cost_runtime_ValidationError error


  // Execution cost write count.
  ExecutionCostWriteCount int `json:"execution_cost_write_count"` // s:25ab69b14d, f:c27f67ffd3aaf08e89a5
  _execution_cost_write_count_ValidationError error


  // Execution cost write length.
  ExecutionCostWriteLength int `json:"execution_cost_write_length"` // s:9e209b1d77, f:707db3a1b84d91383bde
  _execution_cost_write_length_ValidationError error


  // This is also known as the block hash.
  // Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
  // Hash representing the block
  Hash string `json:"hash"` // s:2341319181, f:cc7317a3199fffd085ab
  _hash_ValidationError error


  // Height of the block
  Height int `json:"height"` // s:a240deb99e, f:85d76de5e2c291c2c534
  _height_ValidationError error


  // List of microblocks that were accepted in this anchor block. Not every anchored block will have a accepted all (or any) of the previously streamed microblocks. Microblocks that were orphaned are not included in this list.
  MicroblocksAccepted []string `json:"microblocks_accepted"` // s:9fa3f9b81b, f:93b41705d9dbc8d0a70a
  _microblocks_accepted_ValidationError error


  // List of microblocks that were streamed/produced by this anchor block's miner. This list only includes microblocks that were accepted in the following anchor block. Microblocks that were orphaned are not included in this list.
  MicroblocksStreamed []string `json:"microblocks_streamed"` // s:e912ed7d50, f:ea4ced9610386784a507
  _microblocks_streamed_ValidationError error


  // Anchor chain transaction ID
  MinerTxid string `json:"miner_txid"` // s:ac4fcb81d4, f:9650974d52b9bde82795
  _miner_txid_ValidationError error


  // Hash of the parent block
  ParentBlockHash string `json:"parent_block_hash"` // s:e554fe52fe, f:86fda1cb96a9527933b7
  _parent_block_hash_ValidationError error


  // The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
  ParentMicroblockHash string `json:"parent_microblock_hash"` // s:0fd5c8d856, f:68ddd2c13ef4e8f7e33b
  _parent_microblock_hash_ValidationError error


  // The hash of the last streamed block that precedes this block to which this block is to be appended. Not every anchored block will have a parent microblock stream. An anchored block that does not have a parent microblock stream has the parent microblock hash set to an empty string, and the parent microblock sequence number set to -1.
  ParentMicroblockSequence int `json:"parent_microblock_sequence"` // s:24dad46572, f:a9d7aeec5642f6b41d34
  _parent_microblock_sequence_ValidationError error


  // List of transactions included in the block
  Txs []string `json:"txs"` // s:4e23689644, f:6fd4548909e68c5ac346
  _txs_ValidationError error

}

// BurnchainRewardSlotHolder Reward slot holder on the burnchain
type BurnchainRewardSlotHolder struct {

  // The recipient address that validly received PoX commitments, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
  Address string `json:"address"` // s:f27abc73fa, f:fd5a1d82818dda52311e
  _address_ValidationError error


  // The hash representing the burnchain block
  BurnBlockHash string `json:"burn_block_hash"` // s:35efaa7633, f:013ae19f213d80d39e70
  _burn_block_hash_ValidationError error


  // Height of the burnchain block
  BurnBlockHeight int `json:"burn_block_height"` // s:7dd79ee8ee, f:f4b7b7a6fdec3ceafd4b
  _burn_block_height_ValidationError error


  // Set to `true` if block corresponds to the canonical burchchain tip
  Canonical bool `json:"canonical"` // s:3a3dafcb00, f:63fe71f913ce2aa3a79e
  _canonical_ValidationError error


  // The index position of the reward entry, useful for ordering when there's more than one slot per burnchain block
  SlotIndex int `json:"slot_index"` // s:e0ecf0e0ad, f:06f1e8b5b10cdb46821b
  _slot_index_ValidationError error

}

// BurnchainReward_BurnchainRewardsTotal 
// Aliased for: BurnchainReward, BurnchainRewardsTotal
type BurnchainReward_BurnchainRewardsTotal struct {

  // The total amount of burnchain tokens burned for this burnchain block, in the smallest unit (e.g. satoshis for Bitcoin)
  BurnAmount string `json:"burn_amount"` // s:bc64530786, f:480610b59e318b5ca60f
  _burn_amount_ValidationError error


  // The hash representing the burnchain block
  BurnBlockHash string `json:"burn_block_hash"` // s:7b0c8e31be, f:75f0773e1b0f1dbf54ad
  _burn_block_hash_ValidationError error


  // Height of the burnchain block
  BurnBlockHeight int `json:"burn_block_height"` // s:029820c9ef, f:c9311994eedb807072ad
  _burn_block_height_ValidationError error


  // Set to `true` if block corresponds to the canonical burchchain tip
  Canonical bool `json:"canonical"` // s:e31d75ef9b, f:006756493ec5b7d482ff
  _canonical_ValidationError error


  // The amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
  // The total amount of burnchain tokens rewarded to the recipient, in the smallest unit (e.g. satoshis for Bitcoin)
  RewardAmount string `json:"reward_amount"` // s:2546f91d9a, f:298657f42dfb8c6fe48d
  _reward_amount_ValidationError error


  // The index position of the reward entry, useful for ordering when there's more than one recipient per burnchain block
  RewardIndex int `json:"reward_index"` // s:5d55d65a8c, f:bdd739eec381934995bf
  _reward_index_ValidationError error


  // The recipient address that received the burnchain rewards, in the format native to the burnchain (e.g. B58 encoded for Bitcoin)
  RewardRecipient string `json:"reward_recipient"` // s:11133f5f38, f:d299ae364a3827b5037d
  _reward_recipient_ValidationError error

}

// ChainTip Current chain tip information
type ChainTip struct {

  // the current block hash
  BlockHash string `json:"block_hash"` // s:57e49b89fb, f:74f1dce29c13fb1edcc2
  _block_hash_ValidationError error


  // the current block height
  BlockHeight int `json:"block_height"` // s:784ba302f1, f:a19d7b98b1be7cdd3f98
  _block_height_ValidationError error


  // the current index block hash
  IndexBlockHash string `json:"index_block_hash"` // s:8f6b5c2599, f:26e803e5da9c5710cce6
  _index_block_hash_ValidationError error


  // the current microblock hash
  MicroblockHash string `json:"microblock_hash,omitempty"` // s:55d3647943, f:183266b548228c02c45f

  // the current microblock sequence number
  MicroblockSequence int `json:"microblock_sequence,omitempty"` // s:d25875cefb, f:fce4efa3ce2def5ab886
}

// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
type CoinIdentifier struct {

  // Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
  Identifier string `json:"identifier"` // s:2b873472e4, f:08a269d77b899c256d33
  _identifier_ValidationError error

}

// CoinbasePayload 
type CoinbasePayload struct {

  // Hex encoded 32-byte scratch space for block leader's use
  Data string `json:"data"` // s:c1bba8d1c8, f:c53ae084eb3d6714178e
  _data_ValidationError error

}

// CoinbaseTransactionMetadata Describes representation of a Type 3 Stacks 2.0 transaction: Poison Microblock
type CoinbaseTransactionMetadata struct {
  CoinbasePayload *CoinbasePayload `json:"coinbase_payload"` // s:f42b2b8187, f:b844f22f945e425f6248
  _coinbase_payload_ValidationError error

  TxType string `json:"tx_type"` // s:53661d95ee, f:cb39771f6c0c7782ce7b
  _tx_type_ValidationError error

}

// ContractCall 
type ContractCall struct {

  // Contract identifier formatted as `<principaladdress>.<contract_name>`
  ContractId string `json:"contract_id"` // s:c543d7f44b, f:5b82c7d1e017ea62e1fb
  _contract_id_ValidationError error


  // List of arguments used to invoke the function
  FunctionArgs []*FunctionArgsItems `json:"function_args,omitempty"` // s:bcf7d17e5c, f:606c24e6201914575f36

  // Name of the Clarity function to be invoked
  FunctionName string `json:"function_name"` // s:a228cb9f8e, f:5c17bb8681e6f7d746f2
  _function_name_ValidationError error


  // Function definition, including function name and type as well as parameter names and types
  FunctionSignature string `json:"function_signature"` // s:8ab5fbb327, f:176664568812e929908f
  _function_signature_ValidationError error

}

// ContractCallTransactionMetadata Metadata associated with a contract-call type transaction
type ContractCallTransactionMetadata struct {
  ContractCall *ContractCall `json:"contract_call"` // s:3155fd4b6c, f:172bb461917c0a9d0297
  _contract_call_ValidationError error

  TxType string `json:"tx_type"` // s:845c2dc7bd, f:bfe11f037fe0c8f48e71
  _tx_type_ValidationError error

}

// Details Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
type Details struct {
  Address string `json:"address,omitempty"` // s:0182ec1a9d, f:a5c8912d049070a89a9f
  Error string `json:"error,omitempty"` // s:03a7262f81, f:eaaa76cc72018e293d02
}

// FtBalance_StxBalance 
// Aliased for: FtBalance, StxBalance
type FtBalance_StxBalance struct {
  Balance string `json:"balance"` // s:4b7b0ad543, f:584f99b04a40e0c7e6df
  _balance_ValidationError error


  // The burnchain block height of when the lock event occurred. Zero if no tokens are locked.
  BurnchainLockHeight int `json:"burnchain_lock_height"` // s:c02909f752, f:99f6caaef195a92ba52e
  _burnchain_lock_height_ValidationError error


  // The burnchain block height of when the tokens unlock. Zero if no tokens are locked.
  BurnchainUnlockHeight int `json:"burnchain_unlock_height"` // s:0235418bb1, f:00a36e58e14d62a3ad28
  _burnchain_unlock_height_ValidationError error


  // The STX chain block height of when the lock event occurred. Zero if no tokens are locked.
  LockHeight int `json:"lock_height"` // s:e16764f686, f:aceaa21e456d83c3af83
  _lock_height_ValidationError error


  // The transaction where the lock event occurred. Empty if no tokens are locked.
  LockTxId string `json:"lock_tx_id"` // s:b0e0020f15, f:d041dd276ee4f2ae1329
  _lock_tx_id_ValidationError error


  // The amount of locked STX, as string quoted micro-STX. Zero if no tokens are locked.
  Locked string `json:"locked"` // s:a8fb19c4d4, f:705c95ac46e89b84f211
  _locked_ValidationError error

  TotalFeesSent string `json:"total_fees_sent"` // s:bcfa0d8faa, f:2bd1870bbe96f13067db
  _total_fees_sent_ValidationError error

  TotalMinerRewardsReceived string `json:"total_miner_rewards_received"` // s:da36a67529, f:91898e1050d5b60f7aca
  _total_miner_rewards_received_ValidationError error

  TotalReceived string `json:"total_received"` // s:80da7e54c6, f:f7a4135b80e83c0ccd2c
  _total_received_ValidationError error

  TotalSent string `json:"total_sent"` // s:f2fe7c424f, f:31ee67f86bd12dbebe23
  _total_sent_ValidationError error

}

// FtTransfersItems 
type FtTransfersItems struct {

  // Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
  Amount string `json:"amount"` // s:93b3f8b8d0, f:38f6162c23fa9b89ea94
  _amount_ValidationError error


  // Fungible Token asset identifier.
  AssetIdentifier string `json:"asset_identifier"` // s:3c43d86ef8, f:422d2619d329226a4c0b
  _asset_identifier_ValidationError error


  // Principal that received the asset.
  Recipient string `json:"recipient,omitempty"` // s:d09e884620, f:cc62c9576f2fc69053a5

  // Principal that sent the asset.
  Sender string `json:"sender,omitempty"` // s:6dbe6eec7d, f:6cbc0e844cc058b3253a
}

// FunctionArgsItems 
type FunctionArgsItems struct {
  Hex string `json:"hex"` // s:b3ec276f34, f:41c3744951512830999e
  _hex_ValidationError error

  Name string `json:"name"` // s:8b43cb2c6d, f:83faf39d3d1cac4c4a03
  _name_ValidationError error

  Repr string `json:"repr"` // s:c0c1f4954f, f:78597bc978059c0ee01a
  _repr_ValidationError error

  Type string `json:"type"` // s:7ca6499522, f:cc7bd5dbf23b16ae4c02
  _type_ValidationError error

}

// FungibleTokenMetadata_NonFungibleTokenMetadata 
// Aliased for: FungibleTokenMetadata, NonFungibleTokenMetadata
type FungibleTokenMetadata_NonFungibleTokenMetadata struct {

  // The number of decimal places in a token.
  Decimals float64 `json:"decimals"` // s:5bcaa7b2ce, f:895b0c9c9cd654d0d69b
  _decimals_ValidationError error


  // Describes the asset to which this token represents
  Description string `json:"description"` // s:971f555cf3, f:5f26c007c3dd209d1b62
  _description_ValidationError error


  // The original image URI specified by the contract. A URI pointing to a resource with mime type image/* representing the asset to which this token represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.
  ImageCanonicalUri string `json:"image_canonical_uri"` // s:a9747454fa, f:4ec8ebf1a4ec25e2ecb7
  _image_canonical_uri_ValidationError error


  // A URI pointing to a resource with mime type image/* representing the asset to which this token represents. The API may provide a URI to a cached resource, dependending on configuration. Otherwise, this can be the same value as the canonical image URI.
  ImageUri string `json:"image_uri"` // s:6e8afb4729, f:872df19353c7dc8be475
  _image_uri_ValidationError error


  // Identifies the asset to which this token represents
  Name string `json:"name"` // s:f450f5d87d, f:698d959d06dfec8709da
  _name_ValidationError error


  // principle that deployed the contract
  SenderAddress string `json:"sender_address"` // s:57ece7a9b5, f:3abd704182ee02976c97
  _sender_address_ValidationError error


  // A shorter representation of a token. This is sometimes referred to as a "ticker". Examples: "STX", "COOL", etc. Typically, a token could be referred to as $SYMBOL when referencing it in writing.
  Symbol string `json:"symbol"` // s:517571c27e, f:a0651a8ac1fe7a572e5c
  _symbol_ValidationError error


  // An optional string that is a valid URI which resolves to this token's metadata. Can be empty.
  TokenUri string `json:"token_uri"` // s:6b8b0baed6, f:7c9f4bcb1fff97c2bc4f
  _token_uri_ValidationError error


  // Tx id that deployed the contract
  TxId string `json:"tx_id"` // s:8ab7d8bc72, f:5128553e4938b509a5f6
  _tx_id_ValidationError error

}

// MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails 
// Aliased for: MempoolCoinbaseTransaction, RosettaError, RosettaErrorNoDetails
type MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails struct {

  // Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
  Code int `json:"code"` // s:1e9f3ea3a8, f:bd0cb8d03196cff607bd
  _code_ValidationError error


  // Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
  Details *Details `json:"details,omitempty"` // s:0fe1d7157a, f:835bc72ae83083ea018b

  // Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
  Message string `json:"message"` // s:8c7445dbf7, f:27df73854069ab5ac41b
  _message_ValidationError error


  // An error is retriable if the same request may succeed if submitted again.
  Retriable bool `json:"retriable"` // s:52344de0b6, f:1a1713dd46e977a1a940
  _retriable_ValidationError error

}

// Metadata meta data
type Metadata struct {
  Difficulty string `json:"difficulty"` // s:453ff9a99c, f:f19d21633b940ebd384c
  _difficulty_ValidationError error

  TransactionsRoot string `json:"transactions_root"` // s:75679d1d93, f:44da28d0b077f9ac4c22
  _transactions_root_ValidationError error

}

// Metadata_88e29c6a2a Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
type Metadata_88e29c6a2a struct {

  // The locktime
  LockTime int `json:"lockTime,omitempty"` // s:97594175d6, f:5b625dee985072233b83

  // STX token transfer memo.
  Memo string `json:"memo,omitempty"` // s:08e5a7d7c7, f:f2447aacfb0971321bd5

  // The Size
  Size int `json:"size,omitempty"` // s:b9c71b4496, f:a19a1464d846bcd92254
}

// Metadata_8987256d8e Meta data from subnetwork identifier
type Metadata_8987256d8e struct {

  // producer
  Producer string `json:"producer"` // s:3cdf548852, f:ecd277998800c4cd11cc
  _producer_ValidationError error

}

// Microblock A microblock
type Microblock struct {

  // The hash of the anchor block that confirmed this microblock. This wil be empty for unanchored microblocks
  BlockHash string `json:"block_hash"` // s:653a5b3c1d, f:c189e7cce8331b8ad66c
  _block_hash_ValidationError error


  // The anchor block height that confirmed this microblock.
  BlockHeight int `json:"block_height"` // s:ff5270c7fe, f:92822f43b921b356c5db
  _block_height_ValidationError error


  // Set to `true` if the microblock corresponds to the canonical chain tip.
  Canonical bool `json:"canonical"` // s:6b74a9f8a5, f:2b95d4b3dbc5cc61b7d6
  _canonical_ValidationError error


  // Set to `true` if the microblock was not orphaned in a following anchor block. Defaults to `true` if the following anchor block has not yet been created.
  MicroblockCanonical bool `json:"microblock_canonical"` // s:588908d70e, f:7f6ca8afc4b1f9b1e791
  _microblock_canonical_ValidationError error


  // The SHA512/256 hash of this microblock.
  MicroblockHash string `json:"microblock_hash"` // s:f246e83943, f:f107a0699bbc904d733a
  _microblock_hash_ValidationError error


  // The SHA512/256 hash of the previous signed microblock in this stream.
  MicroblockParentHash string `json:"microblock_parent_hash"` // s:896b7941b1, f:47b82cfb84cb1ba3ba4a
  _microblock_parent_hash_ValidationError error


  // A hint to describe how to order a set of microblocks. Starts at 0.
  MicroblockSequence int `json:"microblock_sequence"` // s:e79418aea4, f:b79c5efe0063fe35eec1
  _microblock_sequence_ValidationError error


  // The hash of the anchor block that preceded this microblock.
  ParentBlockHash string `json:"parent_block_hash"` // s:ba6ba2dd08, f:69c41e2335f7bf17b41a
  _parent_block_hash_ValidationError error


  // The height of the anchor block that preceded this microblock.
  ParentBlockHeight int `json:"parent_block_height"` // s:a8dc4bd78d, f:1754888a479b8137ce9a
  _parent_block_height_ValidationError error


  // The hash of the Bitcoin block that preceded this microblock.
  ParentBurnBlockHash string `json:"parent_burn_block_hash"` // s:a964f2a196, f:e49c3291d8199560a280
  _parent_burn_block_hash_ValidationError error


  // The height of the Bitcoin block that preceded this microblock.
  ParentBurnBlockHeight int `json:"parent_burn_block_height"` // s:414b9ccab7, f:b360fb341557cb57512e
  _parent_burn_block_height_ValidationError error


  // The block timestamp of the Bitcoin block that preceded this microblock.
  ParentBurnBlockTime int `json:"parent_burn_block_time"` // s:b6323fbf1e, f:9d7ba6e51f954e6a3035
  _parent_burn_block_time_ValidationError error


  // The ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) formatted block time of the bitcoin block that preceded this microblock.
  ParentBurnBlockTimeIso string `json:"parent_burn_block_time_iso"` // s:cfc3d672f1, f:61749698ee89e20d46c2
  _parent_burn_block_time_iso_ValidationError error


  // List of transactions included in the microblock
  Txs []string `json:"txs"` // s:4f0faf0aac, f:eba6d969002e94bb9244
  _txs_ValidationError error

}

// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
type NetworkIdentifier struct {

  // Blockchain name
  Blockchain string `json:"blockchain"` // s:a8259ad05b, f:6dfd7f78d3d386a52cd6
  _blockchain_ValidationError error


  // If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
  Network string `json:"network"` // s:f7eb522299, f:4b5c5419426fd9b15810
  _network_ValidationError error


  // In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
  SubNetworkIdentifier *SubNetworkIdentifier `json:"sub_network_identifier,omitempty"` // s:898cabd6ea, f:3fdd83a0088e7acb9d54
}

// NftBalance 
type NftBalance struct {
  Count string `json:"count"` // s:1e62856e69, f:9a02eceb631338cb0634
  _count_ValidationError error

  TotalReceived string `json:"total_received"` // s:4834cef069, f:7b89d742550baebc56f9
  _total_received_ValidationError error

  TotalSent string `json:"total_sent"` // s:22d56f918e, f:4622d305e2533e75d04f
  _total_sent_ValidationError error

}

// NftEvent_NonFungibleTokenHoldingWithTxId 
// Aliased for: NftEvent, NonFungibleTokenHoldingWithTxId
type NftEvent_NonFungibleTokenHoldingWithTxId struct {
  AssetIdentifier string `json:"asset_identifier"` // s:f5535a33e1, f:be4eeba5688ae15c038b
  _asset_identifier_ValidationError error

  BlockHeight float64 `json:"block_height"` // s:be03222bc3, f:5fbf7e158b89746eeabb
  _block_height_ValidationError error

  Recipient string `json:"recipient"` // s:b8b00a8386, f:0175604351673fdbaa53
  _recipient_ValidationError error

  Sender string `json:"sender"` // s:be92036170, f:2d2daf66db766c5d8750
  _sender_ValidationError error

  TxId string `json:"tx_id"` // s:52554dde8a, f:bc1527b17d76b6c956d5
  _tx_id_ValidationError error


  // Identifier of the NFT
  // Non-Fungible Token value
  Value *Value `json:"value"` // s:6800aefee0, f:1cfb069b1549652c0b37
  _value_ValidationError error

}

// NftTransfersItems 
type NftTransfersItems struct {

  // Non Fungible Token asset identifier.
  AssetIdentifier string `json:"asset_identifier"` // s:71f4d0a5b5, f:f4a1b23bf0db767d120a
  _asset_identifier_ValidationError error


  // Principal that received the asset.
  Recipient string `json:"recipient,omitempty"` // s:eb8670a16d, f:76f20122429f3fc343ee

  // Principal that sent the asset.
  Sender string `json:"sender,omitempty"` // s:88c0c083f4, f:058981b367b25a775cc6

  // Non Fungible Token asset value.
  Value *Value `json:"value"` // s:6800aefee0, f:875e96d360732dde3b73
  _value_ValidationError error

}

// NonFungibleTokenHistoryEventWithTxId Non-Fungible Token history event with transaction id
type NonFungibleTokenHistoryEventWithTxId struct {
  AssetEventType string `json:"asset_event_type"` // s:a3d5a765ac, f:4f80b6025c064af3cd1e
  _asset_event_type_ValidationError error

  EventIndex int `json:"event_index"` // s:2e949b4513, f:56a7ab97fb97697641ba
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:02e3cee36c, f:94fc90b96d833fb4e649
  Sender string `json:"sender,omitempty"` // s:d215783e09, f:effc938be98d0106670d
  TxId string `json:"tx_id"` // s:fc36ba0dd4, f:38b160bb3039eb9bf1fc
  _tx_id_ValidationError error

}

// NonFungibleTokenHistoryEventWithTxMetadata Non-Fungible Token history event with transaction metadata
type NonFungibleTokenHistoryEventWithTxMetadata struct {
  AssetEventType string `json:"asset_event_type"` // s:fcd81ff9e2, f:43c5fe36243199467953
  _asset_event_type_ValidationError error

  EventIndex int `json:"event_index"` // s:5d936da1c7, f:59b89a539dad400f9897
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:9840a08444, f:7128241e6028500a0ba0
  Sender string `json:"sender,omitempty"` // s:8bb465cd9a, f:4e01ecdb7fd6affbc104
  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata `json:"tx"` // s:d15bf52174, f:ebf1fb9b3e7868a8b055
  _tx_ValidationError error

}

// NonFungibleTokenHoldingWithTxMetadata Ownership of a Non-Fungible Token with transaction metadata
type NonFungibleTokenHoldingWithTxMetadata struct {
  AssetIdentifier string `json:"asset_identifier"` // s:0235d320e8, f:c31b7cd5f26241586eb9
  _asset_identifier_ValidationError error

  BlockHeight float64 `json:"block_height"` // s:a16bd65f7e, f:75f8e1a538e527b766d6
  _block_height_ValidationError error

  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata `json:"tx"` // s:d15bf52174, f:f015957c26fdc0b1c3d8
  _tx_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:6800aefee0, f:4641ad92e5e1037cfbc5
  _value_ValidationError error

}

// NonFungibleTokenMintWithTxMetadata Non-Fungible Token mint event with transaction metadata
type NonFungibleTokenMintWithTxMetadata struct {
  EventIndex int `json:"event_index"` // s:5d05064132, f:7b2110b8d4179df220ea
  _event_index_ValidationError error

  Recipient string `json:"recipient,omitempty"` // s:037a32e957, f:dc10166ce901db51cb97
  Tx *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata `json:"tx"` // s:d15bf52174, f:58f47969dc9e124c4303
  _tx_ValidationError error


  // Non-Fungible Token value
  Value *Value `json:"value"` // s:6800aefee0, f:b577ab75445de1d84214
  _value_ValidationError error

}

// PoisonMicroblock 
type PoisonMicroblock struct {

  // Hex encoded microblock header
  MicroblockHeader1 string `json:"microblock_header_1"` // s:ea3a65ac53, f:5d747d4670ee7197e4a2
  _microblock_header_1_ValidationError error


  // Hex encoded microblock header
  MicroblockHeader2 string `json:"microblock_header_2"` // s:c06c33652a, f:1e97e22fefdb307cd652
  _microblock_header_2_ValidationError error

}

// PoisonMicroblockTransactionMetadata Metadata associated with a poison-microblock type transaction
type PoisonMicroblockTransactionMetadata struct {
  PoisonMicroblock *PoisonMicroblock `json:"poison_microblock"` // s:931c47bd10, f:1f1a177289f597de59ee
  _poison_microblock_ValidationError error

  TxType string `json:"tx_type"` // s:dadb02ba06, f:f02e3dff8ce4d85eed45
  _tx_type_ValidationError error

}

// ReadOnlyFunctionArgs Describes representation of a Type-0 Stacks 2.0 transaction. https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#type-0-transferring-an-asset
type ReadOnlyFunctionArgs struct {

  // An array of hex serialized Clarity values
  Arguments []string `json:"arguments"` // s:4146eec8e3, f:35066eac48806d8f8085
  _arguments_ValidationError error


  // The simulated tx-sender
  Sender string `json:"sender"` // s:ba738cd435, f:e12b697dc2f7d576af97
  _sender_ValidationError error

}

// Result 
type Result struct {
  TxId string `json:"tx_id"` // s:e1a006cb97, f:7f155390df2e109d23b0
  _tx_id_ValidationError error

}

// RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount 
// Aliased for: RosettaAccount, RosettaAccountIdentifier, RosettaSubAccount
type RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount struct {

  // The address may be a cryptographic public key (or some encoding of it) or a provided username.
  Address string `json:"address"` // s:ab80b33016, f:b2199193b79abf35bff1
  _address_ValidationError error


  // If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
  // Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
  Metadata *Metadata_88e29c6a2a `json:"metadata,omitempty"` // s:88e29c6a2a, f:ff5f18faa638bd5546b6
  SubAccount *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount `json:"sub_account,omitempty"` // s:3a4f5e5667, f:30d4060ecb8da7e90751
}

// RosettaAmount_RosettaMaxFeeAmount 
// Aliased for: RosettaAmount, RosettaMaxFeeAmount
type RosettaAmount_RosettaMaxFeeAmount struct {
  Currency *RosettaCurrency `json:"currency"` // s:86fb47be5c, f:9cc2285041d318f1f301
  _currency_ValidationError error

  Metadata *Metadata_88e29c6a2a `json:"metadata,omitempty"` // s:88e29c6a2a, f:cd3c2d46a3e36d636ca2

  // Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
  Value string `json:"value"` // s:5a4960b040, f:ecfa5744a28b4f544207
  _value_ValidationError error

}

// RosettaBlock Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be inalterable: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents.
type RosettaBlock struct {
  BlockIdentifier interface{} `json:"block_identifier"` // s:20b5141602, f:e72afb43de1e62446646
  _block_identifier_ValidationError error


  // meta data
  Metadata *Metadata `json:"metadata,omitempty"` // s:fae04f9320, f:7f7a39b43fc4f7d34395
  ParentBlockIdentifier *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier `json:"parent_block_identifier"` // s:cdf562c0e9, f:07c641f17ed333bd3122
  _parent_block_identifier_ValidationError error


  // The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
  Timestamp int `json:"timestamp"` // s:5aaa05b4f8, f:8e795acbd4017a81ce8b
  _timestamp_ValidationError error


  // All the transactions in the block
  Transactions []*RosettaTransaction `json:"transactions"` // s:e13f088eaf, f:ac68992dd6aa966f04d8
  _transactions_ValidationError error

}

// RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier 
// Aliased for: RosettaBlockIdentifierHeight, RosettaGenesisBlockIdentifier, RosettaOldestBlockIdentifier, RosettaParentBlockIdentifier
type RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier struct {

  // Block hash
  Hash string `json:"hash"` // s:a47cb31ad5, f:8bb23c5b3d33f81bdbe3
  _hash_ValidationError error


  // This is also known as the block height.
  Index int `json:"index"` // s:73af21fd80, f:76c794a35eebcb398a40
  _index_ValidationError error

}

// RosettaCoin If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.
type RosettaCoin struct {
  Amount *RosettaAmount_RosettaMaxFeeAmount `json:"amount"` // s:a47e9353fd, f:d582064acdba908a5991
  _amount_ValidationError error


  // CoinIdentifier uniquely identifies a Coin.
  CoinIdentifier *CoinIdentifier `json:"coin_identifier"` // s:1c6ae2fd1a, f:ddcfaff5127c54d6060c
  _coin_identifier_ValidationError error

}

// RosettaCoinChange CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
type RosettaCoinChange struct {

  // CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
  CoinAction string `json:"coin_action"` // s:29195b7351, f:3bff2795ec50a62a0136
  _coin_action_ValidationError error


  // CoinIdentifier uniquely identifies a Coin.
  CoinIdentifier *CoinIdentifier `json:"coin_identifier"` // s:1c6ae2fd1a, f:3868104ec73ceae6d17f
  _coin_identifier_ValidationError error

}

// RosettaCurrency Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
type RosettaCurrency struct {

  // Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
  Decimals int `json:"decimals"` // s:901a1c9873, f:2f414b016dfcbef446bf
  _decimals_ValidationError error


  // Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
  Metadata *Metadata_88e29c6a2a `json:"metadata,omitempty"` // s:88e29c6a2a, f:33ac715356f5d93b7150

  // Canonical symbol associated with a currency.
  Symbol string `json:"symbol"` // s:ca381ba317, f:e2e7bd8d64f307dfede8
  _symbol_ValidationError error

}

// RosettaOperation Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction.
type RosettaOperation struct {
  Account *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount `json:"account,omitempty"` // s:3a4f5e5667, f:4426929fe089517c65fa
  Amount *RosettaAmount_RosettaMaxFeeAmount `json:"amount,omitempty"` // s:a47e9353fd, f:8676b325ac9cb65ef963
  CoinChange *RosettaCoinChange `json:"coin_change,omitempty"` // s:b4f92d037b, f:f8e20c7e65e2dab84eae

  // Operations Meta Data
  Metadata *Metadata_88e29c6a2a `json:"metadata,omitempty"` // s:88e29c6a2a, f:ebc252863abbf08bcabf
  OperationIdentifier *RosettaOperationIdentifier_RosettaRelatedOperation `json:"operation_identifier"` // s:21c87174bf, f:360a53136153b4fb3561
  _operation_identifier_ValidationError error


  // Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
  RelatedOperations []*RosettaRelatedOperation `json:"related_operations,omitempty"` // s:533945a06e, f:f325fa45cbdfc07c89dc

  // The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
  Status string `json:"status,omitempty"` // s:16127f270a, f:8cffb683bd6481a8080a

  // The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
  Type string `json:"type"` // s:08a35ec919, f:318391691b749d38c93c
  _type_ValidationError error

}

// RosettaOperationIdentifier_RosettaRelatedOperation 
// Aliased for: RosettaOperationIdentifier, RosettaRelatedOperation
type RosettaOperationIdentifier_RosettaRelatedOperation struct {

  // The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
  // Describes the index of related operation.
  Index int `json:"index"` // s:cf8e489d27, f:3fbe8bf799aa8674d70d
  _index_ValidationError error


  // Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
  // Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
  NetworkIndex int `json:"network_index,omitempty"` // s:8af091ac81, f:1e2910ae398b30a8ed96
}

// RosettaOperationStatus OperationStatus is utilized to indicate which Operation status are considered successful.
type RosettaOperationStatus struct {

  // The status is the network-specific status of the operation.
  Status string `json:"status"` // s:eace86afce, f:66eb4c966e70a17e4bee
  _status_ValidationError error


  // An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.
  Successful bool `json:"successful"` // s:1c4b29f797, f:d3c4b7704c542e91a33f
  _successful_ValidationError error

}

// RosettaOptions The options that will be sent directly to /construction/metadata by the caller.
type RosettaOptions struct {

  // Amount to be transfered.
  Amount string `json:"amount,omitempty"` // s:41edd22fc1, f:aa9a8c7cbe3db255d969

  // Set the burnchain (BTC) block for stacking lock to start.
  BurnBlockHeight int `json:"burn_block_height,omitempty"` // s:81a1f4d452, f:6f9090f0871e5020d3ef

  // Address of the contract to call.
  ContractAddress string `json:"contract_address,omitempty"` // s:7811be981c, f:bc34bdd34166ef5e9417

  // Name of the contract to call.
  ContractName string `json:"contract_name,omitempty"` // s:a0970421de, f:2901000d7f31145a2917

  // Number of decimal places
  Decimals int `json:"decimals,omitempty"` // s:15cfd44ea2, f:7c5525222c9ba8a6a515

  // Delegator address for when calling `delegate-stacking`.
  DelegateTo string `json:"delegate_to,omitempty"` // s:ed4ad3e6e1, f:54ad673a96066d2f342d

  // Fee for this transaction
  Fee string `json:"fee,omitempty"` // s:9051fea201, f:4202d25a661aa2710f7e

  // Maximum price a user is willing to pay.
  GasLimit float64 `json:"gas_limit,omitempty"` // s:5d6d2652f3, f:a64e5768586c5f451adc

  // Cost necessary to perform a transaction on the network
  GasPrice float64 `json:"gas_price,omitempty"` // s:298cc2374e, f:bc554faf269d64fef3a4

  // Maximum fee user is willing to pay
  MaxFee string `json:"max_fee,omitempty"` // s:4599c97238, f:1706ec8fe81df902b62d

  // STX token transfer memo.
  Memo string `json:"memo,omitempty"` // s:d657e90f88, f:bb40a4373b39bf51ca01

  // Number of cycles when stacking.
  NumberOfCycles int `json:"number_of_cycles,omitempty"` // s:de716c2338, f:514b2dc94a0d5aaa6ee5

  // The reward address for stacking transaction. It should be a valid Bitcoin address
  PoxAddr string `json:"pox_addr,omitempty"` // s:26a4b984be, f:e887a3aa6e613b6b4fc3

  // sender's address 
  SenderAddress string `json:"sender_address,omitempty"` // s:20b4888759, f:71e66e308f83008a96f5

  // Transaction approximative size (used to calculate total fee).
  Size int `json:"size,omitempty"` // s:342e6d72d3, f:23039bbd6269fdd79261

  // This value indicates the state of the operations
  Status string `json:"status,omitempty"` // s:e4da33826b, f:1030f7bee26c0b715db6

  //  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
  SuggestedFeeMultiplier float64 `json:"suggested_fee_multiplier,omitempty"` // s:a304f69570, f:84c7cd23329056ffc425

  // Currency symbol e.g STX
  Symbol string `json:"symbol,omitempty"` // s:e90204caf6, f:79be4ebf8840a01d3f66

  // Recipient's address
  TokenTransferRecipientAddress string `json:"token_transfer_recipient_address,omitempty"` // s:0e2cee2d90, f:d512b2e4be5cc3fd76e2

  // Type of operation e.g transfer
  Type string `json:"type,omitempty"` // s:59d914a167, f:c3309fbbe00873d6bbeb
}

// RosettaPeers A Peer is a representation of a node's peer.
type RosettaPeers struct {

  // meta data
  Metadata *Metadata `json:"metadata,omitempty"` // s:fae04f9320, f:bcae11821c025df5c3c4

  // peer id
  PeerId string `json:"peer_id"` // s:54aceb8153, f:b2468750c347ab9f09e5
  _peer_id_ValidationError error

}

// RosettaPublicKey PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
type RosettaPublicKey struct {

  // CurveType is the type of cryptographic curve associated with a PublicKey.
  CurveType string `json:"curve_type"` // s:41dcbfe837, f:a859c4a5e3d6172d4cab
  _curve_type_ValidationError error


  // Hex-encoded public key bytes in the format specified by the CurveType.
  HexBytes string `json:"hex_bytes"` // s:9b707cd982, f:8e33a78304ac69c18876
  _hex_bytes_ValidationError error

}

// RosettaSignature Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.
type RosettaSignature struct {
  HexBytes string `json:"hex_bytes"` // s:5f2b9d5ad0, f:fb73a1f890581c78286a
  _hex_bytes_ValidationError error

  PublicKey *RosettaPublicKey `json:"public_key"` // s:9963a636a5, f:32ee1903d96666493d69
  _public_key_ValidationError error

  SignatureType string `json:"signature_type"` // s:a18d21c822, f:b4abd1f69b0de3d5b0ff
  _signature_type_ValidationError error

  SigningPayload *SigningPayload `json:"signing_payload"` // s:48a5525856, f:60d96ae97a2de353b294
  _signing_payload_ValidationError error

}

// RosettaSyncStatus SyncStatus is used to provide additional context about an implementation's sync status. It is often used to indicate that an implementation is healthy when it cannot be queried until some sync phase occurs. If an implementation is immediately queryable, this model is often not populated.
type RosettaSyncStatus struct {

  // CurrentIndex is the index of the last synced block in the current stage.
  CurrentIndex int `json:"current_index"` // s:8dd97011f6, f:6146991efb9442beef09
  _current_index_ValidationError error


  // Stage is the phase of the sync process.
  Stage string `json:"stage,omitempty"` // s:422abd18c9, f:4c85a3e181fd89c863ee

  // Synced indicates if an implementation has synced up to the most recent block.
  Synced bool `json:"synced,omitempty"` // s:b156d8a100, f:50df67544b9e0696c192

  // TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.
  TargetIndex int `json:"target_index,omitempty"` // s:b55edfe2a8, f:ada65316b8414974d570
}

// RosettaTransaction Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
type RosettaTransaction struct {

  // Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
  Metadata *Metadata_88e29c6a2a `json:"metadata,omitempty"` // s:88e29c6a2a, f:23e67027b4175de4ef77

  // List of operations
  Operations []*RosettaOperation `json:"operations"` // s:18c46f8419, f:d980c3ad145ddaefc2d0
  _operations_ValidationError error

  TransactionIdentifier *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"transaction_identifier"` // s:4a9e77b6c1, f:501ab7484c8db4d4615a
  _transaction_identifier_ValidationError error

}

// RpcAddressBalanceNotificationParams 
type RpcAddressBalanceNotificationParams struct {
  Address string `json:"address"` // s:c1834a86d0, f:dbf602aa7e9a04d292a2
  _address_ValidationError error

  Balance string `json:"balance"` // s:9923728e61, f:c5306c409f5acc917796
  _balance_ValidationError error

}

// RpcAddressBalanceNotificationResponse 
type RpcAddressBalanceNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:436f8ee3d4, f:1354f379b461ab95ef9c
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:158575516e, f:56249c41935fc173e4e6
  _method_ValidationError error

  Params *RpcAddressBalanceNotificationParams `json:"params"` // s:410e093bdf, f:7a667b41638fd4732b19
  _params_ValidationError error

}

// RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams 
// Aliased for: RpcAddressBalanceSubscriptionParams, RpcAddressTxSubscriptionParams, RpcBlockSubscriptionParams, RpcMempoolSubscriptionParams, RpcMicroblockSubscriptionParams
type RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams struct {
  Address string `json:"address"` // s:17f7fb71c5, f:3430fcaf367a0a5e14d4
  _address_ValidationError error

  Event string `json:"event"` // s:6817153709, f:d77b7e0a7cd10c7200b7
  _event_ValidationError error

}

// RpcAddressBalanceSubscriptionRequest 
type RpcAddressBalanceSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:d556e29599, f:73bc0d2a1c54df376a8f
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:c706864f8a, f:61d3726d9ffea87d6b30
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:5706d9be3d, f:af0ed6f01d46dc965e55
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams `json:"params"` // s:a1ec37cd7e, f:622b95378c69976003ab
  _params_ValidationError error

}

// RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams 
// Aliased for: RpcAddressTxNotificationParams, RpcTxUpdateNotificationParams
type RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams struct {
  Address string `json:"address"` // s:b0bd1e78e2, f:c9a7957479d331c104f2
  _address_ValidationError error

  TxId string `json:"tx_id"` // s:82f72e7e45, f:9a1e7d7783f82ddeabed
  _tx_id_ValidationError error

  TxStatus interface{} `json:"tx_status"` // s:23db7fbc55, f:3fea5762dad8ab3709ba
  _tx_status_ValidationError error

  TxType string `json:"tx_type"` // s:156cf16a4c, f:b2f008ac230a2854261c
  _tx_type_ValidationError error

}

// RpcAddressTxNotificationResponse 
type RpcAddressTxNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:a52e64e821, f:80c65a261586e3cb19f0
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:3d42c3554c, f:57a6c5f80693a0c15fb1
  _method_ValidationError error

  Params *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams `json:"params"` // s:3c95f786fc, f:5b196913c15643b95a0a
  _params_ValidationError error

}

// RpcAddressTxSubscriptionRequest 
type RpcAddressTxSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:1dc1ab5230, f:ca944cd323b8c3f71c66
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:f8f4cb59de, f:9d25b40b0e0d343a02e7
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:af460033d0, f:1fc247f4b57e428c3e28
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams `json:"params"` // s:a1ec37cd7e, f:131887f868c763a437a0
  _params_ValidationError error

}

// RpcBlockNotificationResponse 
type RpcBlockNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:329e0dce24, f:e8f02c63d6085e402f40
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:323fc0a689, f:3bf854e50cd9d7a47807
  _method_ValidationError error

  Params *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier `json:"params"` // s:4a9e77b6c1, f:35d5c882f642a58a6d12
  _params_ValidationError error

}

// RpcBlockSubscriptionRequest 
type RpcBlockSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:dbf5006d08, f:e5af98f07e85d9680d83
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:f2aadf93af, f:3cd25558417f36adc916
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:b767be4fd7, f:21c0a8d94f3e4392afbc
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams `json:"params"` // s:a1ec37cd7e, f:24945789faa6a3a2aced
  _params_ValidationError error

}

// RpcMempoolNotificationResponse 
type RpcMempoolNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:75e709d4f5, f:8c345e3e06138d39fe6b
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:7546158c16, f:d84f215f3b7270c7a8be
  _method_ValidationError error

  Params *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata `json:"params"` // s:d15bf52174, f:73c7c97ddcae2f1f0829
  _params_ValidationError error

}

// RpcMempoolSubscriptionRequest 
type RpcMempoolSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:125416c5ec, f:f392f164e928ded6939c
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:7d4985a272, f:4a3d76f134e146a81a5b
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:648948bdc2, f:c2f4517641697b0e5078
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams `json:"params"` // s:a1ec37cd7e, f:5a225e0128e394031dca
  _params_ValidationError error

}

// RpcMicroblockNotificationResponse 
type RpcMicroblockNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:43a2f193b2, f:5875d0398fe04b32e14c
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:ecd521fe6b, f:c0e67b808b64337af4cc
  _method_ValidationError error

  Params *Microblock `json:"params"` // s:1464470fa8, f:3b4b2085428f83892d4a
  _params_ValidationError error

}

// RpcMicroblockSubscriptionRequest 
type RpcMicroblockSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:78439fa992, f:0700a3a800db1ddf7c0c
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:ef27b517ff, f:0310a3b08969618d4f7b
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:004a2057aa, f:f6bde71a762944358d57
  _method_ValidationError error

  Params *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams `json:"params"` // s:a1ec37cd7e, f:a79e87ab7a3e2b9c1fde
  _params_ValidationError error

}

// RpcTxUpdateNotificationResponse 
type RpcTxUpdateNotificationResponse struct {
  Jsonrpc string `json:"jsonrpc"` // s:2dd4dd8986, f:b54e49458f7060128298
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:101c4a51c7, f:8241ba94fda1a446e15f
  _method_ValidationError error

  Params *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams `json:"params"` // s:3c95f786fc, f:81b189b200767295a315
  _params_ValidationError error

}

// RpcTxUpdateSubscriptionParams 
type RpcTxUpdateSubscriptionParams struct {
  Event string `json:"event"` // s:c322108b43, f:4ae2c97621716f77f13c
  _event_ValidationError error

  TxId string `json:"tx_id"` // s:7b738766a3, f:e2323ff2b502b53dd878
  _tx_id_ValidationError error

}

// RpcTxUpdateSubscriptionRequest 
type RpcTxUpdateSubscriptionRequest struct {
  Id interface{} `json:"id"` // s:dd7731525b, f:7a6ecf3315c78bac6e3b
  _id_ValidationError error

  Jsonrpc string `json:"jsonrpc"` // s:104382d1c6, f:3e841f9c67e8b3cc920a
  _jsonrpc_ValidationError error

  Method string `json:"method"` // s:6e60fd20d4, f:3065cf04f07c52965ada
  _method_ValidationError error

  Params *RpcTxUpdateSubscriptionParams `json:"params"` // s:a5035355fd, f:86cfd9902fa0e138c927
  _params_ValidationError error

}

// SigningPayload SigningPayload is signed by the client with the keypair associated with an address using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
type SigningPayload struct {
  AccountIdentifier *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount `json:"account_identifier,omitempty"` // s:3a4f5e5667, f:6029efc33ce12fdb9fb1

  // [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
  Address string `json:"address,omitempty"` // s:a8651cbb29, f:5885b024ea00a3c1e7ad
  HexBytes string `json:"hex_bytes"` // s:71e998c77f, f:de634524bb7bbc8f7891
  _hex_bytes_ValidationError error


  // SignatureType is the type of a cryptographic signature.
  SignatureType string `json:"signature_type,omitempty"` // s:fe1650cd75, f:65cef27b01119a42714f
}

// SmartContract A Smart Contract Detail
type SmartContract struct {
  Abi string `json:"abi"` // s:f8d3215d1f, f:2a140a27cb9c0b4f95f8
  _abi_ValidationError error

  BlockHeight int `json:"block_height"` // s:c1c98f08ee, f:dc544e32067acbc30b6b
  _block_height_ValidationError error

  Canonical bool `json:"canonical"` // s:7f3d25162b, f:3b70a12d3272c8f9f8df
  _canonical_ValidationError error

  SourceCode string `json:"source_code"` // s:db5d8bc397, f:2ef991327147bed6d7d0
  _source_code_ValidationError error

  TxId string `json:"tx_id"` // s:d4d5c98927, f:6a0df9948304b6532e45
  _tx_id_ValidationError error

}

// SmartContractTransactionMetadata Metadata associated with a contract-deploy type transaction. https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#type-1-instantiating-a-smart-contract
type SmartContractTransactionMetadata struct {
  SmartContract *SmartContract_11d00c1bd3 `json:"smart_contract"` // s:11d00c1bd3, f:8b65eb1a0984e46325f2
  _smart_contract_ValidationError error

  TxType string `json:"tx_type"` // s:e726779d5b, f:627b68977ebbb84fa43e
  _tx_type_ValidationError error

}

// SmartContract_11d00c1bd3 
type SmartContract_11d00c1bd3 struct {

  // Contract identifier formatted as `<principaladdress>.<contract_name>`
  ContractId string `json:"contract_id"` // s:a5dfa603cb, f:f59e0abc83cd1d7d9980
  _contract_id_ValidationError error


  // Clarity code of the smart contract being deployed
  SourceCode string `json:"source_code"` // s:b16c521be5, f:a681d03d4d0dc4907fb5
  _source_code_ValidationError error

}

// StxTransfersItems 
type StxTransfersItems struct {

  // Amount transferred in micro-STX as an integer string.
  Amount string `json:"amount"` // s:4261b3eb4c, f:6f25a68d73b3d6ac1034
  _amount_ValidationError error


  // Principal that received STX. This is unspecified if the STX were burned.
  Recipient string `json:"recipient,omitempty"` // s:5b7a250cf1, f:f2138d71bb10bac9138a

  // Principal that sent STX. This is unspecified if the STX were minted.
  Sender string `json:"sender,omitempty"` // s:b19b269dac, f:227c2f4d6037bafb1140
}

// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
type SubNetworkIdentifier struct {

  // Meta data from subnetwork identifier
  Metadata *Metadata_8987256d8e `json:"metadata,omitempty"` // s:8987256d8e, f:2cf966731cc28eb059b9

  // Network name
  Network string `json:"network"` // s:e10a32be0e, f:a9d3ed927276aaaa8422
  _network_ValidationError error

}

// TargetBlockTime 
type TargetBlockTime struct {
  TargetBlockTime int `json:"target_block_time"` // s:d1da618434, f:ee99bb2de98efb97584a
  _target_block_time_ValidationError error

}

// TokenTransfer 
type TokenTransfer struct {

  // Transfer amount as Integer string (64-bit unsigned integer)
  Amount string `json:"amount"` // s:71dccfdfa6, f:6d21b2382f7f5c92c33c
  _amount_ValidationError error


  // Hex encoded arbitrary message, up to 34 bytes length (should try decoding to an ASCII string)
  Memo string `json:"memo"` // s:bcbda85ce2, f:36708ab7f7952c45dee7
  _memo_ValidationError error

  RecipientAddress string `json:"recipient_address"` // s:e06e2b0e47, f:ed78aa7b8d0281ae2463
  _recipient_address_ValidationError error

}

// TokenTransferTransactionMetadata Metadata associated with token-transfer type transactions
type TokenTransferTransactionMetadata struct {
  TokenTransfer *TokenTransfer `json:"token_transfer"` // s:8a30611f62, f:239309a9c1f69b05d408
  _token_transfer_ValidationError error

  TxType string `json:"tx_type"` // s:89dbc2b83b, f:1dc4fceac6ab206069ba
  _tx_type_ValidationError error

}

// TransactionEventAsset 
type TransactionEventAsset struct {
  Amount string `json:"amount,omitempty"` // s:ef9a0402ae, f:e7e2ab77033d651c6d3e
  AssetEventType string `json:"asset_event_type,omitempty"` // s:7ff482ff5d, f:73e17aba32a0a3d7195b
  AssetId string `json:"asset_id,omitempty"` // s:894e5ac9e2, f:9088d4ab5ef04798a174
  Recipient string `json:"recipient,omitempty"` // s:62e55b1860, f:6c3c047203d95f23c991
  Sender string `json:"sender,omitempty"` // s:aed9438795, f:2c4651ae8fbaa24c0291
  Value string `json:"value,omitempty"` // s:fc55a9546c, f:e28a6f3f94307384b765
}

// TransactionFound This object returns transaction for found true
type TransactionFound struct {
  Found bool `json:"found"` // s:d8a8dde251, f:42e900ed52f9fbabc408
  _found_ValidationError error

  Result interface{} `json:"result"` // s:7a61458c98, f:212b8308f34a281b652e
  _result_ValidationError error

}

// TransactionNotFound This object returns the id for not found transaction
type TransactionNotFound struct {
  Found bool `json:"found"` // s:c4f7232560, f:a394b4bba1c9fa151d8e
  _found_ValidationError error

  Result *Result `json:"result"` // s:f5f92d4c5b, f:79bfb3374fb448284edd
  _result_ValidationError error

}

// Value Non-Fungible Token value
type Value struct {

  // Hex string representing the identifier of the Non-Fungible Token
  // Hex string representing the identifier of the NFT
  // 
  Hex string `json:"hex"` // s:a2e18ce40b, f:50b23a1b77b59c5bdd72
  _hex_ValidationError error


  // Readable string of the Non-Fungible Token identifier
  // Readable string of the NFT identifier
  // 
  Repr string `json:"repr"` // s:1acf9c3bb3, f:7a1266283ed2152de9f5
  _repr_ValidationError error

}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata) UnmarshalJSON(b []byte) error {
    event_indexReceived := false
    tx_idReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AbstractMempoolTransaction_AbstractTransaction_AbstractTransactionEvent_CoinbaseTransaction_ContractCallTransaction_MempoolContractCallTransaction_MempoolPoisonMicroblockTransaction_MempoolSmartContractTransaction_MempoolTokenTransferTransaction_MempoolTransaction_NonFungibleTokenHistoryEvent_NonFungibleTokenHolding_NonFungibleTokenMint_NonFungibleTokenMintWithTxId_PoisonMicroblockTransaction_PostConditionFungible_PostConditionNonFungible_PostConditionPrincipal_PostConditionStx_RosettaPartialBlockIdentifier_SmartContractTransaction_TokenTransferTransaction_Transaction_TransactionEvent_TransactionEventFungibleAsset_TransactionEventNonFungibleAsset_TransactionEventSmartContractLog_TransactionEventStxAsset_TransactionEventStxLock_TransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressNonces) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DetectedMissingNonces" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "detected_missing_nonces" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"detected_missing_nonces\": ")
	if tmp, err := json.Marshal(strct.DetectedMissingNonces); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LastExecutedTxNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "last_executed_tx_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"last_executed_tx_nonce\": ")
	if tmp, err := json.Marshal(strct.LastExecutedTxNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LastMempoolTxNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "last_mempool_tx_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"last_mempool_tx_nonce\": ")
	if tmp, err := json.Marshal(strct.LastMempoolTxNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PossibleNextNonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "possible_next_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"possible_next_nonce\": ")
	if tmp, err := json.Marshal(strct.PossibleNextNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressNonces) UnmarshalJSON(b []byte) error {
    detected_missing_noncesReceived := false
    last_executed_tx_nonceReceived := false
    last_mempool_tx_nonceReceived := false
    possible_next_nonceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "detected_missing_nonces":
            if err := json.Unmarshal([]byte(v), &strct.DetectedMissingNonces); err != nil {
				return err
            }
            detected_missing_noncesReceived = true
        case "last_executed_tx_nonce":
            if err := json.Unmarshal([]byte(v), &strct.LastExecutedTxNonce); err != nil {
				return err
            }
            last_executed_tx_nonceReceived = true
        case "last_mempool_tx_nonce":
            if err := json.Unmarshal([]byte(v), &strct.LastMempoolTxNonce); err != nil {
				return err
            }
            last_mempool_tx_nonceReceived = true
        case "possible_next_nonce":
            if err := json.Unmarshal([]byte(v), &strct.PossibleNextNonce); err != nil {
				return err
            }
            possible_next_nonceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if detected_missing_nonces (a required property) was received
    if !detected_missing_noncesReceived {
		strct._detected_missing_nonces_ValidationError = fmt.Errorf("\"DetectedMissingNonces\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if last_executed_tx_nonce (a required property) was received
    if !last_executed_tx_nonceReceived {
		strct._last_executed_tx_nonce_ValidationError = fmt.Errorf("\"LastExecutedTxNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if last_mempool_tx_nonce (a required property) was received
    if !last_mempool_tx_nonceReceived {
		strct._last_mempool_tx_nonce_ValidationError = fmt.Errorf("\"LastMempoolTxNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if possible_next_nonce (a required property) was received
    if !possible_next_nonceReceived {
		strct._possible_next_nonce_ValidationError = fmt.Errorf("\"PossibleNextNonce\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressNonces) Validate() []error {
    var allErrors []error
    if strct._detected_missing_nonces_ValidationError != nil {
		allErrors = append(allErrors, strct._detected_missing_nonces_ValidationError)
	}
    if strct._last_executed_tx_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._last_executed_tx_nonce_ValidationError)
	}
    if strct._last_mempool_tx_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._last_mempool_tx_nonce_ValidationError)
	}
    if strct._possible_next_nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._possible_next_nonce_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressTokenOfferingLocked) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TotalLocked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_locked\": ")
	if tmp, err := json.Marshal(strct.TotalLocked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalUnlocked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_unlocked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_unlocked\": ")
	if tmp, err := json.Marshal(strct.TotalUnlocked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "UnlockSchedule" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "unlock_schedule" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"unlock_schedule\": ")
	if tmp, err := json.Marshal(strct.UnlockSchedule); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressTokenOfferingLocked) UnmarshalJSON(b []byte) error {
    total_lockedReceived := false
    total_unlockedReceived := false
    unlock_scheduleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "total_locked":
            if err := json.Unmarshal([]byte(v), &strct.TotalLocked); err != nil {
				return err
            }
            total_lockedReceived = true
        case "total_unlocked":
            if err := json.Unmarshal([]byte(v), &strct.TotalUnlocked); err != nil {
				return err
            }
            total_unlockedReceived = true
        case "unlock_schedule":
            if err := json.Unmarshal([]byte(v), &strct.UnlockSchedule); err != nil {
				return err
            }
            unlock_scheduleReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if total_locked (a required property) was received
    if !total_lockedReceived {
		strct._total_locked_ValidationError = fmt.Errorf("\"TotalLocked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_unlocked (a required property) was received
    if !total_unlockedReceived {
		strct._total_unlocked_ValidationError = fmt.Errorf("\"TotalUnlocked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if unlock_schedule (a required property) was received
    if !unlock_scheduleReceived {
		strct._unlock_schedule_ValidationError = fmt.Errorf("\"UnlockSchedule\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressTokenOfferingLocked) Validate() []error {
    var allErrors []error
    if strct._total_locked_ValidationError != nil {
		allErrors = append(allErrors, strct._total_locked_ValidationError)
	}
    if strct._total_unlocked_ValidationError != nil {
		allErrors = append(allErrors, strct._total_unlocked_ValidationError)
	}
    if strct._unlock_schedule_ValidationError != nil {
		allErrors = append(allErrors, strct._unlock_schedule_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressTransactionWithTransfers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "ft_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"ft_transfers\": ")
	if tmp, err := json.Marshal(strct.FtTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nft_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nft_transfers\": ")
	if tmp, err := json.Marshal(strct.NftTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_received\": ")
	if tmp, err := json.Marshal(strct.StxReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_sent\": ")
	if tmp, err := json.Marshal(strct.StxSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "StxTransfers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stx_transfers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stx_transfers\": ")
	if tmp, err := json.Marshal(strct.StxTransfers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressTransactionWithTransfers) UnmarshalJSON(b []byte) error {
    stx_receivedReceived := false
    stx_sentReceived := false
    stx_transfersReceived := false
    txReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ft_transfers":
            if err := json.Unmarshal([]byte(v), &strct.FtTransfers); err != nil {
				return err
            }
        case "nft_transfers":
            if err := json.Unmarshal([]byte(v), &strct.NftTransfers); err != nil {
				return err
            }
        case "stx_received":
            if err := json.Unmarshal([]byte(v), &strct.StxReceived); err != nil {
				return err
            }
            stx_receivedReceived = true
        case "stx_sent":
            if err := json.Unmarshal([]byte(v), &strct.StxSent); err != nil {
				return err
            }
            stx_sentReceived = true
        case "stx_transfers":
            if err := json.Unmarshal([]byte(v), &strct.StxTransfers); err != nil {
				return err
            }
            stx_transfersReceived = true
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if stx_received (a required property) was received
    if !stx_receivedReceived {
		strct._stx_received_ValidationError = fmt.Errorf("\"StxReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stx_sent (a required property) was received
    if !stx_sentReceived {
		strct._stx_sent_ValidationError = fmt.Errorf("\"StxSent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if stx_transfers (a required property) was received
    if !stx_transfersReceived {
		strct._stx_transfers_ValidationError = fmt.Errorf("\"StxTransfers\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressTransactionWithTransfers) Validate() []error {
    var allErrors []error
    if strct._stx_received_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_received_ValidationError)
	}
    if strct._stx_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_sent_ValidationError)
	}
    if strct._stx_transfers_ValidationError != nil {
		allErrors = append(allErrors, strct._stx_transfers_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Memo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransferType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transfer_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transfer_type\": ")
	if tmp, err := json.Marshal(strct.TransferType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_index\": ")
	if tmp, err := json.Marshal(strct.TxIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) UnmarshalJSON(b []byte) error {
    amountReceived := false
    block_heightReceived := false
    memoReceived := false
    senderReceived := false
    transfer_typeReceived := false
    tx_idReceived := false
    tx_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
            memoReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        case "transfer_type":
            if err := json.Unmarshal([]byte(v), &strct.TransferType); err != nil {
				return err
            }
            transfer_typeReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "tx_index":
            if err := json.Unmarshal([]byte(v), &strct.TxIndex); err != nil {
				return err
            }
            tx_indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if memo (a required property) was received
    if !memoReceived {
		strct._memo_ValidationError = fmt.Errorf("\"Memo\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transfer_type (a required property) was received
    if !transfer_typeReceived {
		strct._transfer_type_ValidationError = fmt.Errorf("\"TransferType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_index (a required property) was received
    if !tx_indexReceived {
		strct._tx_index_ValidationError = fmt.Errorf("\"TxIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *AddressUnlockSchedule_InboundStxTransfer) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._memo_ValidationError != nil {
		allErrors = append(allErrors, strct._memo_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if strct._transfer_type_ValidationError != nil {
		allErrors = append(allErrors, strct._transfer_type_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._tx_index_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BaseTransaction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AnchorMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "anchor_mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"anchor_mode\": ")
	if tmp, err := json.Marshal(strct.AnchorMode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FeeRate" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "fee_rate" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fee_rate\": ")
	if tmp, err := json.Marshal(strct.FeeRate); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Nonce" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"nonce\": ")
	if tmp, err := json.Marshal(strct.Nonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PostConditionMode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "post_condition_mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"post_condition_mode\": ")
	if tmp, err := json.Marshal(strct.PostConditionMode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PostConditions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "post_conditions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"post_conditions\": ")
	if tmp, err := json.Marshal(strct.PostConditions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SenderAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sponsor_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsor_address\": ")
	if tmp, err := json.Marshal(strct.SponsorAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sponsor_nonce" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsor_nonce\": ")
	if tmp, err := json.Marshal(strct.SponsorNonce); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sponsored" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sponsored" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sponsored\": ")
	if tmp, err := json.Marshal(strct.Sponsored); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaseTransaction) UnmarshalJSON(b []byte) error {
    anchor_modeReceived := false
    fee_rateReceived := false
    nonceReceived := false
    post_condition_modeReceived := false
    post_conditionsReceived := false
    sender_addressReceived := false
    sponsoredReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "anchor_mode":
            if err := json.Unmarshal([]byte(v), &strct.AnchorMode); err != nil {
				return err
            }
            anchor_modeReceived = true
        case "fee_rate":
            if err := json.Unmarshal([]byte(v), &strct.FeeRate); err != nil {
				return err
            }
            fee_rateReceived = true
        case "nonce":
            if err := json.Unmarshal([]byte(v), &strct.Nonce); err != nil {
				return err
            }
            nonceReceived = true
        case "post_condition_mode":
            if err := json.Unmarshal([]byte(v), &strct.PostConditionMode); err != nil {
				return err
            }
            post_condition_modeReceived = true
        case "post_conditions":
            if err := json.Unmarshal([]byte(v), &strct.PostConditions); err != nil {
				return err
            }
            post_conditionsReceived = true
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
            sender_addressReceived = true
        case "sponsor_address":
            if err := json.Unmarshal([]byte(v), &strct.SponsorAddress); err != nil {
				return err
            }
        case "sponsor_nonce":
            if err := json.Unmarshal([]byte(v), &strct.SponsorNonce); err != nil {
				return err
            }
        case "sponsored":
            if err := json.Unmarshal([]byte(v), &strct.Sponsored); err != nil {
				return err
            }
            sponsoredReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if anchor_mode (a required property) was received
    if !anchor_modeReceived {
		strct._anchor_mode_ValidationError = fmt.Errorf("\"AnchorMode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if fee_rate (a required property) was received
    if !fee_rateReceived {
		strct._fee_rate_ValidationError = fmt.Errorf("\"FeeRate\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if nonce (a required property) was received
    if !nonceReceived {
		strct._nonce_ValidationError = fmt.Errorf("\"Nonce\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if post_condition_mode (a required property) was received
    if !post_condition_modeReceived {
		strct._post_condition_mode_ValidationError = fmt.Errorf("\"PostConditionMode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if post_conditions (a required property) was received
    if !post_conditionsReceived {
		strct._post_conditions_ValidationError = fmt.Errorf("\"PostConditions\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender_address (a required property) was received
    if !sender_addressReceived {
		strct._sender_address_ValidationError = fmt.Errorf("\"SenderAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sponsored (a required property) was received
    if !sponsoredReceived {
		strct._sponsored_ValidationError = fmt.Errorf("\"Sponsored\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BaseTransaction) Validate() []error {
    var allErrors []error
    if strct._anchor_mode_ValidationError != nil {
		allErrors = append(allErrors, strct._anchor_mode_ValidationError)
	}
    if strct._fee_rate_ValidationError != nil {
		allErrors = append(allErrors, strct._fee_rate_ValidationError)
	}
    if strct._nonce_ValidationError != nil {
		allErrors = append(allErrors, strct._nonce_ValidationError)
	}
    if strct._post_condition_mode_ValidationError != nil {
		allErrors = append(allErrors, strct._post_condition_mode_ValidationError)
	}
    if strct._post_conditions_ValidationError != nil {
		allErrors = append(allErrors, strct._post_conditions_ValidationError)
	}
    if strct._sender_address_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_address_ValidationError)
	}
    if strct._sponsored_ValidationError != nil {
		allErrors = append(allErrors, strct._sponsored_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockTimeIso" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_time_iso" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_time_iso\": ")
	if tmp, err := json.Marshal(strct.BurnBlockTimeIso); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostReadCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_read_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_read_count\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostReadCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostReadLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_read_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_read_length\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostReadLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostRuntime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_runtime" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_runtime\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostRuntime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostWriteCount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_write_count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_write_count\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostWriteCount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ExecutionCostWriteLength" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "execution_cost_write_length" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"execution_cost_write_length\": ")
	if tmp, err := json.Marshal(strct.ExecutionCostWriteLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Hash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hash\": ")
	if tmp, err := json.Marshal(strct.Hash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Height" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"height\": ")
	if tmp, err := json.Marshal(strct.Height); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblocksAccepted" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblocks_accepted" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblocks_accepted\": ")
	if tmp, err := json.Marshal(strct.MicroblocksAccepted); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblocksStreamed" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblocks_streamed" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblocks_streamed\": ")
	if tmp, err := json.Marshal(strct.MicroblocksStreamed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MinerTxid" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "miner_txid" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"miner_txid\": ")
	if tmp, err := json.Marshal(strct.MinerTxid); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentMicroblockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_microblock_hash\": ")
	if tmp, err := json.Marshal(strct.ParentMicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentMicroblockSequence" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.ParentMicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Txs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "txs" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txs\": ")
	if tmp, err := json.Marshal(strct.Txs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) UnmarshalJSON(b []byte) error {
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    burn_block_timeReceived := false
    burn_block_time_isoReceived := false
    canonicalReceived := false
    execution_cost_read_countReceived := false
    execution_cost_read_lengthReceived := false
    execution_cost_runtimeReceived := false
    execution_cost_write_countReceived := false
    execution_cost_write_lengthReceived := false
    hashReceived := false
    heightReceived := false
    microblocks_acceptedReceived := false
    microblocks_streamedReceived := false
    miner_txidReceived := false
    parent_block_hashReceived := false
    parent_microblock_hashReceived := false
    parent_microblock_sequenceReceived := false
    txsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTime); err != nil {
				return err
            }
            burn_block_timeReceived = true
        case "burn_block_time_iso":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockTimeIso); err != nil {
				return err
            }
            burn_block_time_isoReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "execution_cost_read_count":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostReadCount); err != nil {
				return err
            }
            execution_cost_read_countReceived = true
        case "execution_cost_read_length":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostReadLength); err != nil {
				return err
            }
            execution_cost_read_lengthReceived = true
        case "execution_cost_runtime":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostRuntime); err != nil {
				return err
            }
            execution_cost_runtimeReceived = true
        case "execution_cost_write_count":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostWriteCount); err != nil {
				return err
            }
            execution_cost_write_countReceived = true
        case "execution_cost_write_length":
            if err := json.Unmarshal([]byte(v), &strct.ExecutionCostWriteLength); err != nil {
				return err
            }
            execution_cost_write_lengthReceived = true
        case "hash":
            if err := json.Unmarshal([]byte(v), &strct.Hash); err != nil {
				return err
            }
            hashReceived = true
        case "height":
            if err := json.Unmarshal([]byte(v), &strct.Height); err != nil {
				return err
            }
            heightReceived = true
        case "microblocks_accepted":
            if err := json.Unmarshal([]byte(v), &strct.MicroblocksAccepted); err != nil {
				return err
            }
            microblocks_acceptedReceived = true
        case "microblocks_streamed":
            if err := json.Unmarshal([]byte(v), &strct.MicroblocksStreamed); err != nil {
				return err
            }
            microblocks_streamedReceived = true
        case "miner_txid":
            if err := json.Unmarshal([]byte(v), &strct.MinerTxid); err != nil {
				return err
            }
            miner_txidReceived = true
        case "parent_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHash); err != nil {
				return err
            }
            parent_block_hashReceived = true
        case "parent_microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentMicroblockHash); err != nil {
				return err
            }
            parent_microblock_hashReceived = true
        case "parent_microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.ParentMicroblockSequence); err != nil {
				return err
            }
            parent_microblock_sequenceReceived = true
        case "txs":
            if err := json.Unmarshal([]byte(v), &strct.Txs); err != nil {
				return err
            }
            txsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_time (a required property) was received
    if !burn_block_timeReceived {
		strct._burn_block_time_ValidationError = fmt.Errorf("\"BurnBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_time_iso (a required property) was received
    if !burn_block_time_isoReceived {
		strct._burn_block_time_iso_ValidationError = fmt.Errorf("\"BurnBlockTimeIso\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_read_count (a required property) was received
    if !execution_cost_read_countReceived {
		strct._execution_cost_read_count_ValidationError = fmt.Errorf("\"ExecutionCostReadCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_read_length (a required property) was received
    if !execution_cost_read_lengthReceived {
		strct._execution_cost_read_length_ValidationError = fmt.Errorf("\"ExecutionCostReadLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_runtime (a required property) was received
    if !execution_cost_runtimeReceived {
		strct._execution_cost_runtime_ValidationError = fmt.Errorf("\"ExecutionCostRuntime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_write_count (a required property) was received
    if !execution_cost_write_countReceived {
		strct._execution_cost_write_count_ValidationError = fmt.Errorf("\"ExecutionCostWriteCount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if execution_cost_write_length (a required property) was received
    if !execution_cost_write_lengthReceived {
		strct._execution_cost_write_length_ValidationError = fmt.Errorf("\"ExecutionCostWriteLength\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if hash (a required property) was received
    if !hashReceived {
		strct._hash_ValidationError = fmt.Errorf("\"Hash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if height (a required property) was received
    if !heightReceived {
		strct._height_ValidationError = fmt.Errorf("\"Height\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblocks_accepted (a required property) was received
    if !microblocks_acceptedReceived {
		strct._microblocks_accepted_ValidationError = fmt.Errorf("\"MicroblocksAccepted\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblocks_streamed (a required property) was received
    if !microblocks_streamedReceived {
		strct._microblocks_streamed_ValidationError = fmt.Errorf("\"MicroblocksStreamed\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if miner_txid (a required property) was received
    if !miner_txidReceived {
		strct._miner_txid_ValidationError = fmt.Errorf("\"MinerTxid\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_hash (a required property) was received
    if !parent_block_hashReceived {
		strct._parent_block_hash_ValidationError = fmt.Errorf("\"ParentBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_microblock_hash (a required property) was received
    if !parent_microblock_hashReceived {
		strct._parent_microblock_hash_ValidationError = fmt.Errorf("\"ParentMicroblockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_microblock_sequence (a required property) was received
    if !parent_microblock_sequenceReceived {
		strct._parent_microblock_sequence_ValidationError = fmt.Errorf("\"ParentMicroblockSequence\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if txs (a required property) was received
    if !txsReceived {
		strct._txs_ValidationError = fmt.Errorf("\"Txs\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Block_OtherTransactionIdentifier_RosettaBlockIdentifierHash_TransactionIdentifier) Validate() []error {
    var allErrors []error
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._burn_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_time_ValidationError)
	}
    if strct._burn_block_time_iso_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_time_iso_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._execution_cost_read_count_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_read_count_ValidationError)
	}
    if strct._execution_cost_read_length_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_read_length_ValidationError)
	}
    if strct._execution_cost_runtime_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_runtime_ValidationError)
	}
    if strct._execution_cost_write_count_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_write_count_ValidationError)
	}
    if strct._execution_cost_write_length_ValidationError != nil {
		allErrors = append(allErrors, strct._execution_cost_write_length_ValidationError)
	}
    if strct._hash_ValidationError != nil {
		allErrors = append(allErrors, strct._hash_ValidationError)
	}
    if strct._height_ValidationError != nil {
		allErrors = append(allErrors, strct._height_ValidationError)
	}
    if strct._microblocks_accepted_ValidationError != nil {
		allErrors = append(allErrors, strct._microblocks_accepted_ValidationError)
	}
    if strct._microblocks_streamed_ValidationError != nil {
		allErrors = append(allErrors, strct._microblocks_streamed_ValidationError)
	}
    if strct._miner_txid_ValidationError != nil {
		allErrors = append(allErrors, strct._miner_txid_ValidationError)
	}
    if strct._parent_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_hash_ValidationError)
	}
    if strct._parent_microblock_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_microblock_hash_ValidationError)
	}
    if strct._parent_microblock_sequence_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_microblock_sequence_ValidationError)
	}
    if strct._txs_ValidationError != nil {
		allErrors = append(allErrors, strct._txs_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BurnchainRewardSlotHolder) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SlotIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "slot_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"slot_index\": ")
	if tmp, err := json.Marshal(strct.SlotIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BurnchainRewardSlotHolder) UnmarshalJSON(b []byte) error {
    addressReceived := false
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    canonicalReceived := false
    slot_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "slot_index":
            if err := json.Unmarshal([]byte(v), &strct.SlotIndex); err != nil {
				return err
            }
            slot_indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if slot_index (a required property) was received
    if !slot_indexReceived {
		strct._slot_index_ValidationError = fmt.Errorf("\"SlotIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BurnchainRewardSlotHolder) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._slot_index_ValidationError != nil {
		allErrors = append(allErrors, strct._slot_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BurnAmount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_amount\": ")
	if tmp, err := json.Marshal(strct.BurnAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardAmount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_amount\": ")
	if tmp, err := json.Marshal(strct.RewardAmount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_index\": ")
	if tmp, err := json.Marshal(strct.RewardIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RewardRecipient" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "reward_recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reward_recipient\": ")
	if tmp, err := json.Marshal(strct.RewardRecipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) UnmarshalJSON(b []byte) error {
    burn_amountReceived := false
    burn_block_hashReceived := false
    burn_block_heightReceived := false
    canonicalReceived := false
    reward_amountReceived := false
    reward_indexReceived := false
    reward_recipientReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "burn_amount":
            if err := json.Unmarshal([]byte(v), &strct.BurnAmount); err != nil {
				return err
            }
            burn_amountReceived = true
        case "burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHash); err != nil {
				return err
            }
            burn_block_hashReceived = true
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
            burn_block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "reward_amount":
            if err := json.Unmarshal([]byte(v), &strct.RewardAmount); err != nil {
				return err
            }
            reward_amountReceived = true
        case "reward_index":
            if err := json.Unmarshal([]byte(v), &strct.RewardIndex); err != nil {
				return err
            }
            reward_indexReceived = true
        case "reward_recipient":
            if err := json.Unmarshal([]byte(v), &strct.RewardRecipient); err != nil {
				return err
            }
            reward_recipientReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if burn_amount (a required property) was received
    if !burn_amountReceived {
		strct._burn_amount_ValidationError = fmt.Errorf("\"BurnAmount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_hash (a required property) was received
    if !burn_block_hashReceived {
		strct._burn_block_hash_ValidationError = fmt.Errorf("\"BurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burn_block_height (a required property) was received
    if !burn_block_heightReceived {
		strct._burn_block_height_ValidationError = fmt.Errorf("\"BurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_amount (a required property) was received
    if !reward_amountReceived {
		strct._reward_amount_ValidationError = fmt.Errorf("\"RewardAmount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_index (a required property) was received
    if !reward_indexReceived {
		strct._reward_index_ValidationError = fmt.Errorf("\"RewardIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if reward_recipient (a required property) was received
    if !reward_recipientReceived {
		strct._reward_recipient_ValidationError = fmt.Errorf("\"RewardRecipient\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *BurnchainReward_BurnchainRewardsTotal) Validate() []error {
    var allErrors []error
    if strct._burn_amount_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_amount_ValidationError)
	}
    if strct._burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_hash_ValidationError)
	}
    if strct._burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burn_block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._reward_amount_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_amount_ValidationError)
	}
    if strct._reward_index_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_index_ValidationError)
	}
    if strct._reward_recipient_ValidationError != nil {
		allErrors = append(allErrors, strct._reward_recipient_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ChainTip) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_hash\": ")
	if tmp, err := json.Marshal(strct.BlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "IndexBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index_block_hash\": ")
	if tmp, err := json.Marshal(strct.IndexBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.MicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ChainTip) UnmarshalJSON(b []byte) error {
    block_hashReceived := false
    block_heightReceived := false
    index_block_hashReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BlockHash); err != nil {
				return err
            }
            block_hashReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "index_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.IndexBlockHash); err != nil {
				return err
            }
            index_block_hashReceived = true
        case "microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHash); err != nil {
				return err
            }
        case "microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockSequence); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_hash (a required property) was received
    if !block_hashReceived {
		strct._block_hash_ValidationError = fmt.Errorf("\"BlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if index_block_hash (a required property) was received
    if !index_block_hashReceived {
		strct._index_block_hash_ValidationError = fmt.Errorf("\"IndexBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ChainTip) Validate() []error {
    var allErrors []error
    if strct._block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._block_hash_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._index_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._index_block_hash_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Identifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinIdentifier) UnmarshalJSON(b []byte) error {
    identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
				return err
            }
            identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if identifier (a required property) was received
    if !identifierReceived {
		strct._identifier_ValidationError = fmt.Errorf("\"Identifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinIdentifier) Validate() []error {
    var allErrors []error
    if strct._identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinbasePayload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Data" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "data" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"data\": ")
	if tmp, err := json.Marshal(strct.Data); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinbasePayload) UnmarshalJSON(b []byte) error {
    dataReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "data":
            if err := json.Unmarshal([]byte(v), &strct.Data); err != nil {
				return err
            }
            dataReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if data (a required property) was received
    if !dataReceived {
		strct._data_ValidationError = fmt.Errorf("\"Data\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinbasePayload) Validate() []error {
    var allErrors []error
    if strct._data_ValidationError != nil {
		allErrors = append(allErrors, strct._data_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *CoinbaseTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CoinbasePayload" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coinbase_payload" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coinbase_payload\": ")
	if tmp, err := json.Marshal(strct.CoinbasePayload); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CoinbaseTransactionMetadata) UnmarshalJSON(b []byte) error {
    coinbase_payloadReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "coinbase_payload":
            if err := json.Unmarshal([]byte(v), &strct.CoinbasePayload); err != nil {
				return err
            }
            coinbase_payloadReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if coinbase_payload (a required property) was received
    if !coinbase_payloadReceived {
		strct._coinbase_payload_ValidationError = fmt.Errorf("\"CoinbasePayload\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *CoinbaseTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._coinbase_payload_ValidationError != nil {
		allErrors = append(allErrors, strct._coinbase_payload_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractCall) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_id\": ")
	if tmp, err := json.Marshal(strct.ContractId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "function_args" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_args\": ")
	if tmp, err := json.Marshal(strct.FunctionArgs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FunctionName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "function_name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_name\": ")
	if tmp, err := json.Marshal(strct.FunctionName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "FunctionSignature" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "function_signature" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"function_signature\": ")
	if tmp, err := json.Marshal(strct.FunctionSignature); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractCall) UnmarshalJSON(b []byte) error {
    contract_idReceived := false
    function_nameReceived := false
    function_signatureReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_id":
            if err := json.Unmarshal([]byte(v), &strct.ContractId); err != nil {
				return err
            }
            contract_idReceived = true
        case "function_args":
            if err := json.Unmarshal([]byte(v), &strct.FunctionArgs); err != nil {
				return err
            }
        case "function_name":
            if err := json.Unmarshal([]byte(v), &strct.FunctionName); err != nil {
				return err
            }
            function_nameReceived = true
        case "function_signature":
            if err := json.Unmarshal([]byte(v), &strct.FunctionSignature); err != nil {
				return err
            }
            function_signatureReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_id (a required property) was received
    if !contract_idReceived {
		strct._contract_id_ValidationError = fmt.Errorf("\"ContractId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if function_name (a required property) was received
    if !function_nameReceived {
		strct._function_name_ValidationError = fmt.Errorf("\"FunctionName\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if function_signature (a required property) was received
    if !function_signatureReceived {
		strct._function_signature_ValidationError = fmt.Errorf("\"FunctionSignature\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractCall) Validate() []error {
    var allErrors []error
    if strct._contract_id_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_id_ValidationError)
	}
    if strct._function_name_ValidationError != nil {
		allErrors = append(allErrors, strct._function_name_ValidationError)
	}
    if strct._function_signature_ValidationError != nil {
		allErrors = append(allErrors, strct._function_signature_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ContractCallTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractCall" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_call" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_call\": ")
	if tmp, err := json.Marshal(strct.ContractCall); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ContractCallTransactionMetadata) UnmarshalJSON(b []byte) error {
    contract_callReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_call":
            if err := json.Unmarshal([]byte(v), &strct.ContractCall); err != nil {
				return err
            }
            contract_callReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_call (a required property) was received
    if !contract_callReceived {
		strct._contract_call_ValidationError = fmt.Errorf("\"ContractCall\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ContractCallTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._contract_call_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_call_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FtBalance_StxBalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Balance" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance\": ")
	if tmp, err := json.Marshal(strct.Balance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnchainLockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burnchain_lock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burnchain_lock_height\": ")
	if tmp, err := json.Marshal(strct.BurnchainLockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BurnchainUnlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "burnchain_unlock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burnchain_unlock_height\": ")
	if tmp, err := json.Marshal(strct.BurnchainUnlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "lock_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"lock_height\": ")
	if tmp, err := json.Marshal(strct.LockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "LockTxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "lock_tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"lock_tx_id\": ")
	if tmp, err := json.Marshal(strct.LockTxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Locked" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "locked" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"locked\": ")
	if tmp, err := json.Marshal(strct.Locked); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalFeesSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_fees_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_fees_sent\": ")
	if tmp, err := json.Marshal(strct.TotalFeesSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalMinerRewardsReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_miner_rewards_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_miner_rewards_received\": ")
	if tmp, err := json.Marshal(strct.TotalMinerRewardsReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_received\": ")
	if tmp, err := json.Marshal(strct.TotalReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_sent\": ")
	if tmp, err := json.Marshal(strct.TotalSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FtBalance_StxBalance) UnmarshalJSON(b []byte) error {
    balanceReceived := false
    burnchain_lock_heightReceived := false
    burnchain_unlock_heightReceived := false
    lock_heightReceived := false
    lock_tx_idReceived := false
    lockedReceived := false
    total_fees_sentReceived := false
    total_miner_rewards_receivedReceived := false
    total_receivedReceived := false
    total_sentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "balance":
            if err := json.Unmarshal([]byte(v), &strct.Balance); err != nil {
				return err
            }
            balanceReceived = true
        case "burnchain_lock_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnchainLockHeight); err != nil {
				return err
            }
            burnchain_lock_heightReceived = true
        case "burnchain_unlock_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnchainUnlockHeight); err != nil {
				return err
            }
            burnchain_unlock_heightReceived = true
        case "lock_height":
            if err := json.Unmarshal([]byte(v), &strct.LockHeight); err != nil {
				return err
            }
            lock_heightReceived = true
        case "lock_tx_id":
            if err := json.Unmarshal([]byte(v), &strct.LockTxId); err != nil {
				return err
            }
            lock_tx_idReceived = true
        case "locked":
            if err := json.Unmarshal([]byte(v), &strct.Locked); err != nil {
				return err
            }
            lockedReceived = true
        case "total_fees_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalFeesSent); err != nil {
				return err
            }
            total_fees_sentReceived = true
        case "total_miner_rewards_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalMinerRewardsReceived); err != nil {
				return err
            }
            total_miner_rewards_receivedReceived = true
        case "total_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalReceived); err != nil {
				return err
            }
            total_receivedReceived = true
        case "total_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalSent); err != nil {
				return err
            }
            total_sentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if balance (a required property) was received
    if !balanceReceived {
		strct._balance_ValidationError = fmt.Errorf("\"Balance\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burnchain_lock_height (a required property) was received
    if !burnchain_lock_heightReceived {
		strct._burnchain_lock_height_ValidationError = fmt.Errorf("\"BurnchainLockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if burnchain_unlock_height (a required property) was received
    if !burnchain_unlock_heightReceived {
		strct._burnchain_unlock_height_ValidationError = fmt.Errorf("\"BurnchainUnlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if lock_height (a required property) was received
    if !lock_heightReceived {
		strct._lock_height_ValidationError = fmt.Errorf("\"LockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if lock_tx_id (a required property) was received
    if !lock_tx_idReceived {
		strct._lock_tx_id_ValidationError = fmt.Errorf("\"LockTxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if locked (a required property) was received
    if !lockedReceived {
		strct._locked_ValidationError = fmt.Errorf("\"Locked\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_fees_sent (a required property) was received
    if !total_fees_sentReceived {
		strct._total_fees_sent_ValidationError = fmt.Errorf("\"TotalFeesSent\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_miner_rewards_received (a required property) was received
    if !total_miner_rewards_receivedReceived {
		strct._total_miner_rewards_received_ValidationError = fmt.Errorf("\"TotalMinerRewardsReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_received (a required property) was received
    if !total_receivedReceived {
		strct._total_received_ValidationError = fmt.Errorf("\"TotalReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_sent (a required property) was received
    if !total_sentReceived {
		strct._total_sent_ValidationError = fmt.Errorf("\"TotalSent\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FtBalance_StxBalance) Validate() []error {
    var allErrors []error
    if strct._balance_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_ValidationError)
	}
    if strct._burnchain_lock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burnchain_lock_height_ValidationError)
	}
    if strct._burnchain_unlock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._burnchain_unlock_height_ValidationError)
	}
    if strct._lock_height_ValidationError != nil {
		allErrors = append(allErrors, strct._lock_height_ValidationError)
	}
    if strct._lock_tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._lock_tx_id_ValidationError)
	}
    if strct._locked_ValidationError != nil {
		allErrors = append(allErrors, strct._locked_ValidationError)
	}
    if strct._total_fees_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_fees_sent_ValidationError)
	}
    if strct._total_miner_rewards_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_miner_rewards_received_ValidationError)
	}
    if strct._total_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_received_ValidationError)
	}
    if strct._total_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_sent_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FtTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FtTransfersItems) UnmarshalJSON(b []byte) error {
    amountReceived := false
    asset_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FtTransfersItems) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FunctionArgsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex\": ")
	if tmp, err := json.Marshal(strct.Hex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Repr" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "repr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"repr\": ")
	if tmp, err := json.Marshal(strct.Repr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FunctionArgsItems) UnmarshalJSON(b []byte) error {
    hexReceived := false
    nameReceived := false
    reprReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex":
            if err := json.Unmarshal([]byte(v), &strct.Hex); err != nil {
				return err
            }
            hexReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
            }
            nameReceived = true
        case "repr":
            if err := json.Unmarshal([]byte(v), &strct.Repr); err != nil {
				return err
            }
            reprReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex (a required property) was received
    if !hexReceived {
		strct._hex_ValidationError = fmt.Errorf("\"Hex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if name (a required property) was received
    if !nameReceived {
		strct._name_ValidationError = fmt.Errorf("\"Name\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if repr (a required property) was received
    if !reprReceived {
		strct._repr_ValidationError = fmt.Errorf("\"Repr\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if type (a required property) was received
    if !typeReceived {
		strct._type_ValidationError = fmt.Errorf("\"Type\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FunctionArgsItems) Validate() []error {
    var allErrors []error
    if strct._hex_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_ValidationError)
	}
    if strct._name_ValidationError != nil {
		allErrors = append(allErrors, strct._name_ValidationError)
	}
    if strct._repr_ValidationError != nil {
		allErrors = append(allErrors, strct._repr_ValidationError)
	}
    if strct._type_ValidationError != nil {
		allErrors = append(allErrors, strct._type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Decimals" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ImageCanonicalUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "image_canonical_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"image_canonical_uri\": ")
	if tmp, err := json.Marshal(strct.ImageCanonicalUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ImageUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "image_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"image_uri\": ")
	if tmp, err := json.Marshal(strct.ImageUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SenderAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Symbol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TokenUri" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "token_uri" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_uri\": ")
	if tmp, err := json.Marshal(strct.TokenUri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) UnmarshalJSON(b []byte) error {
    decimalsReceived := false
    descriptionReceived := false
    image_canonical_uriReceived := false
    image_uriReceived := false
    nameReceived := false
    sender_addressReceived := false
    symbolReceived := false
    token_uriReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
            decimalsReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
            }
            descriptionReceived = true
        case "image_canonical_uri":
            if err := json.Unmarshal([]byte(v), &strct.ImageCanonicalUri); err != nil {
				return err
            }
            image_canonical_uriReceived = true
        case "image_uri":
            if err := json.Unmarshal([]byte(v), &strct.ImageUri); err != nil {
				return err
            }
            image_uriReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
            }
            nameReceived = true
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
            sender_addressReceived = true
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
            symbolReceived = true
        case "token_uri":
            if err := json.Unmarshal([]byte(v), &strct.TokenUri); err != nil {
				return err
            }
            token_uriReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if decimals (a required property) was received
    if !decimalsReceived {
		strct._decimals_ValidationError = fmt.Errorf("\"Decimals\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if description (a required property) was received
    if !descriptionReceived {
		strct._description_ValidationError = fmt.Errorf("\"Description\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if image_canonical_uri (a required property) was received
    if !image_canonical_uriReceived {
		strct._image_canonical_uri_ValidationError = fmt.Errorf("\"ImageCanonicalUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if image_uri (a required property) was received
    if !image_uriReceived {
		strct._image_uri_ValidationError = fmt.Errorf("\"ImageUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if name (a required property) was received
    if !nameReceived {
		strct._name_ValidationError = fmt.Errorf("\"Name\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender_address (a required property) was received
    if !sender_addressReceived {
		strct._sender_address_ValidationError = fmt.Errorf("\"SenderAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if symbol (a required property) was received
    if !symbolReceived {
		strct._symbol_ValidationError = fmt.Errorf("\"Symbol\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if token_uri (a required property) was received
    if !token_uriReceived {
		strct._token_uri_ValidationError = fmt.Errorf("\"TokenUri\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *FungibleTokenMetadata_NonFungibleTokenMetadata) Validate() []error {
    var allErrors []error
    if strct._decimals_ValidationError != nil {
		allErrors = append(allErrors, strct._decimals_ValidationError)
	}
    if strct._description_ValidationError != nil {
		allErrors = append(allErrors, strct._description_ValidationError)
	}
    if strct._image_canonical_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._image_canonical_uri_ValidationError)
	}
    if strct._image_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._image_uri_ValidationError)
	}
    if strct._name_ValidationError != nil {
		allErrors = append(allErrors, strct._name_ValidationError)
	}
    if strct._sender_address_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_address_ValidationError)
	}
    if strct._symbol_ValidationError != nil {
		allErrors = append(allErrors, strct._symbol_ValidationError)
	}
    if strct._token_uri_ValidationError != nil {
		allErrors = append(allErrors, strct._token_uri_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Code" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"code\": ")
	if tmp, err := json.Marshal(strct.Code); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "details" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"details\": ")
	if tmp, err := json.Marshal(strct.Details); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Message" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "message" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"message\": ")
	if tmp, err := json.Marshal(strct.Message); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Retriable" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "retriable" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"retriable\": ")
	if tmp, err := json.Marshal(strct.Retriable); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails) UnmarshalJSON(b []byte) error {
    codeReceived := false
    messageReceived := false
    retriableReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "code":
            if err := json.Unmarshal([]byte(v), &strct.Code); err != nil {
				return err
            }
            codeReceived = true
        case "details":
            if err := json.Unmarshal([]byte(v), &strct.Details); err != nil {
				return err
            }
        case "message":
            if err := json.Unmarshal([]byte(v), &strct.Message); err != nil {
				return err
            }
            messageReceived = true
        case "retriable":
            if err := json.Unmarshal([]byte(v), &strct.Retriable); err != nil {
				return err
            }
            retriableReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if code (a required property) was received
    if !codeReceived {
		strct._code_ValidationError = fmt.Errorf("\"Code\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if message (a required property) was received
    if !messageReceived {
		strct._message_ValidationError = fmt.Errorf("\"Message\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if retriable (a required property) was received
    if !retriableReceived {
		strct._retriable_ValidationError = fmt.Errorf("\"Retriable\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *MempoolCoinbaseTransaction_RosettaError_RosettaErrorNoDetails) Validate() []error {
    var allErrors []error
    if strct._code_ValidationError != nil {
		allErrors = append(allErrors, strct._code_ValidationError)
	}
    if strct._message_ValidationError != nil {
		allErrors = append(allErrors, strct._message_ValidationError)
	}
    if strct._retriable_ValidationError != nil {
		allErrors = append(allErrors, strct._retriable_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Metadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Difficulty" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "difficulty" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"difficulty\": ")
	if tmp, err := json.Marshal(strct.Difficulty); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionsRoot" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transactions_root" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transactions_root\": ")
	if tmp, err := json.Marshal(strct.TransactionsRoot); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata) UnmarshalJSON(b []byte) error {
    difficultyReceived := false
    transactions_rootReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "difficulty":
            if err := json.Unmarshal([]byte(v), &strct.Difficulty); err != nil {
				return err
            }
            difficultyReceived = true
        case "transactions_root":
            if err := json.Unmarshal([]byte(v), &strct.TransactionsRoot); err != nil {
				return err
            }
            transactions_rootReceived = true
        }
    }
    // check if difficulty (a required property) was received
    if !difficultyReceived {
		strct._difficulty_ValidationError = fmt.Errorf("\"Difficulty\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transactions_root (a required property) was received
    if !transactions_rootReceived {
		strct._transactions_root_ValidationError = fmt.Errorf("\"TransactionsRoot\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Metadata) Validate() []error {
    var allErrors []error
    if strct._difficulty_ValidationError != nil {
		allErrors = append(allErrors, strct._difficulty_ValidationError)
	}
    if strct._transactions_root_ValidationError != nil {
		allErrors = append(allErrors, strct._transactions_root_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Metadata_8987256d8e) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Producer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "producer" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"producer\": ")
	if tmp, err := json.Marshal(strct.Producer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Metadata_8987256d8e) UnmarshalJSON(b []byte) error {
    producerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "producer":
            if err := json.Unmarshal([]byte(v), &strct.Producer); err != nil {
				return err
            }
            producerReceived = true
        }
    }
    // check if producer (a required property) was received
    if !producerReceived {
		strct._producer_ValidationError = fmt.Errorf("\"Producer\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Metadata_8987256d8e) Validate() []error {
    var allErrors []error
    if strct._producer_ValidationError != nil {
		allErrors = append(allErrors, strct._producer_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Microblock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_hash\": ")
	if tmp, err := json.Marshal(strct.BlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockCanonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_canonical\": ")
	if tmp, err := json.Marshal(strct.MicroblockCanonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockParentHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_parent_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_parent_hash\": ")
	if tmp, err := json.Marshal(strct.MicroblockParentHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockSequence" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_sequence" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_sequence\": ")
	if tmp, err := json.Marshal(strct.MicroblockSequence); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_height\": ")
	if tmp, err := json.Marshal(strct.ParentBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockHash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_hash\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockHash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_height\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_time\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBurnBlockTimeIso" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_burn_block_time_iso" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_burn_block_time_iso\": ")
	if tmp, err := json.Marshal(strct.ParentBurnBlockTimeIso); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Txs" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "txs" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"txs\": ")
	if tmp, err := json.Marshal(strct.Txs); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Microblock) UnmarshalJSON(b []byte) error {
    block_hashReceived := false
    block_heightReceived := false
    canonicalReceived := false
    microblock_canonicalReceived := false
    microblock_hashReceived := false
    microblock_parent_hashReceived := false
    microblock_sequenceReceived := false
    parent_block_hashReceived := false
    parent_block_heightReceived := false
    parent_burn_block_hashReceived := false
    parent_burn_block_heightReceived := false
    parent_burn_block_timeReceived := false
    parent_burn_block_time_isoReceived := false
    txsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_hash":
            if err := json.Unmarshal([]byte(v), &strct.BlockHash); err != nil {
				return err
            }
            block_hashReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "microblock_canonical":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockCanonical); err != nil {
				return err
            }
            microblock_canonicalReceived = true
        case "microblock_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHash); err != nil {
				return err
            }
            microblock_hashReceived = true
        case "microblock_parent_hash":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockParentHash); err != nil {
				return err
            }
            microblock_parent_hashReceived = true
        case "microblock_sequence":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockSequence); err != nil {
				return err
            }
            microblock_sequenceReceived = true
        case "parent_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHash); err != nil {
				return err
            }
            parent_block_hashReceived = true
        case "parent_block_height":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockHeight); err != nil {
				return err
            }
            parent_block_heightReceived = true
        case "parent_burn_block_hash":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockHash); err != nil {
				return err
            }
            parent_burn_block_hashReceived = true
        case "parent_burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockHeight); err != nil {
				return err
            }
            parent_burn_block_heightReceived = true
        case "parent_burn_block_time":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockTime); err != nil {
				return err
            }
            parent_burn_block_timeReceived = true
        case "parent_burn_block_time_iso":
            if err := json.Unmarshal([]byte(v), &strct.ParentBurnBlockTimeIso); err != nil {
				return err
            }
            parent_burn_block_time_isoReceived = true
        case "txs":
            if err := json.Unmarshal([]byte(v), &strct.Txs); err != nil {
				return err
            }
            txsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_hash (a required property) was received
    if !block_hashReceived {
		strct._block_hash_ValidationError = fmt.Errorf("\"BlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_canonical (a required property) was received
    if !microblock_canonicalReceived {
		strct._microblock_canonical_ValidationError = fmt.Errorf("\"MicroblockCanonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_hash (a required property) was received
    if !microblock_hashReceived {
		strct._microblock_hash_ValidationError = fmt.Errorf("\"MicroblockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_parent_hash (a required property) was received
    if !microblock_parent_hashReceived {
		strct._microblock_parent_hash_ValidationError = fmt.Errorf("\"MicroblockParentHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_sequence (a required property) was received
    if !microblock_sequenceReceived {
		strct._microblock_sequence_ValidationError = fmt.Errorf("\"MicroblockSequence\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_hash (a required property) was received
    if !parent_block_hashReceived {
		strct._parent_block_hash_ValidationError = fmt.Errorf("\"ParentBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_height (a required property) was received
    if !parent_block_heightReceived {
		strct._parent_block_height_ValidationError = fmt.Errorf("\"ParentBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_hash (a required property) was received
    if !parent_burn_block_hashReceived {
		strct._parent_burn_block_hash_ValidationError = fmt.Errorf("\"ParentBurnBlockHash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_height (a required property) was received
    if !parent_burn_block_heightReceived {
		strct._parent_burn_block_height_ValidationError = fmt.Errorf("\"ParentBurnBlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_time (a required property) was received
    if !parent_burn_block_timeReceived {
		strct._parent_burn_block_time_ValidationError = fmt.Errorf("\"ParentBurnBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_burn_block_time_iso (a required property) was received
    if !parent_burn_block_time_isoReceived {
		strct._parent_burn_block_time_iso_ValidationError = fmt.Errorf("\"ParentBurnBlockTimeIso\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if txs (a required property) was received
    if !txsReceived {
		strct._txs_ValidationError = fmt.Errorf("\"Txs\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Microblock) Validate() []error {
    var allErrors []error
    if strct._block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._block_hash_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._microblock_canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_canonical_ValidationError)
	}
    if strct._microblock_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_hash_ValidationError)
	}
    if strct._microblock_parent_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_parent_hash_ValidationError)
	}
    if strct._microblock_sequence_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_sequence_ValidationError)
	}
    if strct._parent_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_hash_ValidationError)
	}
    if strct._parent_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_height_ValidationError)
	}
    if strct._parent_burn_block_hash_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_hash_ValidationError)
	}
    if strct._parent_burn_block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_height_ValidationError)
	}
    if strct._parent_burn_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_time_ValidationError)
	}
    if strct._parent_burn_block_time_iso_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_burn_block_time_iso_ValidationError)
	}
    if strct._txs_ValidationError != nil {
		allErrors = append(allErrors, strct._txs_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NetworkIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Blockchain" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "blockchain" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"blockchain\": ")
	if tmp, err := json.Marshal(strct.Blockchain); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Network" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network\": ")
	if tmp, err := json.Marshal(strct.Network); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sub_network_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sub_network_identifier\": ")
	if tmp, err := json.Marshal(strct.SubNetworkIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkIdentifier) UnmarshalJSON(b []byte) error {
    blockchainReceived := false
    networkReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "blockchain":
            if err := json.Unmarshal([]byte(v), &strct.Blockchain); err != nil {
				return err
            }
            blockchainReceived = true
        case "network":
            if err := json.Unmarshal([]byte(v), &strct.Network); err != nil {
				return err
            }
            networkReceived = true
        case "sub_network_identifier":
            if err := json.Unmarshal([]byte(v), &strct.SubNetworkIdentifier); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if blockchain (a required property) was received
    if !blockchainReceived {
		strct._blockchain_ValidationError = fmt.Errorf("\"Blockchain\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if network (a required property) was received
    if !networkReceived {
		strct._network_ValidationError = fmt.Errorf("\"Network\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NetworkIdentifier) Validate() []error {
    var allErrors []error
    if strct._blockchain_ValidationError != nil {
		allErrors = append(allErrors, strct._blockchain_ValidationError)
	}
    if strct._network_ValidationError != nil {
		allErrors = append(allErrors, strct._network_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftBalance) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Count" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "count" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalReceived" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_received" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_received\": ")
	if tmp, err := json.Marshal(strct.TotalReceived); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TotalSent" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "total_sent" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"total_sent\": ")
	if tmp, err := json.Marshal(strct.TotalSent); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftBalance) UnmarshalJSON(b []byte) error {
    countReceived := false
    total_receivedReceived := false
    total_sentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "count":
            if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
				return err
            }
            countReceived = true
        case "total_received":
            if err := json.Unmarshal([]byte(v), &strct.TotalReceived); err != nil {
				return err
            }
            total_receivedReceived = true
        case "total_sent":
            if err := json.Unmarshal([]byte(v), &strct.TotalSent); err != nil {
				return err
            }
            total_sentReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if count (a required property) was received
    if !countReceived {
		strct._count_ValidationError = fmt.Errorf("\"Count\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_received (a required property) was received
    if !total_receivedReceived {
		strct._total_received_ValidationError = fmt.Errorf("\"TotalReceived\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if total_sent (a required property) was received
    if !total_sentReceived {
		strct._total_sent_ValidationError = fmt.Errorf("\"TotalSent\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftBalance) Validate() []error {
    var allErrors []error
    if strct._count_ValidationError != nil {
		allErrors = append(allErrors, strct._count_ValidationError)
	}
    if strct._total_received_ValidationError != nil {
		allErrors = append(allErrors, strct._total_received_ValidationError)
	}
    if strct._total_sent_ValidationError != nil {
		allErrors = append(allErrors, strct._total_sent_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Recipient" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    block_heightReceived := false
    recipientReceived := false
    senderReceived := false
    tx_idReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
            recipientReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if recipient (a required property) was received
    if !recipientReceived {
		strct._recipient_ValidationError = fmt.Errorf("\"Recipient\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftEvent_NonFungibleTokenHoldingWithTxId) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._recipient_ValidationError != nil {
		allErrors = append(allErrors, strct._recipient_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NftTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NftTransfersItems) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NftTransfersItems) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetEventType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) UnmarshalJSON(b []byte) error {
    asset_event_typeReceived := false
    event_indexReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
            asset_event_typeReceived = true
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_event_type (a required property) was received
    if !asset_event_typeReceived {
		strct._asset_event_type_ValidationError = fmt.Errorf("\"AssetEventType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxId) Validate() []error {
    var allErrors []error
    if strct._asset_event_type_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_event_type_ValidationError)
	}
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetEventType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenHistoryEventWithTxMetadata) UnmarshalJSON(b []byte) error {
    asset_event_typeReceived := false
    event_indexReceived := false
    txReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
            asset_event_typeReceived = true
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_event_type (a required property) was received
    if !asset_event_typeReceived {
		strct._asset_event_type_ValidationError = fmt.Errorf("\"AssetEventType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenHistoryEventWithTxMetadata) Validate() []error {
    var allErrors []error
    if strct._asset_event_type_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_event_type_ValidationError)
	}
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AssetIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "asset_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_identifier\": ")
	if tmp, err := json.Marshal(strct.AssetIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) UnmarshalJSON(b []byte) error {
    asset_identifierReceived := false
    block_heightReceived := false
    txReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "asset_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AssetIdentifier); err != nil {
				return err
            }
            asset_identifierReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if asset_identifier (a required property) was received
    if !asset_identifierReceived {
		strct._asset_identifier_ValidationError = fmt.Errorf("\"AssetIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenHoldingWithTxMetadata) Validate() []error {
    var allErrors []error
    if strct._asset_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._asset_identifier_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "EventIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event_index\": ")
	if tmp, err := json.Marshal(strct.EventIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Tx" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx\": ")
	if tmp, err := json.Marshal(strct.Tx); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) UnmarshalJSON(b []byte) error {
    event_indexReceived := false
    txReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event_index":
            if err := json.Unmarshal([]byte(v), &strct.EventIndex); err != nil {
				return err
            }
            event_indexReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "tx":
            if err := json.Unmarshal([]byte(v), &strct.Tx); err != nil {
				return err
            }
            txReceived = true
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event_index (a required property) was received
    if !event_indexReceived {
		strct._event_index_ValidationError = fmt.Errorf("\"EventIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx (a required property) was received
    if !txReceived {
		strct._tx_ValidationError = fmt.Errorf("\"Tx\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *NonFungibleTokenMintWithTxMetadata) Validate() []error {
    var allErrors []error
    if strct._event_index_ValidationError != nil {
		allErrors = append(allErrors, strct._event_index_ValidationError)
	}
    if strct._tx_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *PoisonMicroblock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "MicroblockHeader1" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_header_1" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_header_1\": ")
	if tmp, err := json.Marshal(strct.MicroblockHeader1); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "MicroblockHeader2" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "microblock_header_2" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"microblock_header_2\": ")
	if tmp, err := json.Marshal(strct.MicroblockHeader2); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PoisonMicroblock) UnmarshalJSON(b []byte) error {
    microblock_header_1Received := false
    microblock_header_2Received := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "microblock_header_1":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHeader1); err != nil {
				return err
            }
            microblock_header_1Received = true
        case "microblock_header_2":
            if err := json.Unmarshal([]byte(v), &strct.MicroblockHeader2); err != nil {
				return err
            }
            microblock_header_2Received = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if microblock_header_1 (a required property) was received
    if !microblock_header_1Received {
		strct._microblock_header_1_ValidationError = fmt.Errorf("\"MicroblockHeader1\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if microblock_header_2 (a required property) was received
    if !microblock_header_2Received {
		strct._microblock_header_2_ValidationError = fmt.Errorf("\"MicroblockHeader2\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *PoisonMicroblock) Validate() []error {
    var allErrors []error
    if strct._microblock_header_1_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_header_1_ValidationError)
	}
    if strct._microblock_header_2_ValidationError != nil {
		allErrors = append(allErrors, strct._microblock_header_2_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *PoisonMicroblockTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "PoisonMicroblock" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "poison_microblock" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"poison_microblock\": ")
	if tmp, err := json.Marshal(strct.PoisonMicroblock); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PoisonMicroblockTransactionMetadata) UnmarshalJSON(b []byte) error {
    poison_microblockReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "poison_microblock":
            if err := json.Unmarshal([]byte(v), &strct.PoisonMicroblock); err != nil {
				return err
            }
            poison_microblockReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if poison_microblock (a required property) was received
    if !poison_microblockReceived {
		strct._poison_microblock_ValidationError = fmt.Errorf("\"PoisonMicroblock\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *PoisonMicroblockTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._poison_microblock_ValidationError != nil {
		allErrors = append(allErrors, strct._poison_microblock_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *ReadOnlyFunctionArgs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Arguments" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "arguments" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"arguments\": ")
	if tmp, err := json.Marshal(strct.Arguments); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Sender" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReadOnlyFunctionArgs) UnmarshalJSON(b []byte) error {
    argumentsReceived := false
    senderReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "arguments":
            if err := json.Unmarshal([]byte(v), &strct.Arguments); err != nil {
				return err
            }
            argumentsReceived = true
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
            senderReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if arguments (a required property) was received
    if !argumentsReceived {
		strct._arguments_ValidationError = fmt.Errorf("\"Arguments\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if sender (a required property) was received
    if !senderReceived {
		strct._sender_ValidationError = fmt.Errorf("\"Sender\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *ReadOnlyFunctionArgs) Validate() []error {
    var allErrors []error
    if strct._arguments_ValidationError != nil {
		allErrors = append(allErrors, strct._arguments_ValidationError)
	}
    if strct._sender_ValidationError != nil {
		allErrors = append(allErrors, strct._sender_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Result) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Result) UnmarshalJSON(b []byte) error {
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Result) Validate() []error {
    var allErrors []error
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sub_account" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sub_account\": ")
	if tmp, err := json.Marshal(strct.SubAccount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount) UnmarshalJSON(b []byte) error {
    addressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "sub_account":
            if err := json.Unmarshal([]byte(v), &strct.SubAccount); err != nil {
				return err
            }
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAccount_RosettaAccountIdentifier_RosettaSubAccount) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Currency" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "currency" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"currency\": ")
	if tmp, err := json.Marshal(strct.Currency); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Value" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) UnmarshalJSON(b []byte) error {
    currencyReceived := false
    valueReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "currency":
            if err := json.Unmarshal([]byte(v), &strct.Currency); err != nil {
				return err
            }
            currencyReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
            valueReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if currency (a required property) was received
    if !currencyReceived {
		strct._currency_ValidationError = fmt.Errorf("\"Currency\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if value (a required property) was received
    if !valueReceived {
		strct._value_ValidationError = fmt.Errorf("\"Value\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaAmount_RosettaMaxFeeAmount) Validate() []error {
    var allErrors []error
    if strct._currency_ValidationError != nil {
		allErrors = append(allErrors, strct._currency_ValidationError)
	}
    if strct._value_ValidationError != nil {
		allErrors = append(allErrors, strct._value_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlock) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "BlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_identifier\": ")
	if tmp, err := json.Marshal(strct.BlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "ParentBlockIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "parent_block_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"parent_block_identifier\": ")
	if tmp, err := json.Marshal(strct.ParentBlockIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Timestamp" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "timestamp" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Transactions" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transactions" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transactions\": ")
	if tmp, err := json.Marshal(strct.Transactions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlock) UnmarshalJSON(b []byte) error {
    block_identifierReceived := false
    parent_block_identifierReceived := false
    timestampReceived := false
    transactionsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.BlockIdentifier); err != nil {
				return err
            }
            block_identifierReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "parent_block_identifier":
            if err := json.Unmarshal([]byte(v), &strct.ParentBlockIdentifier); err != nil {
				return err
            }
            parent_block_identifierReceived = true
        case "timestamp":
            if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
				return err
            }
            timestampReceived = true
        case "transactions":
            if err := json.Unmarshal([]byte(v), &strct.Transactions); err != nil {
				return err
            }
            transactionsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if block_identifier (a required property) was received
    if !block_identifierReceived {
		strct._block_identifier_ValidationError = fmt.Errorf("\"BlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if parent_block_identifier (a required property) was received
    if !parent_block_identifierReceived {
		strct._parent_block_identifier_ValidationError = fmt.Errorf("\"ParentBlockIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if timestamp (a required property) was received
    if !timestampReceived {
		strct._timestamp_ValidationError = fmt.Errorf("\"Timestamp\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transactions (a required property) was received
    if !transactionsReceived {
		strct._transactions_ValidationError = fmt.Errorf("\"Transactions\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlock) Validate() []error {
    var allErrors []error
    if strct._block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._block_identifier_ValidationError)
	}
    if strct._parent_block_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._parent_block_identifier_ValidationError)
	}
    if strct._timestamp_ValidationError != nil {
		allErrors = append(allErrors, strct._timestamp_ValidationError)
	}
    if strct._transactions_ValidationError != nil {
		allErrors = append(allErrors, strct._transactions_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hash" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hash" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hash\": ")
	if tmp, err := json.Marshal(strct.Hash); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) UnmarshalJSON(b []byte) error {
    hashReceived := false
    indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hash":
            if err := json.Unmarshal([]byte(v), &strct.Hash); err != nil {
				return err
            }
            hashReceived = true
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
				return err
            }
            indexReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hash (a required property) was received
    if !hashReceived {
		strct._hash_ValidationError = fmt.Errorf("\"Hash\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if index (a required property) was received
    if !indexReceived {
		strct._index_ValidationError = fmt.Errorf("\"Index\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaBlockIdentifierHeight_RosettaGenesisBlockIdentifier_RosettaOldestBlockIdentifier_RosettaParentBlockIdentifier) Validate() []error {
    var allErrors []error
    if strct._hash_ValidationError != nil {
		allErrors = append(allErrors, strct._hash_ValidationError)
	}
    if strct._index_ValidationError != nil {
		allErrors = append(allErrors, strct._index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCoin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "CoinIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_identifier\": ")
	if tmp, err := json.Marshal(strct.CoinIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCoin) UnmarshalJSON(b []byte) error {
    amountReceived := false
    coin_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "coin_identifier":
            if err := json.Unmarshal([]byte(v), &strct.CoinIdentifier); err != nil {
				return err
            }
            coin_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if coin_identifier (a required property) was received
    if !coin_identifierReceived {
		strct._coin_identifier_ValidationError = fmt.Errorf("\"CoinIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCoin) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._coin_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCoinChange) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CoinAction" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_action" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_action\": ")
	if tmp, err := json.Marshal(strct.CoinAction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "CoinIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "coin_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_identifier\": ")
	if tmp, err := json.Marshal(strct.CoinIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCoinChange) UnmarshalJSON(b []byte) error {
    coin_actionReceived := false
    coin_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "coin_action":
            if err := json.Unmarshal([]byte(v), &strct.CoinAction); err != nil {
				return err
            }
            coin_actionReceived = true
        case "coin_identifier":
            if err := json.Unmarshal([]byte(v), &strct.CoinIdentifier); err != nil {
				return err
            }
            coin_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if coin_action (a required property) was received
    if !coin_actionReceived {
		strct._coin_action_ValidationError = fmt.Errorf("\"CoinAction\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if coin_identifier (a required property) was received
    if !coin_identifierReceived {
		strct._coin_identifier_ValidationError = fmt.Errorf("\"CoinIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCoinChange) Validate() []error {
    var allErrors []error
    if strct._coin_action_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_action_ValidationError)
	}
    if strct._coin_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._coin_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaCurrency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Decimals" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Symbol" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaCurrency) UnmarshalJSON(b []byte) error {
    decimalsReceived := false
    symbolReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
            decimalsReceived = true
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
            symbolReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if decimals (a required property) was received
    if !decimalsReceived {
		strct._decimals_ValidationError = fmt.Errorf("\"Decimals\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if symbol (a required property) was received
    if !symbolReceived {
		strct._symbol_ValidationError = fmt.Errorf("\"Symbol\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaCurrency) Validate() []error {
    var allErrors []error
    if strct._decimals_ValidationError != nil {
		allErrors = append(allErrors, strct._decimals_ValidationError)
	}
    if strct._symbol_ValidationError != nil {
		allErrors = append(allErrors, strct._symbol_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account\": ")
	if tmp, err := json.Marshal(strct.Account); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "coin_change" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"coin_change\": ")
	if tmp, err := json.Marshal(strct.CoinChange); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "OperationIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operation_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operation_identifier\": ")
	if tmp, err := json.Marshal(strct.OperationIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "related_operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"related_operations\": ")
	if tmp, err := json.Marshal(strct.RelatedOperations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperation) UnmarshalJSON(b []byte) error {
    operation_identifierReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account":
            if err := json.Unmarshal([]byte(v), &strct.Account); err != nil {
				return err
            }
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "coin_change":
            if err := json.Unmarshal([]byte(v), &strct.CoinChange); err != nil {
				return err
            }
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "operation_identifier":
            if err := json.Unmarshal([]byte(v), &strct.OperationIdentifier); err != nil {
				return err
            }
            operation_identifierReceived = true
        case "related_operations":
            if err := json.Unmarshal([]byte(v), &strct.RelatedOperations); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if operation_identifier (a required property) was received
    if !operation_identifierReceived {
		strct._operation_identifier_ValidationError = fmt.Errorf("\"OperationIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if type (a required property) was received
    if !typeReceived {
		strct._type_ValidationError = fmt.Errorf("\"Type\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperation) Validate() []error {
    var allErrors []error
    if strct._operation_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._operation_identifier_ValidationError)
	}
    if strct._type_ValidationError != nil {
		allErrors = append(allErrors, strct._type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "network_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network_index\": ")
	if tmp, err := json.Marshal(strct.NetworkIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) UnmarshalJSON(b []byte) error {
    indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
				return err
            }
            indexReceived = true
        case "network_index":
            if err := json.Unmarshal([]byte(v), &strct.NetworkIndex); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if index (a required property) was received
    if !indexReceived {
		strct._index_ValidationError = fmt.Errorf("\"Index\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperationIdentifier_RosettaRelatedOperation) Validate() []error {
    var allErrors []error
    if strct._index_ValidationError != nil {
		allErrors = append(allErrors, strct._index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOperationStatus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Successful" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "successful" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"successful\": ")
	if tmp, err := json.Marshal(strct.Successful); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOperationStatus) UnmarshalJSON(b []byte) error {
    statusReceived := false
    successfulReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
            statusReceived = true
        case "successful":
            if err := json.Unmarshal([]byte(v), &strct.Successful); err != nil {
				return err
            }
            successfulReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if status (a required property) was received
    if !statusReceived {
		strct._status_ValidationError = fmt.Errorf("\"Status\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if successful (a required property) was received
    if !successfulReceived {
		strct._successful_ValidationError = fmt.Errorf("\"Successful\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaOperationStatus) Validate() []error {
    var allErrors []error
    if strct._status_ValidationError != nil {
		allErrors = append(allErrors, strct._status_ValidationError)
	}
    if strct._successful_ValidationError != nil {
		allErrors = append(allErrors, strct._successful_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaOptions) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "burn_block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"burn_block_height\": ")
	if tmp, err := json.Marshal(strct.BurnBlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contract_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_address\": ")
	if tmp, err := json.Marshal(strct.ContractAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contract_name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_name\": ")
	if tmp, err := json.Marshal(strct.ContractName); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "decimals" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"decimals\": ")
	if tmp, err := json.Marshal(strct.Decimals); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "delegate_to" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"delegate_to\": ")
	if tmp, err := json.Marshal(strct.DelegateTo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"fee\": ")
	if tmp, err := json.Marshal(strct.Fee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "gas_limit" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"gas_limit\": ")
	if tmp, err := json.Marshal(strct.GasLimit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "gas_price" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"gas_price\": ")
	if tmp, err := json.Marshal(strct.GasPrice); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "max_fee" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_fee\": ")
	if tmp, err := json.Marshal(strct.MaxFee); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "number_of_cycles" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"number_of_cycles\": ")
	if tmp, err := json.Marshal(strct.NumberOfCycles); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pox_addr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"pox_addr\": ")
	if tmp, err := json.Marshal(strct.PoxAddr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender_address\": ")
	if tmp, err := json.Marshal(strct.SenderAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "size" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"size\": ")
	if tmp, err := json.Marshal(strct.Size); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "suggested_fee_multiplier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"suggested_fee_multiplier\": ")
	if tmp, err := json.Marshal(strct.SuggestedFeeMultiplier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "symbol" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"symbol\": ")
	if tmp, err := json.Marshal(strct.Symbol); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "token_transfer_recipient_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_transfer_recipient_address\": ")
	if tmp, err := json.Marshal(strct.TokenTransferRecipientAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaOptions) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "burn_block_height":
            if err := json.Unmarshal([]byte(v), &strct.BurnBlockHeight); err != nil {
				return err
            }
        case "contract_address":
            if err := json.Unmarshal([]byte(v), &strct.ContractAddress); err != nil {
				return err
            }
        case "contract_name":
            if err := json.Unmarshal([]byte(v), &strct.ContractName); err != nil {
				return err
            }
        case "decimals":
            if err := json.Unmarshal([]byte(v), &strct.Decimals); err != nil {
				return err
            }
        case "delegate_to":
            if err := json.Unmarshal([]byte(v), &strct.DelegateTo); err != nil {
				return err
            }
        case "fee":
            if err := json.Unmarshal([]byte(v), &strct.Fee); err != nil {
				return err
            }
        case "gas_limit":
            if err := json.Unmarshal([]byte(v), &strct.GasLimit); err != nil {
				return err
            }
        case "gas_price":
            if err := json.Unmarshal([]byte(v), &strct.GasPrice); err != nil {
				return err
            }
        case "max_fee":
            if err := json.Unmarshal([]byte(v), &strct.MaxFee); err != nil {
				return err
            }
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
        case "number_of_cycles":
            if err := json.Unmarshal([]byte(v), &strct.NumberOfCycles); err != nil {
				return err
            }
        case "pox_addr":
            if err := json.Unmarshal([]byte(v), &strct.PoxAddr); err != nil {
				return err
            }
        case "sender_address":
            if err := json.Unmarshal([]byte(v), &strct.SenderAddress); err != nil {
				return err
            }
        case "size":
            if err := json.Unmarshal([]byte(v), &strct.Size); err != nil {
				return err
            }
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
				return err
            }
        case "suggested_fee_multiplier":
            if err := json.Unmarshal([]byte(v), &strct.SuggestedFeeMultiplier); err != nil {
				return err
            }
        case "symbol":
            if err := json.Unmarshal([]byte(v), &strct.Symbol); err != nil {
				return err
            }
        case "token_transfer_recipient_address":
            if err := json.Unmarshal([]byte(v), &strct.TokenTransferRecipientAddress); err != nil {
				return err
            }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RosettaOptions) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaPeers) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PeerId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "peer_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"peer_id\": ")
	if tmp, err := json.Marshal(strct.PeerId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaPeers) UnmarshalJSON(b []byte) error {
    peer_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "peer_id":
            if err := json.Unmarshal([]byte(v), &strct.PeerId); err != nil {
				return err
            }
            peer_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if peer_id (a required property) was received
    if !peer_idReceived {
		strct._peer_id_ValidationError = fmt.Errorf("\"PeerId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaPeers) Validate() []error {
    var allErrors []error
    if strct._peer_id_ValidationError != nil {
		allErrors = append(allErrors, strct._peer_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaPublicKey) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CurveType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "curve_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"curve_type\": ")
	if tmp, err := json.Marshal(strct.CurveType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaPublicKey) UnmarshalJSON(b []byte) error {
    curve_typeReceived := false
    hex_bytesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "curve_type":
            if err := json.Unmarshal([]byte(v), &strct.CurveType); err != nil {
				return err
            }
            curve_typeReceived = true
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if curve_type (a required property) was received
    if !curve_typeReceived {
		strct._curve_type_ValidationError = fmt.Errorf("\"CurveType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaPublicKey) Validate() []error {
    var allErrors []error
    if strct._curve_type_ValidationError != nil {
		allErrors = append(allErrors, strct._curve_type_ValidationError)
	}
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaSignature) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "PublicKey" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "public_key" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"public_key\": ")
	if tmp, err := json.Marshal(strct.PublicKey); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SignatureType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signature_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signature_type\": ")
	if tmp, err := json.Marshal(strct.SignatureType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SigningPayload" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "signing_payload" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signing_payload\": ")
	if tmp, err := json.Marshal(strct.SigningPayload); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaSignature) UnmarshalJSON(b []byte) error {
    hex_bytesReceived := false
    public_keyReceived := false
    signature_typeReceived := false
    signing_payloadReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        case "public_key":
            if err := json.Unmarshal([]byte(v), &strct.PublicKey); err != nil {
				return err
            }
            public_keyReceived = true
        case "signature_type":
            if err := json.Unmarshal([]byte(v), &strct.SignatureType); err != nil {
				return err
            }
            signature_typeReceived = true
        case "signing_payload":
            if err := json.Unmarshal([]byte(v), &strct.SigningPayload); err != nil {
				return err
            }
            signing_payloadReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if public_key (a required property) was received
    if !public_keyReceived {
		strct._public_key_ValidationError = fmt.Errorf("\"PublicKey\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signature_type (a required property) was received
    if !signature_typeReceived {
		strct._signature_type_ValidationError = fmt.Errorf("\"SignatureType\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if signing_payload (a required property) was received
    if !signing_payloadReceived {
		strct._signing_payload_ValidationError = fmt.Errorf("\"SigningPayload\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaSignature) Validate() []error {
    var allErrors []error
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if strct._public_key_ValidationError != nil {
		allErrors = append(allErrors, strct._public_key_ValidationError)
	}
    if strct._signature_type_ValidationError != nil {
		allErrors = append(allErrors, strct._signature_type_ValidationError)
	}
    if strct._signing_payload_ValidationError != nil {
		allErrors = append(allErrors, strct._signing_payload_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaSyncStatus) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CurrentIndex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "current_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"current_index\": ")
	if tmp, err := json.Marshal(strct.CurrentIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stage" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stage\": ")
	if tmp, err := json.Marshal(strct.Stage); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "synced" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"synced\": ")
	if tmp, err := json.Marshal(strct.Synced); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "target_index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"target_index\": ")
	if tmp, err := json.Marshal(strct.TargetIndex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaSyncStatus) UnmarshalJSON(b []byte) error {
    current_indexReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "current_index":
            if err := json.Unmarshal([]byte(v), &strct.CurrentIndex); err != nil {
				return err
            }
            current_indexReceived = true
        case "stage":
            if err := json.Unmarshal([]byte(v), &strct.Stage); err != nil {
				return err
            }
        case "synced":
            if err := json.Unmarshal([]byte(v), &strct.Synced); err != nil {
				return err
            }
        case "target_index":
            if err := json.Unmarshal([]byte(v), &strct.TargetIndex); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if current_index (a required property) was received
    if !current_indexReceived {
		strct._current_index_ValidationError = fmt.Errorf("\"CurrentIndex\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaSyncStatus) Validate() []error {
    var allErrors []error
    if strct._current_index_ValidationError != nil {
		allErrors = append(allErrors, strct._current_index_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RosettaTransaction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Operations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "operations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"operations\": ")
	if tmp, err := json.Marshal(strct.Operations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TransactionIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "transaction_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"transaction_identifier\": ")
	if tmp, err := json.Marshal(strct.TransactionIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RosettaTransaction) UnmarshalJSON(b []byte) error {
    operationsReceived := false
    transaction_identifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "operations":
            if err := json.Unmarshal([]byte(v), &strct.Operations); err != nil {
				return err
            }
            operationsReceived = true
        case "transaction_identifier":
            if err := json.Unmarshal([]byte(v), &strct.TransactionIdentifier); err != nil {
				return err
            }
            transaction_identifierReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if operations (a required property) was received
    if !operationsReceived {
		strct._operations_ValidationError = fmt.Errorf("\"Operations\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if transaction_identifier (a required property) was received
    if !transaction_identifierReceived {
		strct._transaction_identifier_ValidationError = fmt.Errorf("\"TransactionIdentifier\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RosettaTransaction) Validate() []error {
    var allErrors []error
    if strct._operations_ValidationError != nil {
		allErrors = append(allErrors, strct._operations_ValidationError)
	}
    if strct._transaction_identifier_ValidationError != nil {
		allErrors = append(allErrors, strct._transaction_identifier_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceNotificationParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Balance" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "balance" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"balance\": ")
	if tmp, err := json.Marshal(strct.Balance); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceNotificationParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    balanceReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "balance":
            if err := json.Unmarshal([]byte(v), &strct.Balance); err != nil {
				return err
            }
            balanceReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if balance (a required property) was received
    if !balanceReceived {
		strct._balance_ValidationError = fmt.Errorf("\"Balance\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceNotificationParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._balance_ValidationError != nil {
		allErrors = append(allErrors, strct._balance_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    eventReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
				return err
            }
            eventReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if event (a required property) was received
    if !eventReceived {
		strct._event_ValidationError = fmt.Errorf("\"Event\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceSubscriptionParams_RpcAddressTxSubscriptionParams_RpcBlockSubscriptionParams_RpcMempoolSubscriptionParams_RpcMicroblockSubscriptionParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._event_ValidationError != nil {
		allErrors = append(allErrors, strct._event_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressBalanceSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Address" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxStatus" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_status\": ")
	if tmp, err := json.Marshal(strct.TxStatus); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) UnmarshalJSON(b []byte) error {
    addressReceived := false
    tx_idReceived := false
    tx_statusReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
            addressReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        case "tx_status":
            if err := json.Unmarshal([]byte(v), &strct.TxStatus); err != nil {
				return err
            }
            tx_statusReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if address (a required property) was received
    if !addressReceived {
		strct._address_ValidationError = fmt.Errorf("\"Address\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_status (a required property) was received
    if !tx_statusReceived {
		strct._tx_status_ValidationError = fmt.Errorf("\"TxStatus\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxNotificationParams_RpcTxUpdateNotificationParams) Validate() []error {
    var allErrors []error
    if strct._address_ValidationError != nil {
		allErrors = append(allErrors, strct._address_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if strct._tx_status_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_status_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcAddressTxSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcAddressTxSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcAddressTxSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcBlockNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcBlockNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcBlockNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcBlockSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcBlockSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcBlockSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMempoolNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMempoolNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMempoolNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMempoolSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMempoolSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMempoolSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMicroblockNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMicroblockNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMicroblockNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcMicroblockSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcMicroblockSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcMicroblockSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcTxUpdateNotificationResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcTxUpdateNotificationResponse) UnmarshalJSON(b []byte) error {
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcTxUpdateNotificationResponse) Validate() []error {
    var allErrors []error
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcTxUpdateSubscriptionParams) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Event" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "event" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"event\": ")
	if tmp, err := json.Marshal(strct.Event); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcTxUpdateSubscriptionParams) UnmarshalJSON(b []byte) error {
    eventReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "event":
            if err := json.Unmarshal([]byte(v), &strct.Event); err != nil {
				return err
            }
            eventReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if event (a required property) was received
    if !eventReceived {
		strct._event_ValidationError = fmt.Errorf("\"Event\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcTxUpdateSubscriptionParams) Validate() []error {
    var allErrors []error
    if strct._event_ValidationError != nil {
		allErrors = append(allErrors, strct._event_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *RpcTxUpdateSubscriptionRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Jsonrpc" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "jsonrpc" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"jsonrpc\": ")
	if tmp, err := json.Marshal(strct.Jsonrpc); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Method" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "method" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"method\": ")
	if tmp, err := json.Marshal(strct.Method); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Params" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "params" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"params\": ")
	if tmp, err := json.Marshal(strct.Params); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RpcTxUpdateSubscriptionRequest) UnmarshalJSON(b []byte) error {
    idReceived := false
    jsonrpcReceived := false
    methodReceived := false
    paramsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
				return err
            }
            idReceived = true
        case "jsonrpc":
            if err := json.Unmarshal([]byte(v), &strct.Jsonrpc); err != nil {
				return err
            }
            jsonrpcReceived = true
        case "method":
            if err := json.Unmarshal([]byte(v), &strct.Method); err != nil {
				return err
            }
            methodReceived = true
        case "params":
            if err := json.Unmarshal([]byte(v), &strct.Params); err != nil {
				return err
            }
            paramsReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if id (a required property) was received
    if !idReceived {
		strct._id_ValidationError = fmt.Errorf("\"Id\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if jsonrpc (a required property) was received
    if !jsonrpcReceived {
		strct._jsonrpc_ValidationError = fmt.Errorf("\"Jsonrpc\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if method (a required property) was received
    if !methodReceived {
		strct._method_ValidationError = fmt.Errorf("\"Method\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if params (a required property) was received
    if !paramsReceived {
		strct._params_ValidationError = fmt.Errorf("\"Params\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *RpcTxUpdateSubscriptionRequest) Validate() []error {
    var allErrors []error
    if strct._id_ValidationError != nil {
		allErrors = append(allErrors, strct._id_ValidationError)
	}
    if strct._jsonrpc_ValidationError != nil {
		allErrors = append(allErrors, strct._jsonrpc_ValidationError)
	}
    if strct._method_ValidationError != nil {
		allErrors = append(allErrors, strct._method_ValidationError)
	}
    if strct._params_ValidationError != nil {
		allErrors = append(allErrors, strct._params_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SigningPayload) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "account_identifier" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"account_identifier\": ")
	if tmp, err := json.Marshal(strct.AccountIdentifier); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "HexBytes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex_bytes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex_bytes\": ")
	if tmp, err := json.Marshal(strct.HexBytes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "signature_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"signature_type\": ")
	if tmp, err := json.Marshal(strct.SignatureType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SigningPayload) UnmarshalJSON(b []byte) error {
    hex_bytesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "account_identifier":
            if err := json.Unmarshal([]byte(v), &strct.AccountIdentifier); err != nil {
				return err
            }
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
            }
        case "hex_bytes":
            if err := json.Unmarshal([]byte(v), &strct.HexBytes); err != nil {
				return err
            }
            hex_bytesReceived = true
        case "signature_type":
            if err := json.Unmarshal([]byte(v), &strct.SignatureType); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex_bytes (a required property) was received
    if !hex_bytesReceived {
		strct._hex_bytes_ValidationError = fmt.Errorf("\"HexBytes\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SigningPayload) Validate() []error {
    var allErrors []error
    if strct._hex_bytes_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_bytes_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContract) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Abi" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "abi" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"abi\": ")
	if tmp, err := json.Marshal(strct.Abi); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "BlockHeight" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "block_height" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"block_height\": ")
	if tmp, err := json.Marshal(strct.BlockHeight); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Canonical" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "canonical" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SourceCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "source_code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"source_code\": ")
	if tmp, err := json.Marshal(strct.SourceCode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_id\": ")
	if tmp, err := json.Marshal(strct.TxId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContract) UnmarshalJSON(b []byte) error {
    abiReceived := false
    block_heightReceived := false
    canonicalReceived := false
    source_codeReceived := false
    tx_idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "abi":
            if err := json.Unmarshal([]byte(v), &strct.Abi); err != nil {
				return err
            }
            abiReceived = true
        case "block_height":
            if err := json.Unmarshal([]byte(v), &strct.BlockHeight); err != nil {
				return err
            }
            block_heightReceived = true
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
				return err
            }
            canonicalReceived = true
        case "source_code":
            if err := json.Unmarshal([]byte(v), &strct.SourceCode); err != nil {
				return err
            }
            source_codeReceived = true
        case "tx_id":
            if err := json.Unmarshal([]byte(v), &strct.TxId); err != nil {
				return err
            }
            tx_idReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if abi (a required property) was received
    if !abiReceived {
		strct._abi_ValidationError = fmt.Errorf("\"Abi\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if block_height (a required property) was received
    if !block_heightReceived {
		strct._block_height_ValidationError = fmt.Errorf("\"BlockHeight\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if canonical (a required property) was received
    if !canonicalReceived {
		strct._canonical_ValidationError = fmt.Errorf("\"Canonical\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if source_code (a required property) was received
    if !source_codeReceived {
		strct._source_code_ValidationError = fmt.Errorf("\"SourceCode\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_id (a required property) was received
    if !tx_idReceived {
		strct._tx_id_ValidationError = fmt.Errorf("\"TxId\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContract) Validate() []error {
    var allErrors []error
    if strct._abi_ValidationError != nil {
		allErrors = append(allErrors, strct._abi_ValidationError)
	}
    if strct._block_height_ValidationError != nil {
		allErrors = append(allErrors, strct._block_height_ValidationError)
	}
    if strct._canonical_ValidationError != nil {
		allErrors = append(allErrors, strct._canonical_ValidationError)
	}
    if strct._source_code_ValidationError != nil {
		allErrors = append(allErrors, strct._source_code_ValidationError)
	}
    if strct._tx_id_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_id_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContractTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "SmartContract" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "smart_contract" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"smart_contract\": ")
	if tmp, err := json.Marshal(strct.SmartContract); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContractTransactionMetadata) UnmarshalJSON(b []byte) error {
    smart_contractReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "smart_contract":
            if err := json.Unmarshal([]byte(v), &strct.SmartContract); err != nil {
				return err
            }
            smart_contractReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if smart_contract (a required property) was received
    if !smart_contractReceived {
		strct._smart_contract_ValidationError = fmt.Errorf("\"SmartContract\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContractTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._smart_contract_ValidationError != nil {
		allErrors = append(allErrors, strct._smart_contract_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SmartContract_11d00c1bd3) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ContractId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "contract_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"contract_id\": ")
	if tmp, err := json.Marshal(strct.ContractId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "SourceCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "source_code" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"source_code\": ")
	if tmp, err := json.Marshal(strct.SourceCode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SmartContract_11d00c1bd3) UnmarshalJSON(b []byte) error {
    contract_idReceived := false
    source_codeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contract_id":
            if err := json.Unmarshal([]byte(v), &strct.ContractId); err != nil {
				return err
            }
            contract_idReceived = true
        case "source_code":
            if err := json.Unmarshal([]byte(v), &strct.SourceCode); err != nil {
				return err
            }
            source_codeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if contract_id (a required property) was received
    if !contract_idReceived {
		strct._contract_id_ValidationError = fmt.Errorf("\"ContractId\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if source_code (a required property) was received
    if !source_codeReceived {
		strct._source_code_ValidationError = fmt.Errorf("\"SourceCode\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SmartContract_11d00c1bd3) Validate() []error {
    var allErrors []error
    if strct._contract_id_ValidationError != nil {
		allErrors = append(allErrors, strct._contract_id_ValidationError)
	}
    if strct._source_code_ValidationError != nil {
		allErrors = append(allErrors, strct._source_code_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *StxTransfersItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *StxTransfersItems) UnmarshalJSON(b []byte) error {
    amountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *StxTransfersItems) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *SubNetworkIdentifier) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "metadata" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"metadata\": ")
	if tmp, err := json.Marshal(strct.Metadata); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Network" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "network" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"network\": ")
	if tmp, err := json.Marshal(strct.Network); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SubNetworkIdentifier) UnmarshalJSON(b []byte) error {
    networkReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "metadata":
            if err := json.Unmarshal([]byte(v), &strct.Metadata); err != nil {
				return err
            }
        case "network":
            if err := json.Unmarshal([]byte(v), &strct.Network); err != nil {
				return err
            }
            networkReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if network (a required property) was received
    if !networkReceived {
		strct._network_ValidationError = fmt.Errorf("\"Network\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *SubNetworkIdentifier) Validate() []error {
    var allErrors []error
    if strct._network_ValidationError != nil {
		allErrors = append(allErrors, strct._network_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TargetBlockTime) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TargetBlockTime" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "target_block_time" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"target_block_time\": ")
	if tmp, err := json.Marshal(strct.TargetBlockTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TargetBlockTime) UnmarshalJSON(b []byte) error {
    target_block_timeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "target_block_time":
            if err := json.Unmarshal([]byte(v), &strct.TargetBlockTime); err != nil {
				return err
            }
            target_block_timeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if target_block_time (a required property) was received
    if !target_block_timeReceived {
		strct._target_block_time_ValidationError = fmt.Errorf("\"TargetBlockTime\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TargetBlockTime) Validate() []error {
    var allErrors []error
    if strct._target_block_time_ValidationError != nil {
		allErrors = append(allErrors, strct._target_block_time_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TokenTransfer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Amount" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Memo" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "memo" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"memo\": ")
	if tmp, err := json.Marshal(strct.Memo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "RecipientAddress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recipient_address" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient_address\": ")
	if tmp, err := json.Marshal(strct.RecipientAddress); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TokenTransfer) UnmarshalJSON(b []byte) error {
    amountReceived := false
    memoReceived := false
    recipient_addressReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
            amountReceived = true
        case "memo":
            if err := json.Unmarshal([]byte(v), &strct.Memo); err != nil {
				return err
            }
            memoReceived = true
        case "recipient_address":
            if err := json.Unmarshal([]byte(v), &strct.RecipientAddress); err != nil {
				return err
            }
            recipient_addressReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if amount (a required property) was received
    if !amountReceived {
		strct._amount_ValidationError = fmt.Errorf("\"Amount\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if memo (a required property) was received
    if !memoReceived {
		strct._memo_ValidationError = fmt.Errorf("\"Memo\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if recipient_address (a required property) was received
    if !recipient_addressReceived {
		strct._recipient_address_ValidationError = fmt.Errorf("\"RecipientAddress\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TokenTransfer) Validate() []error {
    var allErrors []error
    if strct._amount_ValidationError != nil {
		allErrors = append(allErrors, strct._amount_ValidationError)
	}
    if strct._memo_ValidationError != nil {
		allErrors = append(allErrors, strct._memo_ValidationError)
	}
    if strct._recipient_address_ValidationError != nil {
		allErrors = append(allErrors, strct._recipient_address_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TokenTransferTransactionMetadata) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "TokenTransfer" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "token_transfer" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"token_transfer\": ")
	if tmp, err := json.Marshal(strct.TokenTransfer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "TxType" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tx_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tx_type\": ")
	if tmp, err := json.Marshal(strct.TxType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TokenTransferTransactionMetadata) UnmarshalJSON(b []byte) error {
    token_transferReceived := false
    tx_typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "token_transfer":
            if err := json.Unmarshal([]byte(v), &strct.TokenTransfer); err != nil {
				return err
            }
            token_transferReceived = true
        case "tx_type":
            if err := json.Unmarshal([]byte(v), &strct.TxType); err != nil {
				return err
            }
            tx_typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if token_transfer (a required property) was received
    if !token_transferReceived {
		strct._token_transfer_ValidationError = fmt.Errorf("\"TokenTransfer\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if tx_type (a required property) was received
    if !tx_typeReceived {
		strct._tx_type_ValidationError = fmt.Errorf("\"TxType\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TokenTransferTransactionMetadata) Validate() []error {
    var allErrors []error
    if strct._token_transfer_ValidationError != nil {
		allErrors = append(allErrors, strct._token_transfer_ValidationError)
	}
    if strct._tx_type_ValidationError != nil {
		allErrors = append(allErrors, strct._tx_type_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionEventAsset) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "amount" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"amount\": ")
	if tmp, err := json.Marshal(strct.Amount); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "asset_event_type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_event_type\": ")
	if tmp, err := json.Marshal(strct.AssetEventType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "asset_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"asset_id\": ")
	if tmp, err := json.Marshal(strct.AssetId); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "recipient" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recipient\": ")
	if tmp, err := json.Marshal(strct.Recipient); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "sender" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"sender\": ")
	if tmp, err := json.Marshal(strct.Sender); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // Marshal the "value" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionEventAsset) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "amount":
            if err := json.Unmarshal([]byte(v), &strct.Amount); err != nil {
				return err
            }
        case "asset_event_type":
            if err := json.Unmarshal([]byte(v), &strct.AssetEventType); err != nil {
				return err
            }
        case "asset_id":
            if err := json.Unmarshal([]byte(v), &strct.AssetId); err != nil {
				return err
            }
        case "recipient":
            if err := json.Unmarshal([]byte(v), &strct.Recipient); err != nil {
				return err
            }
        case "sender":
            if err := json.Unmarshal([]byte(v), &strct.Sender); err != nil {
				return err
            }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
            }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *TransactionEventAsset) Validate() []error {
    var allErrors []error
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionFound) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Found" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "found" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"found\": ")
	if tmp, err := json.Marshal(strct.Found); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionFound) UnmarshalJSON(b []byte) error {
    foundReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "found":
            if err := json.Unmarshal([]byte(v), &strct.Found); err != nil {
				return err
            }
            foundReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
				return err
            }
            resultReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if found (a required property) was received
    if !foundReceived {
		strct._found_ValidationError = fmt.Errorf("\"Found\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if result (a required property) was received
    if !resultReceived {
		strct._result_ValidationError = fmt.Errorf("\"Result\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TransactionFound) Validate() []error {
    var allErrors []error
    if strct._found_ValidationError != nil {
		allErrors = append(allErrors, strct._found_ValidationError)
	}
    if strct._result_ValidationError != nil {
		allErrors = append(allErrors, strct._result_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *TransactionNotFound) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Found" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "found" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"found\": ")
	if tmp, err := json.Marshal(strct.Found); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TransactionNotFound) UnmarshalJSON(b []byte) error {
    foundReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "found":
            if err := json.Unmarshal([]byte(v), &strct.Found); err != nil {
				return err
            }
            foundReceived = true
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
				return err
            }
            resultReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if found (a required property) was received
    if !foundReceived {
		strct._found_ValidationError = fmt.Errorf("\"Found\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if result (a required property) was received
    if !resultReceived {
		strct._result_ValidationError = fmt.Errorf("\"Result\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *TransactionNotFound) Validate() []error {
    var allErrors []error
    if strct._found_ValidationError != nil {
		allErrors = append(allErrors, strct._found_ValidationError)
	}
    if strct._result_ValidationError != nil {
		allErrors = append(allErrors, strct._result_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}

func (strct *Value) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Hex" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "hex" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"hex\": ")
	if tmp, err := json.Marshal(strct.Hex); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
    // "Repr" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "repr" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"repr\": ")
	if tmp, err := json.Marshal(strct.Repr); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Value) UnmarshalJSON(b []byte) error {
    hexReceived := false
    reprReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "hex":
            if err := json.Unmarshal([]byte(v), &strct.Hex); err != nil {
				return err
            }
            hexReceived = true
        case "repr":
            if err := json.Unmarshal([]byte(v), &strct.Repr); err != nil {
				return err
            }
            reprReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if hex (a required property) was received
    if !hexReceived {
		strct._hex_ValidationError = fmt.Errorf("\"Hex\" is required but was not present: %w", ErrFieldRequired)
    }
    // check if repr (a required property) was received
    if !reprReceived {
		strct._repr_ValidationError = fmt.Errorf("\"Repr\" is required but was not present: %w", ErrFieldRequired)
    }
    return nil
}

func (strct *Value) Validate() []error {
    var allErrors []error
    if strct._hex_ValidationError != nil {
		allErrors = append(allErrors, strct._hex_ValidationError)
	}
    if strct._repr_ValidationError != nil {
		allErrors = append(allErrors, strct._repr_ValidationError)
	}
    if len(allErrors) > 0 {
		return allErrors
	}

	return nil
}
