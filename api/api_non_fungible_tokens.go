/*
Stacks Blockchain API

Welcome to the API reference overview for the <a href=\"https://docs.hiro.so/get-started/stacks-blockchain-api\">Stacks Blockchain API</a>.  <a href=\"https://hirosystems.github.io/stacks-blockchain-api/collection.json\" download=\"stacks-api-collection.json\">Download Postman collection</a> 

API version: v4.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// NonFungibleTokensApiService NonFungibleTokensApi service
type NonFungibleTokensApiService service

type ApiGetContractNFTMetadataRequest struct {
	ctx context.Context
	ApiService *NonFungibleTokensApiService
	contractId string
}

func (r ApiGetContractNFTMetadataRequest) Execute() (*NonFungibleTokenMetadata, *http.Response, error) {
	return r.ApiService.GetContractNFTMetadataExecute(r)
}

/*
GetContractNFTMetadata Non fungible tokens metadata for contract id

Retrieves metadata for non fungible tokens for a given contract id. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-NFTs).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId token's contract id
 @return ApiGetContractNFTMetadataRequest
*/
func (a *NonFungibleTokensApiService) GetContractNFTMetadata(ctx context.Context, contractId string) ApiGetContractNFTMetadataRequest {
	return ApiGetContractNFTMetadataRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return NonFungibleTokenMetadata
func (a *NonFungibleTokensApiService) GetContractNFTMetadataExecute(r ApiGetContractNFTMetadataRequest) (*NonFungibleTokenMetadata, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NonFungibleTokenMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonFungibleTokensApiService.GetContractNFTMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tokens/{contractId}/NFT/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterToString(r.contractId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNFTHistoryRequest struct {
	ctx context.Context
	ApiService *NonFungibleTokensApiService
	assetIdentifier *string
	value *string
	limit *int32
	offset *int32
	unanchored *bool
	txMetadata *bool
}

// token asset class identifier
func (r ApiGetNFTHistoryRequest) AssetIdentifier(assetIdentifier string) ApiGetNFTHistoryRequest {
	r.assetIdentifier = &assetIdentifier
	return r
}

// hex representation of the token&#39;s unique value
func (r ApiGetNFTHistoryRequest) Value(value string) ApiGetNFTHistoryRequest {
	r.value = &value
	return r
}

// max number of events to fetch
func (r ApiGetNFTHistoryRequest) Limit(limit int32) ApiGetNFTHistoryRequest {
	r.limit = &limit
	return r
}

// index of first event to fetch
func (r ApiGetNFTHistoryRequest) Offset(offset int32) ApiGetNFTHistoryRequest {
	r.offset = &offset
	return r
}

// whether or not to include events from unconfirmed transactions
func (r ApiGetNFTHistoryRequest) Unanchored(unanchored bool) ApiGetNFTHistoryRequest {
	r.unanchored = &unanchored
	return r
}

// whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times.
func (r ApiGetNFTHistoryRequest) TxMetadata(txMetadata bool) ApiGetNFTHistoryRequest {
	r.txMetadata = &txMetadata
	return r
}

func (r ApiGetNFTHistoryRequest) Execute() (*NonFungibleTokenHistoryEventList, *http.Response, error) {
	return r.ApiService.GetNFTHistoryExecute(r)
}

/*
GetNFTHistory Non-Fungible Token history

Retrieves all events relevant to a Non-Fungible Token. Useful to determine the ownership history of a particular asset.

More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-NFTs).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNFTHistoryRequest
*/
func (a *NonFungibleTokensApiService) GetNFTHistory(ctx context.Context) ApiGetNFTHistoryRequest {
	return ApiGetNFTHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NonFungibleTokenHistoryEventList
func (a *NonFungibleTokensApiService) GetNFTHistoryExecute(r ApiGetNFTHistoryRequest) (*NonFungibleTokenHistoryEventList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NonFungibleTokenHistoryEventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonFungibleTokensApiService.GetNFTHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tokens/NFT/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetIdentifier == nil {
		return localVarReturnValue, nil, reportError("assetIdentifier is required and must be specified")
	}
	if r.value == nil {
		return localVarReturnValue, nil, reportError("value is required and must be specified")
	}

	localVarQueryParams.Add("asset_identifier", parameterToString(*r.assetIdentifier, ""))
	localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	if r.txMetadata != nil {
		localVarQueryParams.Add("tx_metadata", parameterToString(*r.txMetadata, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNFTHoldingsRequest struct {
	ctx context.Context
	ApiService *NonFungibleTokensApiService
	principal *string
	assetIdentifiers *[]string
	limit *int32
	offset *int32
	unanchored *bool
	txMetadata *bool
}

// token owner&#39;s STX address or Smart Contract ID
func (r ApiGetNFTHoldingsRequest) Principal(principal string) ApiGetNFTHoldingsRequest {
	r.principal = &principal
	return r
}

// identifiers of the token asset classes to filter for
func (r ApiGetNFTHoldingsRequest) AssetIdentifiers(assetIdentifiers []string) ApiGetNFTHoldingsRequest {
	r.assetIdentifiers = &assetIdentifiers
	return r
}

// max number of tokens to fetch
func (r ApiGetNFTHoldingsRequest) Limit(limit int32) ApiGetNFTHoldingsRequest {
	r.limit = &limit
	return r
}

// index of first tokens to fetch
func (r ApiGetNFTHoldingsRequest) Offset(offset int32) ApiGetNFTHoldingsRequest {
	r.offset = &offset
	return r
}

// whether or not to include tokens from unconfirmed transactions
func (r ApiGetNFTHoldingsRequest) Unanchored(unanchored bool) ApiGetNFTHoldingsRequest {
	r.unanchored = &unanchored
	return r
}

// whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times.
func (r ApiGetNFTHoldingsRequest) TxMetadata(txMetadata bool) ApiGetNFTHoldingsRequest {
	r.txMetadata = &txMetadata
	return r
}

func (r ApiGetNFTHoldingsRequest) Execute() (*NonFungibleTokenHoldingsList, *http.Response, error) {
	return r.ApiService.GetNFTHoldingsExecute(r)
}

/*
GetNFTHoldings Non-Fungible Token holdings

Retrieves the list of Non-Fungible Tokens owned by the given principal (STX address or Smart Contract ID).
Results can be filtered by one or more asset identifiers and can include metadata about the transaction that made the principal own each token.

More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-NFTs).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNFTHoldingsRequest
*/
func (a *NonFungibleTokensApiService) GetNFTHoldings(ctx context.Context) ApiGetNFTHoldingsRequest {
	return ApiGetNFTHoldingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NonFungibleTokenHoldingsList
func (a *NonFungibleTokensApiService) GetNFTHoldingsExecute(r ApiGetNFTHoldingsRequest) (*NonFungibleTokenHoldingsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NonFungibleTokenHoldingsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonFungibleTokensApiService.GetNFTHoldings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tokens/NFT/holdings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.principal == nil {
		return localVarReturnValue, nil, reportError("principal is required and must be specified")
	}

	localVarQueryParams.Add("principal", parameterToString(*r.principal, ""))
	if r.assetIdentifiers != nil {
		t := *r.assetIdentifiers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asset_identifiers", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asset_identifiers", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	if r.txMetadata != nil {
		localVarQueryParams.Add("tx_metadata", parameterToString(*r.txMetadata, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNFTMetadataListRequest struct {
	ctx context.Context
	ApiService *NonFungibleTokensApiService
	limit *int32
	offset *int32
}

// max number of tokens to fetch
func (r ApiGetNFTMetadataListRequest) Limit(limit int32) ApiGetNFTMetadataListRequest {
	r.limit = &limit
	return r
}

// index of first tokens to fetch
func (r ApiGetNFTMetadataListRequest) Offset(offset int32) ApiGetNFTMetadataListRequest {
	r.offset = &offset
	return r
}

func (r ApiGetNFTMetadataListRequest) Execute() (*NonFungibleTokensMetadataList, *http.Response, error) {
	return r.ApiService.GetNFTMetadataListExecute(r)
}

/*
GetNFTMetadataList Non fungible tokens metadata list

Retrieves a list of non fungible tokens with their metadata. More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-NFTs).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNFTMetadataListRequest
*/
func (a *NonFungibleTokensApiService) GetNFTMetadataList(ctx context.Context) ApiGetNFTMetadataListRequest {
	return ApiGetNFTMetadataListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NonFungibleTokensMetadataList
func (a *NonFungibleTokensApiService) GetNFTMetadataListExecute(r ApiGetNFTMetadataListRequest) (*NonFungibleTokensMetadataList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NonFungibleTokensMetadataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonFungibleTokensApiService.GetNFTMetadataList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tokens/NFT/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNFTMintsRequest struct {
	ctx context.Context
	ApiService *NonFungibleTokensApiService
	assetIdentifier *string
	limit *int32
	offset *int32
	unanchored *bool
	txMetadata *bool
}

// token asset class identifier
func (r ApiGetNFTMintsRequest) AssetIdentifier(assetIdentifier string) ApiGetNFTMintsRequest {
	r.assetIdentifier = &assetIdentifier
	return r
}

// max number of events to fetch
func (r ApiGetNFTMintsRequest) Limit(limit int32) ApiGetNFTMintsRequest {
	r.limit = &limit
	return r
}

// index of first event to fetch
func (r ApiGetNFTMintsRequest) Offset(offset int32) ApiGetNFTMintsRequest {
	r.offset = &offset
	return r
}

// whether or not to include events from unconfirmed transactions
func (r ApiGetNFTMintsRequest) Unanchored(unanchored bool) ApiGetNFTMintsRequest {
	r.unanchored = &unanchored
	return r
}

// whether or not to include the complete transaction metadata instead of just &#x60;tx_id&#x60;. Enabling this option can affect performance and response times.
func (r ApiGetNFTMintsRequest) TxMetadata(txMetadata bool) ApiGetNFTMintsRequest {
	r.txMetadata = &txMetadata
	return r
}

func (r ApiGetNFTMintsRequest) Execute() (*NonFungibleTokenMintList, *http.Response, error) {
	return r.ApiService.GetNFTMintsExecute(r)
}

/*
GetNFTMints Non-Fungible Token mints

Retrieves all mint events for a Non-Fungible Token asset class. Useful to determine which NFTs of a particular collection have been claimed.

More information on Non-Fungible Tokens on the Stacks blockchain can be found [here](https://docs.stacks.co/write-smart-contracts/tokens#non-fungible-tokens-NFTs).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNFTMintsRequest
*/
func (a *NonFungibleTokensApiService) GetNFTMints(ctx context.Context) ApiGetNFTMintsRequest {
	return ApiGetNFTMintsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NonFungibleTokenMintList
func (a *NonFungibleTokensApiService) GetNFTMintsExecute(r ApiGetNFTMintsRequest) (*NonFungibleTokenMintList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NonFungibleTokenMintList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NonFungibleTokensApiService.GetNFTMints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tokens/NFT/mints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assetIdentifier == nil {
		return localVarReturnValue, nil, reportError("assetIdentifier is required and must be specified")
	}

	localVarQueryParams.Add("asset_identifier", parameterToString(*r.assetIdentifier, ""))
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.unanchored != nil {
		localVarQueryParams.Add("unanchored", parameterToString(*r.unanchored, ""))
	}
	if r.txMetadata != nil {
		localVarQueryParams.Add("tx_metadata", parameterToString(*r.txMetadata, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
