// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package api

// GetAddressMempoolTransactionsParams defines parameters for GetAddressMempoolTransactions.
type GetAddressMempoolTransactionsParams struct {
	// max number of transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetAccountAssetsParams defines parameters for GetAccountAssets.
type GetAccountAssetsParams struct {
	// max number of account assets to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first account assets to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state at that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountBalanceParams defines parameters for GetAccountBalance.
type GetAccountBalanceParams struct {
	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountNFTParams defines parameters for GetAccountNFT.
type GetAccountNFTParams struct {
	// number of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// number of items to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountNoncesParams defines parameters for GetAccountNonces.
type GetAccountNoncesParams struct {
	// Optionally get the nonce at a given block height
	BlockHeight *float32 `form:"block_height,omitempty" json:"block_height,omitempty"`

	// Optionally get the nonce at a given block hash
	BlockHash *string `form:"block_hash,omitempty" json:"block_hash,omitempty"`
}

// GetAccountSTXBalanceParams defines parameters for GetAccountSTXBalance.
type GetAccountSTXBalanceParams struct {
	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountInboundParams defines parameters for GetAccountInbound.
type GetAccountInboundParams struct {
	// number of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// number of items to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for transfers only at this given block height
	Height *float32 `form:"height,omitempty" json:"height,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountTransactionsParams defines parameters for GetAccountTransactions.
type GetAccountTransactionsParams struct {
	// max number of account transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first account transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for transactions only at this given block height
	Height *float32 `form:"height,omitempty" json:"height,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetAccountTransactionsWithTransfersParams defines parameters for GetAccountTransactionsWithTransfers.
type GetAccountTransactionsWithTransfersParams struct {
	// max number of account transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first account transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter for transactions only at this given block height
	Height *float32 `form:"height,omitempty" json:"height,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// returned data representing the state up until that point in time, rather than the current block.
	UntilBlock *string `form:"until_block,omitempty" json:"until_block,omitempty"`
}

// GetBlockListParams defines parameters for GetBlockList.
type GetBlockListParams struct {
	// max number of blocks to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first block to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetBurnchainRewardSlotHoldersParams defines parameters for GetBurnchainRewardSlotHolders.
type GetBurnchainRewardSlotHoldersParams struct {
	// max number of items to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of the first items to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetBurnchainRewardSlotHoldersByAddressParams defines parameters for GetBurnchainRewardSlotHoldersByAddress.
type GetBurnchainRewardSlotHoldersByAddressParams struct {
	// max number of items to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of the first items to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetBurnchainRewardListParams defines parameters for GetBurnchainRewardList.
type GetBurnchainRewardListParams struct {
	// max number of rewards to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first rewards to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetBurnchainRewardListByAddressParams defines parameters for GetBurnchainRewardListByAddress.
type GetBurnchainRewardListByAddressParams struct {
	// max number of rewards to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first rewards to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetContractsByTraitParams defines parameters for GetContractsByTrait.
type GetContractsByTraitParams struct {
	// JSON abi of the trait.
	TraitAbi string `form:"trait_abi" json:"trait_abi"`

	// max number of contracts fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first contract event to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetContractByIDParams defines parameters for GetContractByID.
type GetContractByIDParams struct {
	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetContractEventsByIDParams defines parameters for GetContractEventsByID.
type GetContractEventsByIDParams struct {
	// max number of contract events to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first contract event to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// RunFaucetBTCJSONBody defines parameters for RunFaucetBTC.
type RunFaucetBTCJSONBody struct {
	// BTC testnet address
	Address *string `json:"address,omitempty"`
}

// RunFaucetBTCParams defines parameters for RunFaucetBTC.
type RunFaucetBTCParams struct {
	// A valid testnet BTC address
	Address string `form:"address" json:"address"`
}

// RunFaucetSTXJSONBody defines parameters for RunFaucetSTX.
type RunFaucetSTXJSONBody struct {
	// STX testnet address
	Address *string `json:"address,omitempty"`

	// Use required number of tokens for stacking
	Stacking *bool `json:"stacking,omitempty"`
}

// RunFaucetSTXParams defines parameters for RunFaucetSTX.
type RunFaucetSTXParams struct {
	// A valid testnet STX address
	Address string `form:"address" json:"address"`

	// Request the amount of STX tokens needed for individual address stacking
	Stacking *bool `form:"stacking,omitempty" json:"stacking,omitempty"`
}

// FetchFeeRateJSONBody defines parameters for FetchFeeRate.
type FetchFeeRateJSONBody struct {
	// A serialized transaction
	Transaction string `json:"transaction"`
}

// GetNetworkBlockTimeByNetworkParamsNetwork defines parameters for GetNetworkBlockTimeByNetwork.
type GetNetworkBlockTimeByNetworkParamsNetwork string

// GetMicroblockListParams defines parameters for GetMicroblockList.
type GetMicroblockListParams struct {
	// Max number of microblocks to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Index of the first microblock to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchByIDParams defines parameters for SearchByID.
type SearchByIDParams struct {
	// This includes the detailed data for purticular hash in the response
	IncludeMetadata *bool `form:"include_metadata,omitempty" json:"include_metadata,omitempty"`
}

// GetSTXSupplyParams defines parameters for GetSTXSupply.
type GetSTXSupplyParams struct {
	// The block height at which to query supply details from, if not provided then the latest block height is used
	Height *float32 `form:"height,omitempty" json:"height,omitempty"`
}

// GetTotalSTXSupplyLegacyFormatParams defines parameters for GetTotalSTXSupplyLegacyFormat.
type GetTotalSTXSupplyLegacyFormatParams struct {
	// The block height at which to query supply details from, if not provided then the latest block height is used
	Height *float32 `form:"height,omitempty" json:"height,omitempty"`
}

// GetFTMetadataListParams defines parameters for GetFTMetadataList.
type GetFTMetadataListParams struct {
	// max number of tokens to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first tokens to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetNFTHistoryParams defines parameters for GetNFTHistory.
type GetNFTHistoryParams struct {
	// token asset class identifier
	AssetIdentifier string `form:"asset_identifier" json:"asset_identifier"`

	// hex representation of the token's unique value
	Value string `form:"value" json:"value"`

	// max number of events to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first event to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// whether or not to include events from unconfirmed transactions
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
	TxMetadata *bool `form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}

// GetNFTHoldingsParams defines parameters for GetNFTHoldings.
type GetNFTHoldingsParams struct {
	// token owner's STX address or Smart Contract ID
	Principal string `form:"principal" json:"principal"`

	// identifiers of the token asset classes to filter for
	AssetIdentifiers *[]string `form:"asset_identifiers,omitempty" json:"asset_identifiers,omitempty"`

	// max number of tokens to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first tokens to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// whether or not to include tokens from unconfirmed transactions
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
	TxMetadata *bool `form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}

// GetNFTMetadataListParams defines parameters for GetNFTMetadataList.
type GetNFTMetadataListParams struct {
	// max number of tokens to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first tokens to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetNFTMintsParams defines parameters for GetNFTMints.
type GetNFTMintsParams struct {
	// token asset class identifier
	AssetIdentifier string `form:"asset_identifier" json:"asset_identifier"`

	// max number of events to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first event to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// whether or not to include events from unconfirmed transactions
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`

	// whether or not to include the complete transaction metadata instead of just `tx_id`. Enabling this option can affect performance and response times.
	TxMetadata *bool `form:"tx_metadata,omitempty" json:"tx_metadata,omitempty"`
}

// GetTransactionListParams defines parameters for GetTransactionList.
type GetTransactionListParams struct {
	// max number of transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter by transaction type
	Type *[]GetTransactionListParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetTransactionListParamsType defines parameters for GetTransactionList.
type GetTransactionListParamsType string

// GetTransactionsByBlockHashParams defines parameters for GetTransactionsByBlockHash.
type GetTransactionsByBlockHashParams struct {
	// max number of transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTransactionsByBlockHeightParams defines parameters for GetTransactionsByBlockHeight.
type GetTransactionsByBlockHeightParams struct {
	// max number of transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetFilteredEventsParams defines parameters for GetFilteredEvents.
type GetFilteredEventsParams struct {
	// Hash of transaction
	TxId *string `form:"tx_id,omitempty" json:"tx_id,omitempty"`

	// Stacks address or a Contract identifier
	Address *string `form:"address,omitempty" json:"address,omitempty"`

	// number of items to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// number of items to skip
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Filter the events on event type
	Type *[]GetFilteredEventsParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetFilteredEventsParamsType defines parameters for GetFilteredEvents.
type GetFilteredEventsParamsType string

// GetMempoolTransactionListParams defines parameters for GetMempoolTransactionList.
type GetMempoolTransactionListParams struct {
	// Filter to only return transactions with this sender address.
	SenderAddress *string `form:"sender_address,omitempty" json:"sender_address,omitempty"`

	// Filter to only return transactions with this recipient address (only applicable for STX transfer tx types).
	RecipientAddress *string `form:"recipient_address,omitempty" json:"recipient_address,omitempty"`

	// Filter to only return transactions with this address as the sender or recipient (recipient only applicable for STX transfer tx types).
	Address *string `form:"address,omitempty" json:"address,omitempty"`

	// max number of mempool transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first mempool transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetDroppedMempoolTransactionListParams defines parameters for GetDroppedMempoolTransactionList.
type GetDroppedMempoolTransactionListParams struct {
	// max number of mempool transactions to fetch
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// index of first mempool transaction to fetch
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTXListDetailsParams defines parameters for GetTXListDetails.
type GetTXListDetailsParams struct {
	// Array of transaction ids
	TxId []string `form:"tx_id" json:"tx_id"`

	// The number of events to skip
	EventOffset *int `form:"event_offset,omitempty" json:"event_offset,omitempty"`

	// The numbers of events to return
	EventLimit *int `form:"event_limit,omitempty" json:"event_limit,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// GetTransactionByIDParams defines parameters for GetTransactionByID.
type GetTransactionByIDParams struct {
	// The number of events to skip
	EventOffset *int `form:"event_offset,omitempty" json:"event_offset,omitempty"`

	// The numbers of events to return
	EventLimit *int `form:"event_limit,omitempty" json:"event_limit,omitempty"`

	// Include transaction data from unanchored (i.e. unconfirmed) microblocks
	Unanchored *bool `form:"unanchored,omitempty" json:"unanchored,omitempty"`
}

// RosettaAccountBalanceJSONBody defines parameters for RosettaAccountBalance.
type RosettaAccountBalanceJSONBody struct {
	// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
	AccountIdentifier struct {
		// The address may be a cryptographic public key (or some encoding of it) or a provided username.
		Address string `json:"address"`

		// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
		SubAccount *struct {
			// The address may be a cryptographic public key (or some encoding of it) or a provided username.
			Address string `json:"address"`

			// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`
		} `json:"sub_account,omitempty"`
	} `json:"account_identifier"`

	// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
	BlockIdentifier *interface{} `json:"block_identifier,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
}

// RosettaBlockJSONBody defines parameters for RosettaBlock.
type RosettaBlockJSONBody struct {
	// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
	BlockIdentifier interface{} `json:"block_identifier"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
}

// RosettaBlockTransactionJSONBody defines parameters for RosettaBlockTransaction.
type RosettaBlockTransactionJSONBody struct {
	// When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
	BlockIdentifier interface{} `json:"block_identifier"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
	TransactionIdentifier struct {
		// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
		Hash string `json:"hash"`
	} `json:"transaction_identifier"`
}

// RosettaConstructionCombineJSONBody defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
	Signatures []struct {
		HexBytes string `json:"hex_bytes"`

		// PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
		PublicKey struct {
			// CurveType is the type of cryptographic curve associated with a PublicKey.
			CurveType RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType `json:"curve_type"`

			// Hex-encoded public key bytes in the format specified by the CurveType.
			HexBytes string `json:"hex_bytes"`
		} `json:"public_key"`

		// SignatureType is the type of a cryptographic signature.
		SignatureType RosettaConstructionCombineJSONBodySignaturesSignatureType `json:"signature_type"`

		// SigningPayload is signed by the client with the keypair associated with an address using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
		SigningPayload struct {
			// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
			AccountIdentifier *struct {
				// The address may be a cryptographic public key (or some encoding of it) or a provided username.
				Address string `json:"address"`

				// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
				SubAccount *struct {
					// The address may be a cryptographic public key (or some encoding of it) or a provided username.
					Address string `json:"address"`

					// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
					Metadata *map[string]interface{} `json:"metadata,omitempty"`
				} `json:"sub_account,omitempty"`
			} `json:"account_identifier,omitempty"`

			// [DEPRECATED by account_identifier in v1.4.4] The network-specific address of the account that should sign the payload.
			Address  *string `json:"address,omitempty"`
			HexBytes string  `json:"hex_bytes"`

			// SignatureType is the type of a cryptographic signature.
			SignatureType *RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType `json:"signature_type,omitempty"`
		} `json:"signing_payload"`
	} `json:"signatures"`
	UnsignedTransaction string `json:"unsigned_transaction"`
}

// RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesPublicKeyCurveType string

// RosettaConstructionCombineJSONBodySignaturesSignatureType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesSignatureType string

// RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType defines parameters for RosettaConstructionCombine.
type RosettaConstructionCombineJSONBodySignaturesSigningPayloadSignatureType string

// RosettaConstructionDeriveJSONBody defines parameters for RosettaConstructionDerive.
type RosettaConstructionDeriveJSONBody struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
	PublicKey struct {
		// CurveType is the type of cryptographic curve associated with a PublicKey.
		CurveType RosettaConstructionDeriveJSONBodyPublicKeyCurveType `json:"curve_type"`

		// Hex-encoded public key bytes in the format specified by the CurveType.
		HexBytes string `json:"hex_bytes"`
	} `json:"public_key"`
}

// RosettaConstructionDeriveJSONBodyPublicKeyCurveType defines parameters for RosettaConstructionDerive.
type RosettaConstructionDeriveJSONBodyPublicKeyCurveType string

// RosettaConstructionHashJSONBody defines parameters for RosettaConstructionHash.
type RosettaConstructionHashJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// Signed transaction
	SignedTransaction string `json:"signed_transaction"`
}

// RosettaConstructionMetadataJSONBody defines parameters for RosettaConstructionMetadata.
type RosettaConstructionMetadataJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// The options that will be sent directly to /construction/metadata by the caller.
	Options struct {
		// Amount to be transfered.
		Amount *string `json:"amount,omitempty"`

		// Set the burnchain (BTC) block for stacking lock to start.
		BurnBlockHeight *int `json:"burn_block_height,omitempty"`

		// Address of the contract to call.
		ContractAddress *string `json:"contract_address,omitempty"`

		// Name of the contract to call.
		ContractName *string `json:"contract_name,omitempty"`

		// Number of decimal places
		Decimals *int `json:"decimals,omitempty"`

		// Delegator address for when calling `delegate-stacking`.
		DelegateTo *string `json:"delegate_to,omitempty"`

		// Fee for this transaction
		Fee *string `json:"fee,omitempty"`

		// Maximum price a user is willing to pay.
		GasLimit *float32 `json:"gas_limit,omitempty"`

		// Cost necessary to perform a transaction on the network
		GasPrice *float32 `json:"gas_price,omitempty"`

		// Maximum fee user is willing to pay
		MaxFee *string `json:"max_fee,omitempty"`

		// STX token transfer memo.
		Memo *string `json:"memo,omitempty"`

		// Number of cycles when stacking.
		NumberOfCycles *int `json:"number_of_cycles,omitempty"`

		// The reward address for stacking transaction. It should be a valid Bitcoin address
		PoxAddr *string `json:"pox_addr,omitempty"`

		// sender's address
		SenderAddress *string `json:"sender_address,omitempty"`

		// Transaction approximative size (used to calculate total fee).
		Size *int `json:"size,omitempty"`

		// This value indicates the state of the operations
		Status *string `json:"status,omitempty"`

		//  A suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency.
		SuggestedFeeMultiplier *float32 `json:"suggested_fee_multiplier,omitempty"`

		// Currency symbol e.g STX
		Symbol *string `json:"symbol,omitempty"`

		// Recipient's address
		TokenTransferRecipientAddress *string `json:"token_transfer_recipient_address,omitempty"`

		// Type of operation e.g transfer
		Type *string `json:"type,omitempty"`
	} `json:"options"`
	PublicKeys *[]struct {
		// CurveType is the type of cryptographic curve associated with a PublicKey.
		CurveType RosettaConstructionMetadataJSONBodyPublicKeysCurveType `json:"curve_type"`

		// Hex-encoded public key bytes in the format specified by the CurveType.
		HexBytes string `json:"hex_bytes"`
	} `json:"public_keys,omitempty"`
}

// RosettaConstructionMetadataJSONBodyPublicKeysCurveType defines parameters for RosettaConstructionMetadata.
type RosettaConstructionMetadataJSONBodyPublicKeysCurveType string

// RosettaConstructionParseJSONBody defines parameters for RosettaConstructionParse.
type RosettaConstructionParseJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// Signed is a boolean indicating whether the transaction is signed.
	Signed bool `json:"signed"`

	// This must be either the unsigned transaction blob returned by /construction/payloads or the signed transaction blob returned by /construction/combine.
	Transaction string `json:"transaction"`
}

// RosettaConstructionPayloadsJSONBody defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBody struct {
	Metadata *struct {
		AccountSequence *int    `json:"account_sequence,omitempty"`
		RecentBlockHash *string `json:"recent_block_hash,omitempty"`
	} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
	Operations []struct {
		// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
		Account *struct {
			// The address may be a cryptographic public key (or some encoding of it) or a provided username.
			Address string `json:"address"`

			// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
			SubAccount *struct {
				// The address may be a cryptographic public key (or some encoding of it) or a provided username.
				Address string `json:"address"`

				// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`
			} `json:"sub_account,omitempty"`
		} `json:"account,omitempty"`

		// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
		Amount *struct {
			// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
			Currency struct {
				// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
				Decimals int `json:"decimals"`

				// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// Canonical symbol associated with a currency.
				Symbol string `json:"symbol"`
			} `json:"currency"`
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
			Value string `json:"value"`
		} `json:"amount,omitempty"`

		// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
		CoinChange *struct {
			// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
			CoinAction RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction `json:"coin_action"`

			// CoinIdentifier uniquely identifies a Coin.
			CoinIdentifier struct {
				// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
				Identifier string `json:"identifier"`
			} `json:"coin_identifier"`
		} `json:"coin_change,omitempty"`

		// Operations Meta Data
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// The operation_identifier uniquely identifies an operation within a transaction.
		OperationIdentifier struct {
			// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
			Index int `json:"index"`

			// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
			NetworkIndex *int `json:"network_index,omitempty"`
		} `json:"operation_identifier"`

		// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
		RelatedOperations *[]struct {
			// Describes the index of related operation.
			Index int `json:"index"`

			// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
			NetworkIndex *int `json:"network_index,omitempty"`
		} `json:"related_operations,omitempty"`

		// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
		Status *string `json:"status,omitempty"`

		// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
		Type string `json:"type"`
	} `json:"operations"`
	PublicKeys *[]struct {
		// CurveType is the type of cryptographic curve associated with a PublicKey.
		CurveType RosettaConstructionPayloadsJSONBodyPublicKeysCurveType `json:"curve_type"`

		// Hex-encoded public key bytes in the format specified by the CurveType.
		HexBytes string `json:"hex_bytes"`
	} `json:"public_keys,omitempty"`
}

// RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBodyOperationsCoinChangeCoinAction string

// RosettaConstructionPayloadsJSONBodyPublicKeysCurveType defines parameters for RosettaConstructionPayloads.
type RosettaConstructionPayloadsJSONBodyPublicKeysCurveType string

// RosettaConstructionPreprocessJSONBody defines parameters for RosettaConstructionPreprocess.
type RosettaConstructionPreprocessJSONBody struct {
	MaxFee *[]struct {
		// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
		Currency struct {
			// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
			Decimals int `json:"decimals"`

			// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Canonical symbol associated with a currency.
			Symbol string `json:"symbol"`
		} `json:"currency"`
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
		Value string `json:"value"`
	} `json:"max_fee,omitempty"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
	Operations []struct {
		// The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
		Account *struct {
			// The address may be a cryptographic public key (or some encoding of it) or a provided username.
			Address string `json:"address"`

			// Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
			SubAccount *struct {
				// The address may be a cryptographic public key (or some encoding of it) or a provided username.
				Address string `json:"address"`

				// If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`
			} `json:"sub_account,omitempty"`
		} `json:"account,omitempty"`

		// Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
		Amount *struct {
			// Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
			Currency struct {
				// Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
				Decimals int `json:"decimals"`

				// Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// Canonical symbol associated with a currency.
				Symbol string `json:"symbol"`
			} `json:"currency"`
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
			Value string `json:"value"`
		} `json:"amount,omitempty"`

		// CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don't populate this model).
		CoinChange *struct {
			// CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
			CoinAction RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction `json:"coin_action"`

			// CoinIdentifier uniquely identifies a Coin.
			CoinIdentifier struct {
				// Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
				Identifier string `json:"identifier"`
			} `json:"coin_identifier"`
		} `json:"coin_change,omitempty"`

		// Operations Meta Data
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// The operation_identifier uniquely identifies an operation within a transaction.
		OperationIdentifier struct {
			// The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
			Index int `json:"index"`

			// Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
			NetworkIndex *int `json:"network_index,omitempty"`
		} `json:"operation_identifier"`

		// Restrict referenced related_operations to identifier indexes < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
		RelatedOperations *[]struct {
			// Describes the index of related operation.
			Index int `json:"index"`

			// Some blockchains specify an operation index that is essential for client use. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
			NetworkIndex *int `json:"network_index,omitempty"`
		} `json:"related_operations,omitempty"`

		// The network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply. Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation.
		Status *string `json:"status,omitempty"`

		// The network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkStatus. This can be very useful to downstream consumers that parse all block data.
		Type string `json:"type"`
	} `json:"operations"`

	//  The caller can also provide a suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency. It is assumed that providing a very low multiplier (like 0.0001) will never lead to a transaction being created with a fee less than the minimum network fee (if applicable). In the case that the caller provides both a max fee and a suggested fee multiplier, the max fee will set an upper bound on the suggested fee (regardless of the multiplier provided).
	SuggestedFeeMultiplier *int `json:"suggested_fee_multiplier,omitempty"`
}

// RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction defines parameters for RosettaConstructionPreprocess.
type RosettaConstructionPreprocessJSONBodyOperationsCoinChangeCoinAction string

// RosettaConstructionSubmitJSONBody defines parameters for RosettaConstructionSubmit.
type RosettaConstructionSubmitJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// Signed transaction
	SignedTransaction string `json:"signed_transaction"`
}

// RosettaMempoolJSONBody defines parameters for RosettaMempool.
type RosettaMempoolJSONBody struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
}

// RosettaMempoolTransactionJSONBody defines parameters for RosettaMempoolTransaction.
type RosettaMempoolTransactionJSONBody struct {
	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`

	// The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
	TransactionIdentifier struct {
		// Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
		Hash string `json:"hash"`
	} `json:"transaction_identifier"`
}

// RosettaNetworkOptionsJSONBody defines parameters for RosettaNetworkOptions.
type RosettaNetworkOptionsJSONBody struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
}

// RosettaNetworkStatusJSONBody defines parameters for RosettaNetworkStatus.
type RosettaNetworkStatusJSONBody struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier struct {
		// Blockchain name
		Blockchain string `json:"blockchain"`

		// If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
		Network string `json:"network"`

		// In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
		SubNetworkIdentifier *struct {
			// Meta data from subnetwork identifier
			Metadata *struct {
				// producer
				Producer string `json:"producer"`
			} `json:"metadata,omitempty"`

			// Network name
			Network string `json:"network"`
		} `json:"sub_network_identifier,omitempty"`
	} `json:"network_identifier"`
}

// GetAllNamesParams defines parameters for GetAllNames.
type GetAllNamesParams struct {
	// names are returned in pages of size 100, so specify the page number.
	Page int `form:"page" json:"page"`
}

// GetNamespaceNamesParams defines parameters for GetNamespaceNames.
type GetNamespaceNamesParams struct {
	// names are returned in pages of size 100, so specify the page number.
	Page int `form:"page" json:"page"`
}

// GetAccountInfoParams defines parameters for GetAccountInfo.
type GetAccountInfoParams struct {
	// Returns object without the proof field if set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// The Stacks chain tip to query from
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// CallReadOnlyFunctionJSONBody defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionJSONBody struct {
	// An array of hex serialized Clarity values
	Arguments []string `json:"arguments"`

	// The simulated tx-sender
	Sender string `json:"sender"`
}

// CallReadOnlyFunctionParams defines parameters for CallReadOnlyFunction.
type CallReadOnlyFunctionParams struct {
	// The Stacks chain tip to query from
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetContractInterfaceParams defines parameters for GetContractInterface.
type GetContractInterfaceParams struct {
	// The Stacks chain tip to query from
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// GetContractSourceParams defines parameters for GetContractSource.
type GetContractSourceParams struct {
	// Returns object without the proof field if set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// The Stacks chain tip to query from
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// PostFeeTransactionJSONBody defines parameters for PostFeeTransaction.
type PostFeeTransactionJSONBody struct {
	EstimatedLen       *int   `json:"estimated_len,omitempty"`
	TransactionPayload string `json:"transaction_payload"`
}

// GetContractDataMapEntryJSONBody defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryJSONBody = string

// GetContractDataMapEntryParams defines parameters for GetContractDataMapEntry.
type GetContractDataMapEntryParams struct {
	// Returns object without the proof field when set to 0
	Proof *int `form:"proof,omitempty" json:"proof,omitempty"`

	// The Stacks chain tip to query from
	Tip *string `form:"tip,omitempty" json:"tip,omitempty"`
}

// RunFaucetBTCJSONRequestBody defines body for RunFaucetBTC for application/json ContentType.
type RunFaucetBTCJSONRequestBody RunFaucetBTCJSONBody

// RunFaucetSTXJSONRequestBody defines body for RunFaucetSTX for application/json ContentType.
type RunFaucetSTXJSONRequestBody RunFaucetSTXJSONBody

// FetchFeeRateJSONRequestBody defines body for FetchFeeRate for application/json ContentType.
type FetchFeeRateJSONRequestBody FetchFeeRateJSONBody

// RosettaAccountBalanceJSONRequestBody defines body for RosettaAccountBalance for application/json ContentType.
type RosettaAccountBalanceJSONRequestBody RosettaAccountBalanceJSONBody

// RosettaBlockJSONRequestBody defines body for RosettaBlock for application/json ContentType.
type RosettaBlockJSONRequestBody RosettaBlockJSONBody

// RosettaBlockTransactionJSONRequestBody defines body for RosettaBlockTransaction for application/json ContentType.
type RosettaBlockTransactionJSONRequestBody RosettaBlockTransactionJSONBody

// RosettaConstructionCombineJSONRequestBody defines body for RosettaConstructionCombine for application/json ContentType.
type RosettaConstructionCombineJSONRequestBody RosettaConstructionCombineJSONBody

// RosettaConstructionDeriveJSONRequestBody defines body for RosettaConstructionDerive for application/json ContentType.
type RosettaConstructionDeriveJSONRequestBody RosettaConstructionDeriveJSONBody

// RosettaConstructionHashJSONRequestBody defines body for RosettaConstructionHash for application/json ContentType.
type RosettaConstructionHashJSONRequestBody RosettaConstructionHashJSONBody

// RosettaConstructionMetadataJSONRequestBody defines body for RosettaConstructionMetadata for application/json ContentType.
type RosettaConstructionMetadataJSONRequestBody RosettaConstructionMetadataJSONBody

// RosettaConstructionParseJSONRequestBody defines body for RosettaConstructionParse for application/json ContentType.
type RosettaConstructionParseJSONRequestBody RosettaConstructionParseJSONBody

// RosettaConstructionPayloadsJSONRequestBody defines body for RosettaConstructionPayloads for application/json ContentType.
type RosettaConstructionPayloadsJSONRequestBody RosettaConstructionPayloadsJSONBody

// RosettaConstructionPreprocessJSONRequestBody defines body for RosettaConstructionPreprocess for application/json ContentType.
type RosettaConstructionPreprocessJSONRequestBody RosettaConstructionPreprocessJSONBody

// RosettaConstructionSubmitJSONRequestBody defines body for RosettaConstructionSubmit for application/json ContentType.
type RosettaConstructionSubmitJSONRequestBody RosettaConstructionSubmitJSONBody

// RosettaMempoolJSONRequestBody defines body for RosettaMempool for application/json ContentType.
type RosettaMempoolJSONRequestBody RosettaMempoolJSONBody

// RosettaMempoolTransactionJSONRequestBody defines body for RosettaMempoolTransaction for application/json ContentType.
type RosettaMempoolTransactionJSONRequestBody RosettaMempoolTransactionJSONBody

// RosettaNetworkOptionsJSONRequestBody defines body for RosettaNetworkOptions for application/json ContentType.
type RosettaNetworkOptionsJSONRequestBody RosettaNetworkOptionsJSONBody

// RosettaNetworkStatusJSONRequestBody defines body for RosettaNetworkStatus for application/json ContentType.
type RosettaNetworkStatusJSONRequestBody RosettaNetworkStatusJSONBody

// CallReadOnlyFunctionJSONRequestBody defines body for CallReadOnlyFunction for application/json ContentType.
type CallReadOnlyFunctionJSONRequestBody CallReadOnlyFunctionJSONBody

// PostFeeTransactionJSONRequestBody defines body for PostFeeTransaction for application/json ContentType.
type PostFeeTransactionJSONRequestBody PostFeeTransactionJSONBody

// GetContractDataMapEntryJSONRequestBody defines body for GetContractDataMapEntry for application/json ContentType.
type GetContractDataMapEntryJSONRequestBody = GetContractDataMapEntryJSONBody
